diff --git a/Makefile.am b/Makefile.am
index 1487619..3cc73c7 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -1,7 +1,7 @@
 ## Makefile.am for GTK+
 include $(top_srcdir)/Makefile.decl
 
-SRC_SUBDIRS = gdk gtk modules
+SRC_SUBDIRS = gdk gtk
 SUBDIRS = $(SRC_SUBDIRS) m4macros build
 
 # require automake 1.4
diff --git a/configure.ac b/configure.ac
index d2f117d..4753065 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1240,129 +1240,6 @@ GDK_PIXBUF_LIBS=`$PKG_CONFIG --libs gdk-pixbuf-2.0`
 AC_SUBST(GDK_PIXBUF_LIBS)
 
 
-################################################################
-# Printing system checks
-################################################################
-
-AC_ARG_ENABLE(cups,
-              [AC_HELP_STRING([--disable-cups]
-                              [disable cups print backend])],,
-              [enable_cups=auto])
-
-if test "x$enable_cups" = "xno"; then
-  AM_CONDITIONAL(HAVE_CUPS, false)
-else
-  AC_PATH_TOOL(CUPS_CONFIG, cups-config, no)
-  if test "x$CUPS_CONFIG" = "xno"; then
-    if test "x$enable_cups" = "xauto"; then
-      AM_CONDITIONAL(HAVE_CUPS, false)
-    else
-      AC_MSG_ERROR([
-*** cups not found.
-])
-    fi
-  else
-    CUPS_CFLAGS=`$CUPS_CONFIG --cflags | sed 's/-O[0-9]*//' | sed 's/-m[^\t]*//g'`
-    CUPS_LIBS=`$CUPS_CONFIG --libs`
-
-    CUPS_API_VERSION=`$CUPS_CONFIG --api-version`
-    CUPS_API_MAJOR=`echo $ECHO_N $CUPS_API_VERSION | awk -F. '{print $1}'`
-    CUPS_API_MINOR=`echo $ECHO_N $CUPS_API_VERSION | awk -F. '{print $2}'`
-
-    if test $CUPS_API_MAJOR -gt 1 -o \
-            $CUPS_API_MAJOR -eq 1 -a $CUPS_API_MINOR -ge 2; then
-      AC_DEFINE(HAVE_CUPS_API_1_2, 1, 
-                [Define to 1 if CUPS 1.2 API is available])
-    fi
-    if test $CUPS_API_MAJOR -gt 1 -o \
-	    $CUPS_API_MAJOR -eq 1 -a $CUPS_API_MINOR -ge 6; then
-      AC_DEFINE(HAVE_CUPS_API_1_6, 1,
-                [Define to 1 if CUPS 1.6 API is available])
-      have_cups_api_1_6=yes
-    fi
-
-    AC_SUBST(CUPS_API_MAJOR)
-    AC_SUBST(CUPS_API_MINOR)
-    AC_SUBST(CUPS_CFLAGS)
-    AC_SUBST(CUPS_LIBS)
-
-    AC_CHECK_HEADER(cups/cups.h,,AC_MSG_ERROR([[*** Sorry, cups-config present but cups/cups.h missing.]]))
-
-    AM_CONDITIONAL(HAVE_CUPS, true)
-
-    gtk_save_cflags="$CFLAGS"
-    CFLAGS="$CUPS_CFLAGS"
-    AC_TRY_COMPILE([#include <cups/http.h>],
-                   [http_t http; char *s = http.authstring;],
-                   [AC_DEFINE(HAVE_HTTP_AUTHSTRING, [],
-                              [Define if cups http_t authstring field is accessible])],)
-    CFLAGS="$gtk_save_cflags"
-
-    AC_SUBST(HAVE_HTTP_AUTHSTRING)
-
-    gtk_save_libs="$LIBS"
-    LIBS="$CUPS_LIBS"
-    AC_CHECK_FUNCS(httpGetAuthString)
-    LIBS="$gtk_save_libs"
-  fi
-fi
-
-# Checks to see if we should compile with PAPI backend for GTK+
-#
-
-AC_ARG_ENABLE(papi,
-              [AC_HELP_STRING([--disable-papi]
-                              [disable papi print backend])],,
-             [enable_papi=auto])
-
-if test "x$enable_papi" = "xno"; then
-  AM_CONDITIONAL(HAVE_PAPI, false)
-else
-  AC_MSG_CHECKING(libpapi)
-  AC_CHECK_LIB(papi, papiServiceCreate, have_papi=yes, have_papi=no)
-  if test $have_papi = yes; then
-    AC_DEFINE([HAVE_PAPI], [], [Define to 1 if libpapi available])
-  fi
-  AM_CONDITIONAL(HAVE_PAPI, test $have_papi = yes)
-  if test "x$enable_papi" = "xyes" -a "x$have_papi" = "xno"; then
-    AC_MSG_ERROR([
-*** papi not found.
-])
-  fi
-fi
-
-AM_CONDITIONAL(HAVE_PAPI_CUPS, test "x$have_papi" = "xyes" -a "x$CUPS_CONFIG" != "xno")
-
-gtk_save_cppflags="$CPPFLAGS"
-CPPFLAGS="$CPPFLAGS $GTK_DEP_CFLAGS $GDK_DEP_CFLAGS"
-
-AC_CHECK_HEADER(cairo-pdf.h,,AC_MSG_ERROR([
-*** Can't find cairo-pdf.h. You must build Cairo with the pdf
-*** backend enabled.]))
-
-if test "$os_win32" != "yes"; then
-  AC_CHECK_HEADER(cairo-ps.h,,AC_MSG_ERROR([
-*** Can't find cairo-ps.h. You must build Cairo with the 
-*** postscript backend enabled.]))
-
-  AC_CHECK_HEADER(cairo-svg.h,,AC_MSG_ERROR([
-*** Can't find cairo-svg.h. You must build Cairo with the
-*** svg backend enabled.]))
-fi   
-
-CPPFLAGS="$gtk_save_cppflags"
-     
-			  	
-AC_ARG_ENABLE(test-print-backend,
-              [AC_HELP_STRING([--enable-test-print-backend],
-                              [build test print backend])],,
-              [enable_test_print_backend=no])
-AM_CONDITIONAL(TEST_PRINT_BACKEND, test "x$enable_test_print_backend" != "xno")
-
-if test "$os_win32" = "yes"; then
-  AC_CHECK_TYPES([IPrintDialogCallback],[],[],[[#include <windows.h>]])
-fi
-
 ################################################################
 # Strip -export-dynamic from the link lines of various libraries
 ################################################################
@@ -1518,12 +1395,6 @@ gdk/x11/Makefile
 gdk/directfb/Makefile
 gtk/Makefile
 gtk/gtkversion.h
-modules/Makefile
-modules/printbackends/Makefile
-modules/printbackends/cups/Makefile
-modules/printbackends/lpr/Makefile
-modules/printbackends/file/Makefile
-modules/printbackends/papi/Makefile
 ])
 
 AC_OUTPUT
diff --git a/gtk/Makefile.am b/gtk/Makefile.am
index a3173fb..6d92f43 100644
--- a/gtk/Makefile.am
+++ b/gtk/Makefile.am
@@ -19,20 +19,6 @@ endif
 SUBDIRS = .
 DIST_SUBDIRS=
 
-if HAVE_PAPI_CUPS
-GTK_PRINT_BACKENDS=file,papi,cups
-else
-if HAVE_CUPS
-GTK_PRINT_BACKENDS=file,cups
-else
-if HAVE_PAPI
-GTK_PRINT_BACKENDS=file,papi
-else
-GTK_PRINT_BACKENDS=file,lpr
-endif
-endif
-endif
-
 # manually remove if wanted
 # grep for DISABLE_PRINTING_BACKENDS to easly find
 #GTK_PRINT_BACKENDS=
diff --git a/modules/Makefile.am b/modules/Makefile.am
deleted file mode 100644
index f80912b..0000000
--- a/modules/Makefile.am
+++ /dev/null
@@ -1,9 +0,0 @@
-include $(top_srcdir)/Makefile.decl
-
-SUBDIRS =
-
-if OS_UNIX
-SUBDIRS += printbackends
-endif
-
--include $(top_srcdir)/git.mk
diff --git a/modules/printbackends/Makefile.am b/modules/printbackends/Makefile.am
deleted file mode 100644
index 63d9d5c..0000000
--- a/modules/printbackends/Makefile.am
+++ /dev/null
@@ -1,15 +0,0 @@
-include $(top_srcdir)/Makefile.decl
-
-SUBDIRS = file lpr
-
-if HAVE_CUPS
-SUBDIRS += cups
-endif
-
-if HAVE_PAPI
-SUBDIRS += papi
-endif
-
-DIST_SUBDIRS = cups file lpr papi
-
--include $(top_srcdir)/git.mk
diff --git a/modules/printbackends/cups/Makefile.am b/modules/printbackends/cups/Makefile.am
deleted file mode 100644
index 463199e..0000000
--- a/modules/printbackends/cups/Makefile.am
+++ /dev/null
@@ -1,37 +0,0 @@
-include $(top_srcdir)/Makefile.decl
-
-
-INCLUDES = \
-	-I$(top_srcdir) 				\
-	-I$(top_srcdir)/gtk				\
-	-I$(top_builddir)/gtk				\
-	-I$(top_srcdir)/gdk				\
-	-I$(top_builddir)/gdk				\
-	$(CUPS_CFLAGS)					\
-	-DGTK_PRINT_BACKEND_ENABLE_UNSUPPORTED		\
-	$(GTK_DEP_CFLAGS)				\
-	$(GTK_DEBUG_FLAGS)
-
-LDADDS = \
-	$(top_builddir)/gtk/$(gtktargetlib)		\
-	$(top_builddir)/gdk/$(gdktargetlib)		\
-	$(GTK_DEP_LIBS)
-
-backenddir = $(libdir)/gtk-2.0/$(GTK_BINARY_VERSION)/printbackends
-
-backend_LTLIBRARIES = libprintbackend-cups.la
-
-libprintbackend_cups_la_SOURCES =	\
-	gtkprintbackendcups.c		\
-	gtkprintercups.c		\
-	gtkcupsutils.c
-
-noinst_HEADERS =			\
-	gtkprintbackendcups.h		\
-	gtkprintercups.h		\
-	gtkcupsutils.h
-
-libprintbackend_cups_la_LDFLAGS =  -avoid-version -module $(no_undefined)
-libprintbackend_cups_la_LIBADD = $(LDADDS) $(CUPS_LIBS)
-
--include $(top_srcdir)/git.mk
diff --git a/modules/printbackends/cups/gtkcupsutils.c b/modules/printbackends/cups/gtkcupsutils.c
deleted file mode 100644
index dbf9d51..0000000
--- a/modules/printbackends/cups/gtkcupsutils.c
+++ /dev/null
@@ -1,1681 +0,0 @@
-/* GTK - The GIMP Toolkit
- * gtkcupsutils.h: Statemachine implementation of POST and GET 
- * cups calls which can be used to create a non-blocking cups API
- * Copyright (C) 2006, 2007 Red Hat, Inc.
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-#include "config.h"
-#include <gtk/gtk.h>
-#include "gtkcupsutils.h"
-
-#include <errno.h>
-#include <unistd.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <stdlib.h>
-#include <time.h>
-#include <fcntl.h>
-#include <sys/socket.h>
-
-typedef void (*GtkCupsRequestStateFunc) (GtkCupsRequest *request);
-
-static void _connect            (GtkCupsRequest *request);
-static void _post_send          (GtkCupsRequest *request);
-static void _post_write_request (GtkCupsRequest *request);
-static void _post_write_data    (GtkCupsRequest *request);
-static void _post_check         (GtkCupsRequest *request);
-static void _post_auth          (GtkCupsRequest *request);
-static void _post_read_response (GtkCupsRequest *request);
-
-static void _get_send           (GtkCupsRequest *request);
-static void _get_check          (GtkCupsRequest *request);
-static void _get_auth           (GtkCupsRequest *request);
-static void _get_read_data      (GtkCupsRequest *request);
-
-struct _GtkCupsResult
-{
-  gchar *error_msg;
-  ipp_t *ipp_response;
-  GtkCupsErrorType error_type;
-
-  /* some error types like HTTP_ERROR have a status and a code */
-  int error_status;            
-  int error_code;
-
-  guint is_error : 1;
-  guint is_ipp_response : 1;
-};
-
-
-#define _GTK_CUPS_MAX_ATTEMPTS 10 
-#define _GTK_CUPS_MAX_CHUNK_SIZE 8192
-
-static GtkCupsRequestStateFunc post_states[] = {
-  _connect,
-  _post_send,
-  _post_write_request,
-  _post_write_data,
-  _post_check,
-  _post_auth,
-  _post_read_response
-};
-
-static GtkCupsRequestStateFunc get_states[] = {
-  _connect,
-  _get_send,
-  _get_check,
-  _get_auth,
-  _get_read_data
-};
-
-#ifndef HAVE_CUPS_API_1_6
-#define ippSetOperation(ipp_request, ipp_op_id) ipp_request->request.op.operation_id = ipp_op_id
-#define ippSetRequestId(ipp_request, ipp_rq_id) ipp_request->request.op.request_id = ipp_rq_id
-#define ippSetState(ipp_request, ipp_state) ipp_request->state = ipp_state
-#define ippGetString(attr, index, foo) attr->values[index].string.text
-#define ippGetCount(attr) attr->num_values
-
-int
-ippSetVersion (ipp_t *ipp,
-               int    major,
-               int    minor)
-{
-  if (!ipp || major < 0 || minor < 0)
-    return 0;
-
-  ipp->request.any.version[0] = major;
-  ipp->request.any.version[1] = minor;
-
-  return 1;
-}
-#endif
-
-static void
-gtk_cups_result_set_error (GtkCupsResult    *result,
-                           GtkCupsErrorType  error_type,
-                           int               error_status,
-                           int               error_code, 
-                           const char       *error_msg,
-			   ...)
-{
-  va_list args;
-
-  result->is_ipp_response = FALSE;
-  result->is_error = TRUE;
-  result->error_type = error_type;
-  result->error_status = error_status;
-  result->error_code = error_code;
-
-  va_start (args, error_msg);
-  result->error_msg = g_strdup_vprintf (error_msg, args);
-  va_end (args);
-}
-
-GtkCupsRequest *
-gtk_cups_request_new_with_username (http_t             *connection,
-                                    GtkCupsRequestType  req_type, 
-                                    gint                operation_id,
-                                    GIOChannel         *data_io,
-                                    const char         *server,
-                                    const char         *resource,
-                                    const char         *username)
-{
-  GtkCupsRequest *request;
-  cups_lang_t *language;
-  
-  request = g_new0 (GtkCupsRequest, 1);
-  request->result = g_new0 (GtkCupsResult, 1);
-
-  request->result->error_msg = NULL;
-  request->result->ipp_response = NULL;
-
-  request->result->is_error = FALSE;
-  request->result->is_ipp_response = FALSE;
-
-  request->type = req_type;
-  request->state = GTK_CUPS_REQUEST_START;
-
-  request->password_state = GTK_CUPS_PASSWORD_NONE;
-
-   if (server)
-    request->server = g_strdup (server);
-  else
-    request->server = g_strdup (cupsServer ());
-
-
-  if (resource)
-    request->resource = g_strdup (resource);
-  else
-    request->resource = g_strdup ("/");
- 
-  if (connection != NULL)
-    {
-      request->http = connection;
-      request->own_http = FALSE;
-    }
-  else
-    {
-      request->http = NULL;
-      request->http = httpConnectEncrypt (request->server, 
-                                          ippPort (), 
-                                          cupsEncryption ());
-
-      if (request->http)
-        httpBlocking (request->http, 0);
-        
-      request->own_http = TRUE;
-    }
-
-  request->last_status = HTTP_CONTINUE;
-
-  request->attempts = 0;
-  request->data_io = data_io;
-
-  request->ipp_request = ippNew ();
-  ippSetOperation (request->ipp_request, operation_id);
-  ippSetRequestId (request->ipp_request, 1);
-
-  language = cupsLangDefault ();
-
-  gtk_cups_request_ipp_add_string (request, IPP_TAG_OPERATION, IPP_TAG_CHARSET,
-                                   "attributes-charset", 
-                                   NULL, "utf-8");
-	
-  gtk_cups_request_ipp_add_string (request, IPP_TAG_OPERATION, IPP_TAG_LANGUAGE,
-                                   "attributes-natural-language", 
-                                   NULL, language->language);
-
-  if (username != NULL)
-    gtk_cups_request_ipp_add_string (request, IPP_TAG_OPERATION, IPP_TAG_NAME,
-                                     "requesting-user-name",
-                                     NULL, username);
-  else
-    gtk_cups_request_ipp_add_string (request, IPP_TAG_OPERATION, IPP_TAG_NAME,
-                                     "requesting-user-name",
-                                     NULL, cupsUser ());
-
-  request->auth_info_required = NULL;
-  request->auth_info = NULL;
-  request->need_auth_info = FALSE;
-
-  cupsLangFree (language);
-
-  return request;
-}
-
-GtkCupsRequest *
-gtk_cups_request_new (http_t             *connection,
-                      GtkCupsRequestType  req_type, 
-                      gint                operation_id,
-                      GIOChannel         *data_io,
-                      const char         *server,
-                      const char         *resource)
-{
-  return gtk_cups_request_new_with_username (connection,
-                                             req_type,
-                                             operation_id,
-                                             data_io,
-                                             server,
-                                             resource,
-                                             NULL);
-}
-
-static void
-gtk_cups_result_free (GtkCupsResult *result)
-{
-  g_free (result->error_msg);
-
-  if (result->ipp_response)
-    ippDelete (result->ipp_response);
-
-  g_free (result);
-}
-
-void
-gtk_cups_request_free (GtkCupsRequest *request)
-{
-  if (request->own_http)
-    {
-      if (request->http)
-        httpClose (request->http);
-    }
-  
-  if (request->ipp_request)
-    ippDelete (request->ipp_request);
-
-  g_free (request->server);
-  g_free (request->resource);
-  if (request->password != NULL)
-    {
-      memset (request->password, 0, strlen (request->password));
-      g_free (request->password);
-    }
-
-  g_free (request->username);
-  g_strfreev (request->auth_info_required);
-
-  gtk_cups_result_free (request->result);
-
-  g_free (request);
-}
-
-gboolean 
-gtk_cups_request_read_write (GtkCupsRequest *request, gboolean connect_only)
-{
-  if (connect_only && request->state != GTK_CUPS_REQUEST_START)
-    return FALSE;
-
-  do
-    {
-      if (request->type == GTK_CUPS_POST)
-        post_states[request->state] (request);
-      else if (request->type == GTK_CUPS_GET)
-        get_states[request->state] (request);
-
-      if (gtk_cups_result_is_error (request->result))
-        request->state = GTK_CUPS_REQUEST_DONE;
-
-      if (request->attempts > _GTK_CUPS_MAX_ATTEMPTS &&
-          request->state != GTK_CUPS_REQUEST_DONE)
-        {
-          /* TODO: should add a status or error code for too many failed attempts */
-          gtk_cups_result_set_error (request->result,
-                                     GTK_CUPS_ERROR_GENERAL,
-                                     0,
-                                     0,
-                                     "Too many failed attempts");
-
-          request->state = GTK_CUPS_REQUEST_DONE;
-        }
-
-      if (request->state == GTK_CUPS_REQUEST_DONE)
-        {
-          request->poll_state = GTK_CUPS_HTTP_IDLE;
-          return TRUE;
-        }
-    }
-  /* We need to recheck using httpCheck if the poll_state is read, because
-   * Cups has an internal read buffer. And if this buffer is filled, we may
-   * never get a poll event again. */
-  while (request->poll_state == GTK_CUPS_HTTP_READ && request->http && httpCheck(request->http));
-
-  return FALSE;
-}
-
-GtkCupsPollState 
-gtk_cups_request_get_poll_state (GtkCupsRequest *request)
-{
-  return request->poll_state;
-}
-
-
-
-GtkCupsResult *
-gtk_cups_request_get_result (GtkCupsRequest *request)
-{
-  return request->result;
-}
-
-void            
-gtk_cups_request_ipp_add_string (GtkCupsRequest *request,
-                                 ipp_tag_t       group,
-                                 ipp_tag_t       tag,
-                                 const char     *name,
-                                 const char     *charset,
-                                 const char     *value)
-{
-  ippAddString (request->ipp_request,
-                group,
-                tag,
-                name,
-                charset,
-                value);
-}
-
-void            
-gtk_cups_request_ipp_add_strings (GtkCupsRequest    *request,
-				  ipp_tag_t          group,
-				  ipp_tag_t          tag,
-				  const char        *name,
-				  int                num_values,
-				  const char        *charset,
-				  const char *const *values)
-{
-  ippAddStrings (request->ipp_request,
-		 group,
-		 tag,
-		 name,
-		 num_values,
-		 charset,
-		 values);
-}
-
-const char *
-gtk_cups_request_ipp_get_string (GtkCupsRequest *request,
-                                 ipp_tag_t       tag,
-                                 const char     *name)
-{
-  ipp_attribute_t *attribute = NULL;
-
-  if (request != NULL && request->ipp_request != NULL)
-    attribute = ippFindAttribute (request->ipp_request,
-                                  name,
-                                  tag);
-
-  if (attribute != NULL && ippGetCount (attribute) > 0)
-      return ippGetString (attribute, 0, NULL);
-  else
-    return NULL;
-}
-
-
-typedef struct
-{
-  const char	*name;
-  ipp_tag_t	value_tag;
-} ipp_option_t;
-
-static const ipp_option_t ipp_options[] = {
-  { "blackplot",		IPP_TAG_BOOLEAN },
-  { "brightness",		IPP_TAG_INTEGER },
-  { "columns",			IPP_TAG_INTEGER },
-  { "copies",			IPP_TAG_INTEGER },
-  { "finishings",		IPP_TAG_ENUM },
-  { "fitplot",			IPP_TAG_BOOLEAN },
-  { "gamma",			IPP_TAG_INTEGER },
-  { "hue",			IPP_TAG_INTEGER },
-  { "job-k-limit",		IPP_TAG_INTEGER },
-  { "job-page-limit",		IPP_TAG_INTEGER },
-  { "job-priority",		IPP_TAG_INTEGER },
-  { "job-quota-period",		IPP_TAG_INTEGER },
-  { "landscape",		IPP_TAG_BOOLEAN },
-  { "media",			IPP_TAG_KEYWORD },
-  { "mirror",			IPP_TAG_BOOLEAN },
-  { "natural-scaling",		IPP_TAG_INTEGER },
-  { "number-up",		IPP_TAG_INTEGER },
-  { "orientation-requested",	IPP_TAG_ENUM },
-  { "page-bottom",		IPP_TAG_INTEGER },
-  { "page-left",		IPP_TAG_INTEGER },
-  { "page-ranges",		IPP_TAG_RANGE },
-  { "page-right",		IPP_TAG_INTEGER },
-  { "page-top",			IPP_TAG_INTEGER },
-  { "penwidth",			IPP_TAG_INTEGER },
-  { "ppi",			IPP_TAG_INTEGER },
-  { "prettyprint",		IPP_TAG_BOOLEAN },
-  { "printer-resolution",	IPP_TAG_RESOLUTION },
-  { "print-quality",		IPP_TAG_ENUM },
-  { "saturation",		IPP_TAG_INTEGER },
-  { "scaling",			IPP_TAG_INTEGER },
-  { "sides",			IPP_TAG_KEYWORD },
-  { "wrap",			IPP_TAG_BOOLEAN },
-  { "number-up-layout",		IPP_TAG_INTEGER }
-};
-
-
-static ipp_tag_t
-_find_option_tag (const gchar *option)
-{
-  int lower_bound, upper_bound, num_options;
-  int current_option;
-  ipp_tag_t result;
-
-  result = IPP_TAG_ZERO;
-
-  lower_bound = 0;
-  upper_bound = num_options = (int) G_N_ELEMENTS (ipp_options) - 1;
-  
-  while (1)
-    {
-      int match;
-      current_option = (int) (((upper_bound - lower_bound) / 2) + lower_bound);
-
-      match = strcasecmp (option, ipp_options[current_option].name);
-      if (match == 0)
-        {
-	  result = ipp_options[current_option].value_tag;
-	  return result;
-	}
-      else if (match < 0)
-        {
-          upper_bound = current_option - 1;
-	}
-      else
-        {
-          lower_bound = current_option + 1;
-	}
-
-      if (upper_bound == lower_bound && upper_bound == current_option)
-        return result;
-
-      if (upper_bound < 0)
-        return result;
-
-      if (lower_bound > num_options)
-        return result;
-
-      if (upper_bound < lower_bound)
-        return result;
-    }
-}
-
-/*
- * Note that this function uses IPP_TAG_JOB, so it is
- * only suitable for IPP Group 2 attributes.
- * See RFC 2911.
- */
-void
-gtk_cups_request_encode_option (GtkCupsRequest *request,
-                                const gchar    *option,
-			        const gchar    *value)
-{
-  ipp_tag_t option_tag;
-
-  g_return_if_fail (option != NULL);
-  g_return_if_fail (value != NULL);
-
-  option_tag = _find_option_tag (option);
-
-  if (option_tag == IPP_TAG_ZERO)
-    {
-      option_tag = IPP_TAG_NAME;
-      if (strcasecmp (value, "true") == 0 ||
-          strcasecmp (value, "false") == 0)
-        {
-          option_tag = IPP_TAG_BOOLEAN;
-        }
-    }
-        
-  switch (option_tag)
-    {
-      case IPP_TAG_INTEGER:
-      case IPP_TAG_ENUM:
-        ippAddInteger (request->ipp_request,
-                       IPP_TAG_JOB,
-                       option_tag,
-                       option,
-                       strtol (value, NULL, 0));
-        break;
-
-      case IPP_TAG_BOOLEAN:
-        {
-          char b;
-          
-          if (strcasecmp (value, "true") == 0 ||
-	      strcasecmp (value, "on") == 0 ||
-	      strcasecmp (value, "yes") == 0) 
-	    b = 1;
-	  else
-            b = 0;
-
-          ippAddBoolean (request->ipp_request,
-                         IPP_TAG_JOB,
-                         option,
-                         b);
-        
-          break;
-        }
-        
-      case IPP_TAG_RANGE:
-        {
-          char	*s;
-          int lower;
-          int upper;
-          
-          if (*value == '-')
-	    {
-	      lower = 1;
-	      s = (char *)value;
-	    }
-	  else
-	    lower = strtol (value, &s, 0);
-
-	  if (*s == '-')
-	    {
-	      if (s[1])
-		upper = strtol (s + 1, NULL, 0);
-	      else
-		upper = 2147483647;
-            }
-	  else
-	    upper = lower;
-         
-          ippAddRange (request->ipp_request,
-                       IPP_TAG_JOB,
-                       option,
-                       lower,
-                       upper);
-
-          break;
-        }
-
-      case IPP_TAG_RESOLUTION:
-        {
-          char *s;
-          int xres;
-          int yres;
-          ipp_res_t units;
-          
-          xres = strtol (value, &s, 0);
-
-	  if (*s == 'x')
-	    yres = strtol (s + 1, &s, 0);
-	  else
-	    yres = xres;
-
-	  if (strcasecmp (s, "dpc") == 0)
-            units = IPP_RES_PER_CM;
-          else
-            units = IPP_RES_PER_INCH;
-          
-          ippAddResolution (request->ipp_request,
-                            IPP_TAG_JOB,
-                            option,
-                            units,
-                            xres,
-                            yres);
-
-          break;
-        }
-
-      default:
-        {
-          char *values;
-          char *s;
-          int in_quotes;
-          char *next;
-          GPtrArray *strings;
-          
-          values = g_strdup (value);
-          strings = NULL;
-	  in_quotes = 0;
-
-          for (s = values, next = s; *s != '\0'; s++)
-            {
-              if (in_quotes != 2 && *s == '\'')
-                {
-                  /* skip quoted value */
-                  if (in_quotes == 0)
-                    in_quotes = 1;
-                  else
-                    in_quotes = 0;
-                }
-              else if (in_quotes != 1 && *s == '\"')
-                {
-                  /* skip quoted value */
-                  if (in_quotes == 0)
-                    in_quotes = 2;
-                  else
-                    in_quotes = 0;
-                }
-              else if (in_quotes == 0 && *s == ',')
-                {
-                  /* found delimiter, add to value array */
-                  *s = '\0';
-                  if (strings == NULL)
-                    strings = g_ptr_array_new ();
-                  g_ptr_array_add (strings, next);
-                  next = s + 1;
-                }
-              else if (in_quotes == 0 && *s == '\\' && s[1] != '\0')
-                {
-                  /* skip escaped character */
-                  s++;
-                }
-            }
-          
-          if (strings == NULL)
-            {
-              /* single value */
-              ippAddString (request->ipp_request,
-                            IPP_TAG_JOB,
-                            option_tag,
-                            option,
-                            NULL,
-                            value);
-            }
-          else
-            {
-              /* multiple values */
-              
-              /* add last value */
-              g_ptr_array_add (strings, next);
-              
-              ippAddStrings (request->ipp_request,
-                             IPP_TAG_JOB,
-                             option_tag,
-                             option,
-                             strings->len,
-                             NULL,
-                             (const char **) strings->pdata);
-              g_ptr_array_free (strings, TRUE);
-            }
-
-          g_free (values);
-        }
-
-        break;
-    }
-}
-				
-
-void
-gtk_cups_request_set_ipp_version (GtkCupsRequest     *request,
-				  gint                major,
-				  gint                minor)
-{
-  ippSetVersion (request->ipp_request, major, minor);
-}
-
-static void
-_connect (GtkCupsRequest *request)
-{
-  request->poll_state = GTK_CUPS_HTTP_IDLE;
-  request->bytes_received = 0;
-
-  if (request->http == NULL)
-    {
-      request->http = httpConnectEncrypt (request->server, 
-                                          ippPort (), 
-                                          cupsEncryption ());
-
-      if (request->http == NULL)
-        request->attempts++;
-
-      if (request->http)
-        httpBlocking (request->http, 0);
-        
-      request->own_http = TRUE;
-    }
-  else
-    {
-      request->attempts = 0;
-      request->state++;
-
-      /* we always write to the socket after we get
-         the connection */
-      request->poll_state = GTK_CUPS_HTTP_WRITE;
-    }
-}
-
-static void 
-_post_send (GtkCupsRequest *request)
-{
-  gchar length[255];
-  struct stat data_info;
-
-  GTK_NOTE (PRINTING,
-            g_print ("CUPS Backend: %s\n", G_STRFUNC));
-
-  request->poll_state = GTK_CUPS_HTTP_WRITE;
-
-  if (request->data_io != NULL)
-    {
-      fstat (g_io_channel_unix_get_fd (request->data_io), &data_info);
-      sprintf (length, "%lu", (unsigned long) (ippLength (request->ipp_request) + data_info.st_size));
-    }
-  else
-    sprintf (length, "%lu", (unsigned long) ippLength (request->ipp_request));
-	
-  httpClearFields (request->http);
-  httpSetField (request->http, HTTP_FIELD_CONTENT_LENGTH, length);
-  httpSetField (request->http, HTTP_FIELD_CONTENT_TYPE, "application/ipp");
-#ifdef HAVE_HTTPGETAUTHSTRING
-  httpSetField (request->http, HTTP_FIELD_AUTHORIZATION, httpGetAuthString (request->http));
-#else
-#ifdef HAVE_HTTP_AUTHSTRING
-  httpSetField (request->http, HTTP_FIELD_AUTHORIZATION, request->http->authstring);
-#endif
-#endif
-
-  if (httpPost (request->http, request->resource))
-    {
-      if (httpReconnect (request->http))
-        {
-          request->state = GTK_CUPS_POST_DONE;
-          request->poll_state = GTK_CUPS_HTTP_IDLE;
-
-          /* TODO: should add a status or error code for failed post */
-          gtk_cups_result_set_error (request->result,
-                                     GTK_CUPS_ERROR_GENERAL,
-                                     0,
-                                     0,
-                                     "Failed Post");
-        }
-
-      request->attempts++;
-      return;    
-    }
-        
-    request->attempts = 0;
-
-    request->state = GTK_CUPS_POST_WRITE_REQUEST;
-    ippSetState (request->ipp_request, IPP_IDLE);
-}
-
-static void 
-_post_write_request (GtkCupsRequest *request)
-{
-  ipp_state_t ipp_status;
-
-  GTK_NOTE (PRINTING,
-            g_print ("CUPS Backend: %s\n", G_STRFUNC));
-
-  request->poll_state = GTK_CUPS_HTTP_WRITE;
-  
-  ipp_status = ippWrite (request->http, request->ipp_request);
-
-  if (ipp_status == IPP_ERROR)
-    {
-      int cups_error = cupsLastError ();
-      request->state = GTK_CUPS_POST_DONE;
-      request->poll_state = GTK_CUPS_HTTP_IDLE;
- 
-      gtk_cups_result_set_error (request->result, 
-                                 GTK_CUPS_ERROR_IPP,
-                                 ipp_status,
-                                 cups_error,
-                                 "%s", 
-                                 ippErrorString (cups_error));
-      return;
-    }
-
-  if (ipp_status == IPP_DATA)
-    {
-      if (request->data_io != NULL)
-        request->state = GTK_CUPS_POST_WRITE_DATA;
-      else
-        {
-          request->state = GTK_CUPS_POST_CHECK;
-          request->poll_state = GTK_CUPS_HTTP_READ;
-	}
-    }
-}
-
-static void 
-_post_write_data (GtkCupsRequest *request)
-{
-  gsize bytes;
-  char buffer[_GTK_CUPS_MAX_CHUNK_SIZE];
-  http_status_t http_status;
-
-  GTK_NOTE (PRINTING,
-            g_print ("CUPS Backend: %s\n", G_STRFUNC));
-
-  request->poll_state = GTK_CUPS_HTTP_WRITE;
-  
-  if (httpCheck (request->http))
-    http_status = httpUpdate (request->http);
-  else
-    http_status = request->last_status;
-
-  request->last_status = http_status;
-
-
-  if (http_status == HTTP_CONTINUE || http_status == HTTP_OK)
-    {
-      GIOStatus io_status;
-      GError *error;
-
-      error = NULL;
-
-      /* send data */
-      io_status =
-        g_io_channel_read_chars (request->data_io, 
-	                         buffer, 
-				 _GTK_CUPS_MAX_CHUNK_SIZE,
-				 &bytes,
-				 &error);
-
-      if (io_status == G_IO_STATUS_ERROR)
-        {
-          request->state = GTK_CUPS_POST_DONE;
-	  request->poll_state = GTK_CUPS_HTTP_IDLE;
-     
-          gtk_cups_result_set_error (request->result,
-                                     GTK_CUPS_ERROR_IO,
-                                     io_status,
-                                     error->code, 
-                                     "Error reading from cache file: %s",
-                                     error->message);
-
-	  g_error_free (error);
-          return;
-	}
-      else if (bytes == 0 && io_status == G_IO_STATUS_EOF)
-        {
-          request->state = GTK_CUPS_POST_CHECK;
-	  request->poll_state = GTK_CUPS_HTTP_READ;
-
-          request->attempts = 0;
-          return;
-        }
-
-
-#if HAVE_CUPS_API_1_2
-      if (httpWrite2 (request->http, buffer, bytes) < bytes)
-#else
-      if (httpWrite (request->http, buffer, (int) bytes) < bytes)
-#endif /* HAVE_CUPS_API_1_2 */
-        {
-          int http_errno;
-
-          http_errno = httpError (request->http);
-
-          request->state = GTK_CUPS_POST_DONE;
-	  request->poll_state = GTK_CUPS_HTTP_IDLE;
-     
-          gtk_cups_result_set_error (request->result,
-                                     GTK_CUPS_ERROR_HTTP,
-                                     http_status,
-                                     http_errno, 
-                                     "Error writing to socket in Post %s", 
-                                     g_strerror (http_errno));
-          return;
-        }
-    }
-  else if (http_status == HTTP_UNAUTHORIZED)
-    {
-      request->state = GTK_CUPS_POST_CHECK;
-      request->poll_state = GTK_CUPS_HTTP_READ;
-
-      request->attempts = 0;
-      return;
-    }
-  else
-    {
-      request->attempts++;
-    }
-}
-
-static void
-_post_auth (GtkCupsRequest *request)
-{
-  if (request->password_state == GTK_CUPS_PASSWORD_HAS)
-    {
-      if (request->password == NULL)
-        {
-          request->state = GTK_CUPS_POST_DONE;
-          request->poll_state = GTK_CUPS_HTTP_IDLE;
-
-          gtk_cups_result_set_error (request->result, 
-                                     GTK_CUPS_ERROR_AUTH,
-                                     0,
-                                     1,
-                                     "Canceled by user");
-        }
-      else
-        request->state = GTK_CUPS_POST_CHECK;
-    }
-}
-
-static void
-_get_auth (GtkCupsRequest *request)
-{
-  if (request->password_state == GTK_CUPS_PASSWORD_HAS)
-    {
-      if (request->password == NULL)
-        {
-          request->state = GTK_CUPS_GET_DONE;
-          request->poll_state = GTK_CUPS_HTTP_IDLE;
-
-          gtk_cups_result_set_error (request->result, 
-                                     GTK_CUPS_ERROR_AUTH,
-                                     0,
-                                     1,
-                                     "Canceled by user");
-        }
-      else
-        request->state = GTK_CUPS_GET_CHECK;
-    }
-}
-
-/* Very ugly hack: cups has a stupid synchronous password callback 
- * that doesn't even take the request or user data parameters, so 
- * we have to use a static variable to pass the password to it.
- * Not threadsafe !
- * The callback sets cups_password to NULL to signal that the 
- * password has been used.
- */
-static char *cups_password = NULL;
-static char *cups_username = NULL;
-
-static const char *
-passwordCB (const char *prompt)
-{
-  char *pwd = cups_password;
-  cups_password = NULL;
-
-  cupsSetUser (cups_username);
-
-  return pwd;
-}
-
-static void 
-_post_check (GtkCupsRequest *request)
-{
-  http_status_t http_status;
-
-  http_status = request->last_status;
-
-  GTK_NOTE (PRINTING,
-            g_print ("CUPS Backend: %s - status %i\n", G_STRFUNC, http_status));
-
-  request->poll_state = GTK_CUPS_HTTP_READ;
-
-  if (http_status == HTTP_CONTINUE)
-    {
-      goto again; 
-    }
-  else if (http_status == HTTP_UNAUTHORIZED)
-    {
-      int auth_result = -1;
-      httpFlush (request->http);
-
-      if (request->password_state == GTK_CUPS_PASSWORD_APPLIED)
-        {
-          request->poll_state = GTK_CUPS_HTTP_IDLE;
-          request->password_state = GTK_CUPS_PASSWORD_NOT_VALID;
-          request->state = GTK_CUPS_POST_AUTH;
-          request->need_password = TRUE;
-
-          return;
-        }
-
-      /* Negotiate */
-      if (strncmp (httpGetField (request->http, HTTP_FIELD_WWW_AUTHENTICATE), "Negotiate", 9) == 0)
-        {
-          auth_result = cupsDoAuthentication (request->http, "POST", request->resource);
-        }
-      /* Basic, BasicDigest, Digest and PeerCred */
-      else
-        {
-          if (request->password_state == GTK_CUPS_PASSWORD_NONE)
-            {
-              cups_username = request->username;
-              cupsSetPasswordCB (passwordCB);
-
-              /* This call success for PeerCred authentication */
-              auth_result = cupsDoAuthentication (request->http, "POST", request->resource);
-
-              if (auth_result != 0)
-                {
-                  /* move to AUTH state to let the backend 
-                   * ask for a password
-                   */ 
-                  request->poll_state = GTK_CUPS_HTTP_IDLE;
-                  request->state = GTK_CUPS_POST_AUTH;
-                  request->need_password = TRUE;
-
-                  return;
-                }
-            }
-          else
-            {
-              cups_password = request->password;
-              cups_username = request->username;
-
-              auth_result = cupsDoAuthentication (request->http, "POST", request->resource);
-
-              if (cups_password != NULL)
-                return;
-
-              if (request->password != NULL)
-                {
-                  memset (request->password, 0, strlen (request->password));
-                  g_free (request->password);
-                  request->password = NULL;
-                }
-
-              request->password_state = GTK_CUPS_PASSWORD_APPLIED;
-            }
-        }
-
-      if (auth_result ||
-          httpReconnect (request->http))
-        {
-          /* if the password has been used, reset password_state
-           * so that we ask for a new one next time around
-           */ 
-          if (cups_password == NULL)
-            request->password_state = GTK_CUPS_PASSWORD_NONE;
-
-          request->state = GTK_CUPS_POST_DONE;
-          request->poll_state = GTK_CUPS_HTTP_IDLE;
-          gtk_cups_result_set_error (request->result, 
-                                     GTK_CUPS_ERROR_AUTH,
-                                     0,
-                                     0,
-                                     "Not authorized");
-          return;
-        }
-      
-      if (request->data_io != NULL)
-        g_io_channel_seek_position (request->data_io, 0, G_SEEK_SET, NULL);
-
-      request->state = GTK_CUPS_POST_CONNECT;
-      request->poll_state = GTK_CUPS_HTTP_WRITE;
-    }
-  else if (http_status == HTTP_ERROR)
-    {
-      int error = httpError (request->http);
-      if (error != ENETDOWN && error != ENETUNREACH)	  
-        {
-          request->attempts++;
-          goto again;
-        }
-      else
-        {
-          request->state = GTK_CUPS_POST_DONE;
-          request->poll_state = GTK_CUPS_HTTP_IDLE;
-     
-          gtk_cups_result_set_error (request->result,
-                                     GTK_CUPS_ERROR_HTTP,
-                                     http_status,
-                                     error, 
-                                     "Unknown HTTP error");
-
-          return;
-        }
-    }
-  else if (http_status == HTTP_UPGRADE_REQUIRED)
-    {
-      /* Flush any error message... */
-      httpFlush (request->http);
-
-      cupsSetEncryption (HTTP_ENCRYPT_REQUIRED);
-      request->state = GTK_CUPS_POST_CONNECT;
-
-      /* Reconnect... */
-      httpReconnect (request->http);
-
-      /* Upgrade with encryption... */
-      httpEncryption (request->http, HTTP_ENCRYPT_REQUIRED);
- 
-      request->attempts++;
-      goto again;
-    }
-  else if (http_status != HTTP_OK)
-    {
-      int http_errno;
-
-      http_errno = httpError (request->http);
-
-      if (http_errno == EPIPE)
-        request->state = GTK_CUPS_POST_CONNECT;
-      else
-        {
-          request->state = GTK_CUPS_POST_DONE;
-          gtk_cups_result_set_error (request->result,
-                                     GTK_CUPS_ERROR_HTTP,
-                                     http_status,
-                                     http_errno, 
-                                     "HTTP Error in POST %s", 
-                                     g_strerror (http_errno));
-          request->poll_state = GTK_CUPS_HTTP_IDLE;
- 
-          httpFlush (request->http); 
-          return;
-        }
-
-      request->poll_state = GTK_CUPS_HTTP_IDLE;
-       
-      httpFlush (request->http); 
-      
-      request->last_status = HTTP_CONTINUE;
-      httpClose (request->http);
-      request->http = NULL;
-      return;  
-    }
-  else
-    {
-      request->state = GTK_CUPS_POST_READ_RESPONSE;
-      return;
-    }
-
- again:
-  http_status = HTTP_CONTINUE;
-
-  if (httpCheck (request->http))
-    http_status = httpUpdate (request->http);
-
-  request->last_status = http_status;
-}
-
-static void 
-_post_read_response (GtkCupsRequest *request)
-{
-  ipp_state_t ipp_status;
-
-  GTK_NOTE (PRINTING,
-            g_print ("CUPS Backend: %s\n", G_STRFUNC));
-
-  request->poll_state = GTK_CUPS_HTTP_READ;
-
-  if (request->result->ipp_response == NULL)
-    request->result->ipp_response = ippNew();
-
-  ipp_status = ippRead (request->http, 
-                        request->result->ipp_response);
-
-  if (ipp_status == IPP_ERROR)
-    {
-      int ipp_error = cupsLastError ();
-      gtk_cups_result_set_error (request->result,  
-                                 GTK_CUPS_ERROR_IPP,
-                                 ipp_status,
-                                 ipp_error,
-                                 "%s",
-                                 ippErrorString (ipp_error));
-      
-      ippDelete (request->result->ipp_response);
-      request->result->ipp_response = NULL;
-
-      request->state = GTK_CUPS_POST_DONE;
-      request->poll_state = GTK_CUPS_HTTP_IDLE;
-    }
-  else if (ipp_status == IPP_DATA)
-    {
-      request->state = GTK_CUPS_POST_DONE;
-      request->poll_state = GTK_CUPS_HTTP_IDLE;
-    }
-}
-
-static void 
-_get_send (GtkCupsRequest *request)
-{
-  GTK_NOTE (PRINTING,
-            g_print ("CUPS Backend: %s\n", G_STRFUNC));
-
-  request->poll_state = GTK_CUPS_HTTP_WRITE;
-
-  if (request->data_io == NULL)
-    {
-      gtk_cups_result_set_error (request->result,
-                                 GTK_CUPS_ERROR_IO,
-                                 G_IO_STATUS_ERROR,
-                                 G_IO_CHANNEL_ERROR_FAILED, 
-                                 "Get requires an open io channel");
-
-      request->state = GTK_CUPS_GET_DONE;
-      request->poll_state = GTK_CUPS_HTTP_IDLE;
-
-      return;
-    }
-
-  httpClearFields (request->http);
-#ifdef HAVE_HTTPGETAUTHSTRING
-  httpSetField (request->http, HTTP_FIELD_AUTHORIZATION, httpGetAuthString (request->http));
-#else
-#ifdef HAVE_HTTP_AUTHSTRING
-  httpSetField (request->http, HTTP_FIELD_AUTHORIZATION, request->http->authstring);
-#endif
-#endif
-
-  if (httpGet (request->http, request->resource))
-    {
-      if (httpReconnect (request->http))
-        {
-          request->state = GTK_CUPS_GET_DONE;
-          request->poll_state = GTK_CUPS_HTTP_IDLE;
-	 
-          /* TODO: should add a status or error code for failed GET */ 
-          gtk_cups_result_set_error (request->result, 
-                                     GTK_CUPS_ERROR_GENERAL,
-                                     0,
-                                     0,
-                                     "Failed Get");
-        }
-
-      request->attempts++;
-      return;    
-    }
-
-  if (httpCheck (request->http))
-    request->last_status = httpUpdate (request->http);
-        
-  request->attempts = 0;
-
-  request->state = GTK_CUPS_GET_CHECK;
-  request->poll_state = GTK_CUPS_HTTP_READ;
-  
-  ippSetState (request->ipp_request, IPP_IDLE);
-}
-
-static void 
-_get_check (GtkCupsRequest *request)
-{
-  http_status_t http_status;
-
-  GTK_NOTE (PRINTING,
-            g_print ("CUPS Backend: %s\n", G_STRFUNC));
-
-  http_status = request->last_status;
-
-  request->poll_state = GTK_CUPS_HTTP_READ;
-
-  if (http_status == HTTP_CONTINUE)
-    {
-      goto again; 
-    }
-  else if (http_status == HTTP_UNAUTHORIZED)
-    {
-      int auth_result = -1;
-      httpFlush (request->http);
-
-      if (request->password_state == GTK_CUPS_PASSWORD_APPLIED)
-        {
-          request->poll_state = GTK_CUPS_HTTP_IDLE;
-          request->password_state = GTK_CUPS_PASSWORD_NOT_VALID;
-          request->state = GTK_CUPS_GET_AUTH;
-          request->need_password = TRUE;
-
-          return;
-        }
-
-      /* Negotiate */
-      if (strncmp (httpGetField (request->http, HTTP_FIELD_WWW_AUTHENTICATE), "Negotiate", 9) == 0)
-        {
-          auth_result = cupsDoAuthentication (request->http, "GET", request->resource);
-        }
-      /* Basic, BasicDigest, Digest and PeerCred */
-      else
-        {
-          if (request->password_state == GTK_CUPS_PASSWORD_NONE)
-            {
-              cups_username = request->username;
-              cupsSetPasswordCB (passwordCB);
-
-              /* This call success for PeerCred authentication */
-              auth_result = cupsDoAuthentication (request->http, "GET", request->resource);
-
-              if (auth_result != 0)
-                {
-                  /* move to AUTH state to let the backend
-                   * ask for a password
-                   */
-                  request->poll_state = GTK_CUPS_HTTP_IDLE;
-                  request->state = GTK_CUPS_GET_AUTH;
-                  request->need_password = TRUE;
-
-                  return;
-                }
-            }
-          else
-            {
-              cups_password = request->password;
-              cups_username = request->username;
-
-              auth_result = cupsDoAuthentication (request->http, "GET", request->resource);
-
-              if (cups_password != NULL)
-                return;
-
-              if (request->password != NULL)
-                {
-                  memset (request->password, 0, strlen (request->password));
-                  g_free (request->password);
-                  request->password = NULL;
-                }
-
-              request->password_state = GTK_CUPS_PASSWORD_APPLIED;
-            }
-        }
-
-      if (auth_result ||
-          httpReconnect (request->http))
-        {
-          /* if the password has been used, reset password_state
-           * so that we ask for a new one next time around
-           */
-          if (cups_password == NULL)
-            request->password_state = GTK_CUPS_PASSWORD_NONE;
-
-          request->state = GTK_CUPS_GET_DONE;
-          request->poll_state = GTK_CUPS_HTTP_IDLE;
-          gtk_cups_result_set_error (request->result, 
-                                     GTK_CUPS_ERROR_AUTH,
-                                     0,
-                                     0,
-                                     "Not authorized");
-          return;
-        }
-
-      request->state = GTK_CUPS_GET_CONNECT;
-      request->last_status = HTTP_CONTINUE;
-
-     return;
-    }
-  else if (http_status == HTTP_UPGRADE_REQUIRED)
-    {
-      /* Flush any error message... */
-      httpFlush (request->http);
-
-      cupsSetEncryption (HTTP_ENCRYPT_REQUIRED);
-      request->state = GTK_CUPS_GET_CONNECT;
-
-      /* Reconnect... */
-      httpReconnect (request->http);
-
-      /* Upgrade with encryption... */
-      httpEncryption (request->http, HTTP_ENCRYPT_REQUIRED);
- 
-      request->attempts++;
-      goto again;
-    }
-  else if (http_status != HTTP_OK)
-    {
-      int http_errno;
-
-      http_errno = httpError (request->http);
-
-      if (http_errno == EPIPE)
-        request->state = GTK_CUPS_GET_CONNECT;
-      else
-        {
-          request->state = GTK_CUPS_GET_DONE;
-          gtk_cups_result_set_error (request->result,
-                                     GTK_CUPS_ERROR_HTTP,
-                                     http_status,
-                                     http_errno, 
-                                     "HTTP Error in GET %s", 
-                                     g_strerror (http_errno));
-          request->poll_state = GTK_CUPS_HTTP_IDLE;
-          httpFlush (request->http);
-
-          return;
-        }
-
-      request->poll_state = GTK_CUPS_HTTP_IDLE;
-      httpFlush (request->http);
-      httpClose (request->http);
-      request->last_status = HTTP_CONTINUE;
-      request->http = NULL;
-      return;
-
-    }
-  else
-    {
-      request->state = GTK_CUPS_GET_READ_DATA;
-      return;
-    }
-
- again:
-  http_status = HTTP_CONTINUE;
-
-  if (httpCheck (request->http))
-    http_status = httpUpdate (request->http);
-
-  request->last_status = http_status;
-
-}
-
-static void 
-_get_read_data (GtkCupsRequest *request)
-{
-  char buffer[_GTK_CUPS_MAX_CHUNK_SIZE];
-  gsize bytes;
-  gsize bytes_written;
-  GIOStatus io_status;
-  GError *error;
-
-  GTK_NOTE (PRINTING,
-            g_print ("CUPS Backend: %s\n", G_STRFUNC));
-
-  error = NULL;
-
-  request->poll_state = GTK_CUPS_HTTP_READ;
-
-#if HAVE_CUPS_API_1_2
-  bytes = httpRead2 (request->http, buffer, sizeof (buffer));
-#else
-  bytes = httpRead (request->http, buffer, sizeof (buffer));
-#endif /* HAVE_CUPS_API_1_2 */
-  request->bytes_received += bytes;
-
-  GTK_NOTE (PRINTING,
-            g_print ("CUPS Backend: %" G_GSIZE_FORMAT " bytes read\n", bytes));
-  
-  io_status =
-    g_io_channel_write_chars (request->data_io, 
-                              buffer, 
-			      bytes, 
-			      &bytes_written,
-			      &error);
-
-  if (io_status == G_IO_STATUS_ERROR)
-    {
-      request->state = GTK_CUPS_GET_DONE;
-      request->poll_state = GTK_CUPS_HTTP_IDLE;
-    
-      gtk_cups_result_set_error (request->result,
-                                 GTK_CUPS_ERROR_IO,
-                                 io_status,
-                                 error->code, 
-                                 error->message);
-      g_error_free (error);
-    }
-
-  /* Stop if we do not expect any more data or EOF was received. */
-#if HAVE_CUPS_API_1_2
-  if (httpGetLength2 (request->http) <= request->bytes_received || bytes == 0)
-#else
-  if (httpGetLength (request->http) <= request->bytes_received || bytes == 0)
-#endif /* HAVE_CUPS_API_1_2 */
-    {
-      request->state = GTK_CUPS_GET_DONE;
-      request->poll_state = GTK_CUPS_HTTP_IDLE;
-
-      return;
-    }
-}
-
-gboolean
-gtk_cups_request_is_done (GtkCupsRequest *request)
-{
-  return (request->state == GTK_CUPS_REQUEST_DONE);
-}
-
-gboolean
-gtk_cups_result_is_error (GtkCupsResult *result)
-{
-  return result->is_error;
-}
-
-ipp_t *
-gtk_cups_result_get_response (GtkCupsResult *result)
-{
-  return result->ipp_response;
-}
-
-GtkCupsErrorType
-gtk_cups_result_get_error_type (GtkCupsResult *result)
-{
-  return result->error_type;
-}
-
-int
-gtk_cups_result_get_error_status (GtkCupsResult *result)
-{
-  return result->error_status;
-}
-
-int
-gtk_cups_result_get_error_code (GtkCupsResult *result)
-{
-  return result->error_code;
-}
-
-const char *
-gtk_cups_result_get_error_string (GtkCupsResult *result)
-{
-  return result->error_msg; 
-}
-
-/* This function allocates new instance of GtkCupsConnectionTest() and creates
- * a socket for communication with a CUPS server 'server'.
- */
-GtkCupsConnectionTest *
-gtk_cups_connection_test_new (const char *server,
-                              const int   port)
-{
-  GtkCupsConnectionTest *result = NULL;
-#ifdef HAVE_CUPS_API_1_2
-  gchar                 *port_str = NULL;
-
-  result = g_new (GtkCupsConnectionTest, 1);
-
-  if (port >= 0)
-    port_str = g_strdup_printf ("%d", port);
-  else
-    port_str = g_strdup_printf ("%d", ippPort ());
-
-  if (server != NULL)
-    result->addrlist = httpAddrGetList (server, AF_UNSPEC, port_str);
-  else
-    result->addrlist = httpAddrGetList (cupsServer (), AF_UNSPEC, port_str);
-
-  g_free (port_str);
-
-  result->socket = -1;
-  result->current_addr = NULL;
-  result->last_wrong_addr = NULL;
-  result->at_init = GTK_CUPS_CONNECTION_NOT_AVAILABLE;
-
-  result->at_init = gtk_cups_connection_test_get_state (result);
-#else
-  result = g_new (GtkCupsConnectionTest, 1);
-#endif
-
-  return result;
-}
-
-
-/* A non-blocking test whether it is possible to connect to a CUPS server specified
- * inside of GtkCupsConnectionTest structure.
- *  - you need to check it more then once.
- * The connection is closed after a successful connection.
- */
-GtkCupsConnectionState 
-gtk_cups_connection_test_get_state (GtkCupsConnectionTest *test)
-{
-#ifdef HAVE_CUPS_API_1_2
-  GtkCupsConnectionState result = GTK_CUPS_CONNECTION_NOT_AVAILABLE;
-  http_addrlist_t       *iter;
-  gint                   error_code;
-  gint                   flags;
-  gint                   code;
-
-  if (test == NULL)
-    return GTK_CUPS_CONNECTION_NOT_AVAILABLE;
-
-  if (test->at_init == GTK_CUPS_CONNECTION_AVAILABLE)
-    {
-      test->at_init = GTK_CUPS_CONNECTION_NOT_AVAILABLE;
-      return GTK_CUPS_CONNECTION_AVAILABLE;
-    }
-  else
-    {
-      if (test->socket == -1)
-        {
-          if (test->last_wrong_addr != NULL && test->last_wrong_addr->next != NULL)
-            iter = test->last_wrong_addr->next;
-          else
-            {
-              test->last_wrong_addr = NULL;
-              iter = test->addrlist;
-            }
-
-          while (iter)
-            {
-              test->socket = socket (iter->addr.addr.sa_family,
-                                     SOCK_STREAM,
-                                     0);
-
-              if (test->socket >= 0)
-                {
-                  flags = fcntl (test->socket, F_GETFL);
-
-                  if (flags != -1)
-                    flags |= O_NONBLOCK;
-
-                  fcntl (test->socket, F_SETFL, flags);
-              
-                  test->current_addr = iter;
-              
-                  break;
-                }
-               iter = iter->next;
-            }
-        }
-
-      if (test->socket >= 0)
-        {
-          code = connect (test->socket,
-                          &test->current_addr->addr.addr,
-                          httpAddrLength (&test->current_addr->addr));
-
-          error_code = errno;
-
-          if (code == 0 || error_code == EISCONN)
-            {
-              close (test->socket);
-              test->socket = -1;
-              test->current_addr = NULL;
-              result = GTK_CUPS_CONNECTION_AVAILABLE;
-            }
-          else
-            {
-              if (error_code == EALREADY || error_code == EINPROGRESS)
-                result = GTK_CUPS_CONNECTION_IN_PROGRESS;
-              else
-                {
-                  close (test->socket);
-                  test->socket = -1;
-                  test->last_wrong_addr = test->current_addr;
-                  result = GTK_CUPS_CONNECTION_NOT_AVAILABLE;
-                }
-            }
-         }
-
-      return result;
-    }
-#else
-  return GTK_CUPS_CONNECTION_AVAILABLE;
-#endif
-}
-
-/* This function frees memory used by the GtkCupsConnectionTest structure.
- */
-void 
-gtk_cups_connection_test_free (GtkCupsConnectionTest *test)
-{
-  if (test == NULL)
-    return;
-
-#ifdef HAVE_CUPS_API_1_2
-  test->current_addr = NULL;
-  test->last_wrong_addr = NULL;
-  httpAddrFreeList (test->addrlist);
-  if (test->socket != -1)
-    {
-      close (test->socket);
-      test->socket = -1;
-    }
-#endif
-  g_free (test);
-}
diff --git a/modules/printbackends/cups/gtkcupsutils.h b/modules/printbackends/cups/gtkcupsutils.h
deleted file mode 100644
index e1d1e82..0000000
--- a/modules/printbackends/cups/gtkcupsutils.h
+++ /dev/null
@@ -1,200 +0,0 @@
-/* gtkcupsutils.h 
- * Copyright (C) 2006 John (J5) Palmieri <johnp@redhat.com>
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
- 
-#ifndef __GTK_CUPS_UTILS_H__
-#define __GTK_CUPS_UTILS_H__
-
-#include <glib.h>
-#include <cups/cups.h>
-#include <cups/language.h>
-#include <cups/http.h>
-#include <cups/ipp.h>
-
-G_BEGIN_DECLS
-
-typedef struct _GtkCupsRequest        GtkCupsRequest;
-typedef struct _GtkCupsResult         GtkCupsResult;
-typedef struct _GtkCupsConnectionTest GtkCupsConnectionTest;
-
-typedef enum
-{
-  GTK_CUPS_ERROR_HTTP,
-  GTK_CUPS_ERROR_IPP,
-  GTK_CUPS_ERROR_IO,
-  GTK_CUPS_ERROR_AUTH,
-  GTK_CUPS_ERROR_GENERAL
-} GtkCupsErrorType;
-
-typedef enum
-{
-  GTK_CUPS_POST,
-  GTK_CUPS_GET
-} GtkCupsRequestType;
-
-
-/** 
- * Direction we should be polling the http socket on.
- * We are either reading or writting at each state.
- * This makes it easy for mainloops to connect to poll.
- */
-typedef enum
-{
-  GTK_CUPS_HTTP_IDLE,
-  GTK_CUPS_HTTP_READ,
-  GTK_CUPS_HTTP_WRITE
-} GtkCupsPollState;
-
-typedef enum
-{
-  GTK_CUPS_CONNECTION_AVAILABLE,
-  GTK_CUPS_CONNECTION_NOT_AVAILABLE,
-  GTK_CUPS_CONNECTION_IN_PROGRESS  
-} GtkCupsConnectionState;
-
-typedef enum
-{
-  GTK_CUPS_PASSWORD_NONE,
-  GTK_CUPS_PASSWORD_REQUESTED,
-  GTK_CUPS_PASSWORD_HAS,
-  GTK_CUPS_PASSWORD_APPLIED,
-  GTK_CUPS_PASSWORD_NOT_VALID
-} GtkCupsPasswordState;
-
-struct _GtkCupsRequest 
-{
-  GtkCupsRequestType type;
-
-  http_t *http;
-  http_status_t last_status;
-  ipp_t *ipp_request;
-
-  gchar *server;
-  gchar *resource;
-  GIOChannel *data_io;
-  gint attempts;
-
-  GtkCupsResult *result;
-
-  gint state;
-  GtkCupsPollState poll_state;
-  guint64 bytes_received;
-
-  gchar *password;
-  gchar *username;
-
-  gint own_http : 1;
-  gint need_password : 1;
-  gint need_auth_info : 1;
-  gchar **auth_info_required;
-  gchar **auth_info;
-  GtkCupsPasswordState password_state;
-};
-
-struct _GtkCupsConnectionTest
-{
-#ifdef HAVE_CUPS_API_1_2
-  GtkCupsConnectionState at_init;
-  http_addrlist_t       *addrlist;
-  http_addrlist_t       *current_addr;
-  http_addrlist_t       *last_wrong_addr;
-  gint                   socket;
-#endif
-};
-
-#define GTK_CUPS_REQUEST_START 0
-#define GTK_CUPS_REQUEST_DONE 500
-
-/* POST states */
-enum 
-{
-  GTK_CUPS_POST_CONNECT = GTK_CUPS_REQUEST_START,
-  GTK_CUPS_POST_SEND,
-  GTK_CUPS_POST_WRITE_REQUEST,
-  GTK_CUPS_POST_WRITE_DATA,
-  GTK_CUPS_POST_CHECK,
-  GTK_CUPS_POST_AUTH,
-  GTK_CUPS_POST_READ_RESPONSE,
-  GTK_CUPS_POST_DONE = GTK_CUPS_REQUEST_DONE
-};
-
-/* GET states */
-enum
-{
-  GTK_CUPS_GET_CONNECT = GTK_CUPS_REQUEST_START,
-  GTK_CUPS_GET_SEND,
-  GTK_CUPS_GET_CHECK,
-  GTK_CUPS_GET_AUTH,
-  GTK_CUPS_GET_READ_DATA,
-  GTK_CUPS_GET_DONE = GTK_CUPS_REQUEST_DONE
-};
-
-GtkCupsRequest        * gtk_cups_request_new_with_username (http_t             *connection,
-							    GtkCupsRequestType  req_type,
-							    gint                operation_id,
-							    GIOChannel         *data_io,
-							    const char         *server,
-							    const char         *resource,
-							    const char         *username);
-GtkCupsRequest        * gtk_cups_request_new               (http_t             *connection,
-							    GtkCupsRequestType  req_type,
-							    gint                operation_id,
-							    GIOChannel         *data_io,
-							    const char         *server,
-							    const char         *resource);
-void                    gtk_cups_request_ipp_add_string    (GtkCupsRequest     *request,
-							    ipp_tag_t           group,
-							    ipp_tag_t           tag,
-							    const char         *name,
-							    const char         *charset,
-							    const char         *value);
-void                    gtk_cups_request_ipp_add_strings   (GtkCupsRequest     *request,
-							    ipp_tag_t           group,
-							    ipp_tag_t           tag,
-							    const char         *name,
-							    int                 num_values,
-							    const char         *charset,
-							    const char * const *values);
-const char            * gtk_cups_request_ipp_get_string    (GtkCupsRequest     *request,
-							    ipp_tag_t           tag,
-							    const char         *name);
-gboolean                gtk_cups_request_read_write        (GtkCupsRequest     *request,
-                                                            gboolean            connect_only);
-GtkCupsPollState        gtk_cups_request_get_poll_state    (GtkCupsRequest     *request);
-void                    gtk_cups_request_free              (GtkCupsRequest     *request);
-GtkCupsResult         * gtk_cups_request_get_result        (GtkCupsRequest     *request);
-gboolean                gtk_cups_request_is_done           (GtkCupsRequest     *request);
-void                    gtk_cups_request_encode_option     (GtkCupsRequest     *request,
-						            const gchar        *option,
-							    const gchar        *value);
-void                    gtk_cups_request_set_ipp_version   (GtkCupsRequest     *request,
-							    gint                major,
-							    gint                minor);
-gboolean                gtk_cups_result_is_error           (GtkCupsResult      *result);
-ipp_t                 * gtk_cups_result_get_response       (GtkCupsResult      *result);
-GtkCupsErrorType        gtk_cups_result_get_error_type     (GtkCupsResult      *result);
-int                     gtk_cups_result_get_error_status   (GtkCupsResult      *result);
-int                     gtk_cups_result_get_error_code     (GtkCupsResult      *result);
-const char            * gtk_cups_result_get_error_string   (GtkCupsResult      *result);
-GtkCupsConnectionTest * gtk_cups_connection_test_new       (const char         *server,
-                                                            const int           port);
-GtkCupsConnectionState  gtk_cups_connection_test_get_state (GtkCupsConnectionTest *test);
-void                    gtk_cups_connection_test_free      (GtkCupsConnectionTest *test);
-
-G_END_DECLS
-#endif 
diff --git a/modules/printbackends/cups/gtkprintbackendcups.c b/modules/printbackends/cups/gtkprintbackendcups.c
deleted file mode 100644
index 985f0d2..0000000
--- a/modules/printbackends/cups/gtkprintbackendcups.c
+++ /dev/null
@@ -1,5438 +0,0 @@
-/* GTK - The GIMP Toolkit
- * gtkprintbackendcups.h: Default implementation of GtkPrintBackend 
- * for the Common Unix Print System (CUPS)
- * Copyright (C) 2006, 2007 Red Hat, Inc.
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-#ifdef __linux__
-#define _GNU_SOURCE
-#endif
-
-#include "config.h"
-#include <ctype.h>
-#include <unistd.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <stdlib.h>
-#include <time.h>
-/* Cups 1.6 deprecates ppdFindAttr(), ppdFindCustomOption(),
- * ppdFirstCustomParam(), and ppdNextCustomParam() among others. This
- * turns off the warning so that it will compile.
- */
-#ifdef HAVE_CUPS_API_1_6
-# define _PPD_DEPRECATED
-#endif
-
-#include <cups/cups.h>
-#include <cups/language.h>
-#include <cups/http.h>
-#include <cups/ipp.h>
-#include <errno.h>
-#include <cairo.h>
-#include <cairo-pdf.h>
-#include <cairo-ps.h>
-
-#include <glib/gstdio.h>
-#include "gtk/gtkintl.h"
-#include <gmodule.h>
-
-#include <gtk/gtk.h>
-#include <gtk/gtkprintbackend.h>
-#include <gtk/gtkunixprint.h>
-#include <gtk/gtkprinter-private.h>
-
-#include "gtkprintbackendcups.h"
-#include "gtkprintercups.h"
-
-#include "gtkcupsutils.h"
-
-
-typedef struct _GtkPrintBackendCupsClass GtkPrintBackendCupsClass;
-
-#define GTK_PRINT_BACKEND_CUPS_CLASS(klass)     (G_TYPE_CHECK_CLASS_CAST ((klass), GTK_TYPE_PRINT_BACKEND_CUPS, GtkPrintBackendCupsClass))
-#define GTK_IS_PRINT_BACKEND_CUPS_CLASS(klass)  (G_TYPE_CHECK_CLASS_TYPE ((klass), GTK_TYPE_PRINT_BACKEND_CUPS))
-#define GTK_PRINT_BACKEND_CUPS_GET_CLASS(obj)   (G_TYPE_INSTANCE_GET_CLASS ((obj), GTK_TYPE_PRINT_BACKEND_CUPS, GtkPrintBackendCupsClass))
-
-#define _CUPS_MAX_ATTEMPTS 10 
-#define _CUPS_MAX_CHUNK_SIZE 8192
-
-#ifdef HAVE_CUPS_API_1_6
-#define AVAHI_IF_UNSPEC -1
-#define AVAHI_PROTO_INET 0
-#define AVAHI_PROTO_INET6 1
-#define AVAHI_PROTO_UNSPEC -1
-
-#define AVAHI_BUS "org.freedesktop.Avahi"
-#define AVAHI_SERVER_IFACE "org.freedesktop.Avahi.Server"
-#define AVAHI_SERVICE_BROWSER_IFACE "org.freedesktop.Avahi.ServiceBrowser"
-#endif
-
-/* define this to see warnings about ignored ppd options */
-#undef PRINT_IGNORED_OPTIONS
-
-#define _CUPS_MAP_ATTR_INT(attr, v, a) {if (!g_ascii_strcasecmp (attr->name, (a))) v = attr->values[0].integer;}
-#define _CUPS_MAP_ATTR_STR(attr, v, a) {if (!g_ascii_strcasecmp (attr->name, (a))) v = attr->values[0].string.text;}
-
-static GType print_backend_cups_type = 0;
-
-typedef void (* GtkPrintCupsResponseCallbackFunc) (GtkPrintBackend *print_backend,
-                                                   GtkCupsResult   *result, 
-                                                   gpointer         user_data);
-
-typedef enum 
-{
-  DISPATCH_SETUP,
-  DISPATCH_REQUEST,
-  DISPATCH_SEND,
-  DISPATCH_CHECK,
-  DISPATCH_READ,
-  DISPATCH_ERROR
-} GtkPrintCupsDispatchState;
-
-typedef struct 
-{
-  GSource source;
-
-  http_t *http;
-  GtkCupsRequest *request;
-  GtkCupsPollState poll_state;
-  GPollFD *data_poll;
-  GtkPrintBackendCups *backend;
-  GtkPrintCupsResponseCallbackFunc callback;
-  gpointer                         callback_data;
-
-} GtkPrintCupsDispatchWatch;
-
-struct _GtkPrintBackendCupsClass
-{
-  GtkPrintBackendClass parent_class;
-};
-
-struct _GtkPrintBackendCups
-{
-  GtkPrintBackend parent_instance;
-
-  char *default_printer;
-  
-  guint list_printers_poll;
-  guint list_printers_pending : 1;
-  gint  list_printers_attempts;
-  guint got_default_printer   : 1;
-  guint default_printer_poll;
-  GtkCupsConnectionTest *cups_connection_test;
-  gint  reading_ppds;
-
-  char **covers;
-  int    number_of_covers;
-
-  GList      *requests;
-  GHashTable *auth;
-  gchar      *username;
-  gboolean    authentication_lock;
-#ifdef HAVE_CUPS_API_1_6
-  void *dbus_connection;
-  gchar           *avahi_default_printer;
-  guint            avahi_service_browser_subscription_id;
-  guint            avahi_service_browser_subscription_ids[2];
-  gchar           *avahi_service_browser_paths[2];
-  GCancellable    *avahi_cancellable;
-#endif
-};
-
-static GObjectClass *backend_parent_class;
-
-static void                 gtk_print_backend_cups_class_init      (GtkPrintBackendCupsClass          *class);
-static void                 gtk_print_backend_cups_init            (GtkPrintBackendCups               *impl);
-static void                 gtk_print_backend_cups_finalize        (GObject                           *object);
-static void                 gtk_print_backend_cups_dispose         (GObject                           *object);
-static void                 cups_get_printer_list                  (GtkPrintBackend                   *print_backend);
-static void                 cups_get_default_printer               (GtkPrintBackendCups               *print_backend);
-static void                 cups_get_local_default_printer         (GtkPrintBackendCups               *print_backend);
-static void                 cups_request_execute                   (GtkPrintBackendCups               *print_backend,
-								    GtkCupsRequest                    *request,
-								    GtkPrintCupsResponseCallbackFunc   callback,
-								    gpointer                           user_data,
-								    GDestroyNotify                     notify);
-static void                 cups_printer_get_settings_from_options (GtkPrinter                        *printer,
-								    GtkPrinterOptionSet               *options,
-								    GtkPrintSettings                  *settings);
-static gboolean             cups_printer_mark_conflicts            (GtkPrinter                        *printer,
-								    GtkPrinterOptionSet               *options);
-static GtkPrinterOptionSet *cups_printer_get_options               (GtkPrinter                        *printer,
-								    GtkPrintSettings                  *settings,
-								    GtkPageSetup                      *page_setup,
-                                                                    GtkPrintCapabilities               capabilities);
-static void                 cups_printer_prepare_for_print         (GtkPrinter                        *printer,
-								    GtkPrintJob                       *print_job,
-								    GtkPrintSettings                  *settings,
-								    GtkPageSetup                      *page_setup);
-static GList *              cups_printer_list_papers               (GtkPrinter                        *printer);
-static GtkPageSetup *       cups_printer_get_default_page_size     (GtkPrinter                        *printer);
-static void                 cups_printer_request_details           (GtkPrinter                        *printer);
-static gboolean             cups_request_default_printer           (GtkPrintBackendCups               *print_backend);
-static gboolean             cups_request_ppd                       (GtkPrinter                        *printer);
-static gboolean             cups_printer_get_hard_margins          (GtkPrinter                        *printer,
-								    gdouble                           *top,
-								    gdouble                           *bottom,
-								    gdouble                           *left,
-								    gdouble                           *right);
-static GtkPrintCapabilities cups_printer_get_capabilities          (GtkPrinter                        *printer);
-static void                 set_option_from_settings               (GtkPrinterOption                  *option,
-								    GtkPrintSettings                  *setting);
-static void                 cups_begin_polling_info                (GtkPrintBackendCups               *print_backend,
-								    GtkPrintJob                       *job,
-								    int                                job_id);
-static gboolean             cups_job_info_poll_timeout             (gpointer                           user_data);
-static void                 gtk_print_backend_cups_print_stream    (GtkPrintBackend                   *backend,
-								    GtkPrintJob                       *job,
-								    GIOChannel                        *data_io,
-								    GtkPrintJobCompleteFunc            callback,
-								    gpointer                           user_data,
-								    GDestroyNotify                     dnotify);
-static cairo_surface_t *    cups_printer_create_cairo_surface      (GtkPrinter                        *printer,
-								    GtkPrintSettings                  *settings,
-								    gdouble                            width,
-								    gdouble                            height,
-								    GIOChannel                        *cache_io);
-
-static void                 gtk_print_backend_cups_set_password    (GtkPrintBackend                   *backend, 
-                                                                    gchar                            **auth_info_required,
-                                                                    gchar                            **auth_info);
-
-void                        overwrite_and_free                      (gpointer                          data);
-static gboolean             is_address_local                        (const gchar                      *address);
-static gboolean             request_auth_info                       (gpointer                          data);
-
-#ifdef HAVE_CUPS_API_1_6
-static void                 avahi_request_printer_list              (GtkPrintBackendCups              *cups_backend);
-#endif
-
-static void
-gtk_print_backend_cups_register_type (GTypeModule *module)
-{
-  const GTypeInfo print_backend_cups_info =
-  {
-    sizeof (GtkPrintBackendCupsClass),
-    NULL,		/* base_init */
-    NULL,		/* base_finalize */
-    (GClassInitFunc) gtk_print_backend_cups_class_init,
-    NULL,		/* class_finalize */
-    NULL,		/* class_data */
-    sizeof (GtkPrintBackendCups),
-    0,	          	/* n_preallocs */
-    (GInstanceInitFunc) gtk_print_backend_cups_init
-  };
-
-  print_backend_cups_type = g_type_module_register_type (module,
-                                                         GTK_TYPE_PRINT_BACKEND,
-                                                         "GtkPrintBackendCups",
-                                                         &print_backend_cups_info, 0);
-}
-
-G_MODULE_EXPORT void 
-pb_module_init (GTypeModule *module)
-{
-  GTK_NOTE (PRINTING,
-            g_print ("CUPS Backend: Initializing the CUPS print backend module\n")); 
-
-  gtk_print_backend_cups_register_type (module);
-  gtk_printer_cups_register_type (module);
-}
-
-G_MODULE_EXPORT void 
-pb_module_exit (void)
-{
-
-}
-  
-G_MODULE_EXPORT GtkPrintBackend * 
-pb_module_create (void)
-{
-  return gtk_print_backend_cups_new ();
-}
-/* CUPS 1.6 Getter/Setter Functions CUPS 1.6 makes private most of the
- * IPP structures and enforces access via new getter functions, which
- * are unfortunately not available in earlier versions. We define
- * below those getter functions as macros for use when building
- * against earlier CUPS versions.
- */
-#ifndef HAVE_CUPS_API_1_6
-#define ippGetOperation(ipp_request) ipp_request->request.op.operation_id
-#define ippGetInteger(attr, index) attr->values[index].integer
-#define ippGetBoolean(attr, index) attr->values[index].boolean
-#define ippGetString(attr, index, foo) attr->values[index].string.text
-#define ippGetValueTag(attr) attr->value_tag
-#define ippGetName(attr) attr->name
-#define ippGetCount(attr) attr->num_values
-#define ippGetGroupTag(attr) attr->group_tag
-
-static int
-ippGetRange (ipp_attribute_t *attr,
-             int element,
-             int *upper)
-{
-  *upper = attr->values[element].range.upper;
-  return (attr->values[element].range.lower);
-}
-#endif
-/*
- * GtkPrintBackendCups
- */
-GType
-gtk_print_backend_cups_get_type (void)
-{
-  return print_backend_cups_type;
-}
-
-/**
- * gtk_print_backend_cups_new:
- *
- * Creates a new #GtkPrintBackendCups object. #GtkPrintBackendCups
- * implements the #GtkPrintBackend interface with direct access to
- * the filesystem using Unix/Linux API calls
- *
- * Return value: the new #GtkPrintBackendCups object
- */
-GtkPrintBackend *
-gtk_print_backend_cups_new (void)
-{
-  GTK_NOTE (PRINTING,
-            g_print ("CUPS Backend: Creating a new CUPS print backend object\n"));
-
-  return g_object_new (GTK_TYPE_PRINT_BACKEND_CUPS, NULL);
-}
-
-static void
-gtk_print_backend_cups_class_init (GtkPrintBackendCupsClass *class)
-{
-  GObjectClass *gobject_class = G_OBJECT_CLASS (class);
-  GtkPrintBackendClass *backend_class = GTK_PRINT_BACKEND_CLASS (class);
-
-  backend_parent_class = g_type_class_peek_parent (class);
-
-  gobject_class->finalize = gtk_print_backend_cups_finalize;
-  gobject_class->dispose = gtk_print_backend_cups_dispose;
-
-  backend_class->request_printer_list = cups_get_printer_list; 
-  backend_class->print_stream = gtk_print_backend_cups_print_stream;
-  backend_class->printer_request_details = cups_printer_request_details;
-  backend_class->printer_create_cairo_surface = cups_printer_create_cairo_surface;
-  backend_class->printer_get_options = cups_printer_get_options;
-  backend_class->printer_mark_conflicts = cups_printer_mark_conflicts;
-  backend_class->printer_get_settings_from_options = cups_printer_get_settings_from_options;
-  backend_class->printer_prepare_for_print = cups_printer_prepare_for_print;
-  backend_class->printer_list_papers = cups_printer_list_papers;
-  backend_class->printer_get_default_page_size = cups_printer_get_default_page_size;
-  backend_class->printer_get_hard_margins = cups_printer_get_hard_margins;
-  backend_class->printer_get_capabilities = cups_printer_get_capabilities;
-  backend_class->set_password = gtk_print_backend_cups_set_password;
-}
-
-static cairo_status_t
-_cairo_write_to_cups (void                *closure,
-                      const unsigned char *data,
-                      unsigned int         length)
-{
-  GIOChannel *io = (GIOChannel *)closure;
-  gsize written;
-  GError *error;
-
-  error = NULL;
-
-  GTK_NOTE (PRINTING,
-            g_print ("CUPS Backend: Writing %i byte chunk to temp file\n", length));
-
-  while (length > 0) 
-    {
-      g_io_channel_write_chars (io, (gchar *)data, length, &written, &error);
-
-      if (error != NULL)
-	{
-	  GTK_NOTE (PRINTING,
-                    g_print ("CUPS Backend: Error writing to temp file, %s\n", 
-                             error->message));
-
-          g_error_free (error);
-	  return CAIRO_STATUS_WRITE_ERROR;
-	}    
-
-      GTK_NOTE (PRINTING,
-                g_print ("CUPS Backend: Wrote %" G_GSIZE_FORMAT " bytes to temp file\n", written));
-
-      data += written;
-      length -= written;
-    }
-
-  return CAIRO_STATUS_SUCCESS;
-}
-
-static cairo_surface_t *
-cups_printer_create_cairo_surface (GtkPrinter       *printer,
-				   GtkPrintSettings *settings,
-				   gdouble           width, 
-				   gdouble           height,
-				   GIOChannel       *cache_io)
-{
-  cairo_surface_t *surface;
-  ppd_file_t      *ppd_file = NULL;
-  ppd_attr_t      *ppd_attr = NULL;
-  ppd_attr_t      *ppd_attr_res = NULL;
-  ppd_attr_t      *ppd_attr_screen_freq = NULL;
-  ppd_attr_t      *ppd_attr_res_screen_freq = NULL;
-  gchar           *res_string = NULL;
-  gint             level = 2;
-
-  if (gtk_printer_accepts_pdf (printer))
-    surface = cairo_pdf_surface_create_for_stream (_cairo_write_to_cups, cache_io, width, height);
-  else
-    surface = cairo_ps_surface_create_for_stream  (_cairo_write_to_cups, cache_io, width, height);
-
-  ppd_file = gtk_printer_cups_get_ppd (GTK_PRINTER_CUPS (printer));
-
-  if (ppd_file != NULL)
-    {
-      ppd_attr = ppdFindAttr (ppd_file, "LanguageLevel", NULL);
-
-      if (ppd_attr != NULL)
-        level = atoi (ppd_attr->value);
-
-      if (gtk_print_settings_get_resolution (settings) == 0)
-        {
-          ppd_attr_res = ppdFindAttr (ppd_file, "DefaultResolution", NULL);
-
-          if (ppd_attr_res != NULL)
-            {
-              int res, res_x, res_y;
-
-              if (sscanf (ppd_attr_res->value, "%dx%ddpi", &res_x, &res_y) == 2)
-                {
-                  if (res_x > 0 && res_y > 0)
-                    gtk_print_settings_set_resolution_xy (settings, res_x, res_y);
-                }
-              else if (sscanf (ppd_attr_res->value, "%ddpi", &res) == 1)
-                {
-                  if (res > 0)
-                    gtk_print_settings_set_resolution (settings, res);
-                }
-            }
-        }
-
-      res_string = g_strdup_printf ("%ddpi",
-                                    gtk_print_settings_get_resolution (settings));
-      ppd_attr_res_screen_freq = ppdFindAttr (ppd_file, "ResScreenFreq", res_string);
-      g_free (res_string);
-
-      if (ppd_attr_res_screen_freq == NULL)
-        {
-          res_string = g_strdup_printf ("%dx%ddpi",
-                                        gtk_print_settings_get_resolution_x (settings),
-                                        gtk_print_settings_get_resolution_y (settings));
-          ppd_attr_res_screen_freq = ppdFindAttr (ppd_file, "ResScreenFreq", res_string);
-          g_free (res_string);
-        }
-
-      ppd_attr_screen_freq = ppdFindAttr (ppd_file, "ScreenFreq", NULL);
-
-      if (ppd_attr_res_screen_freq != NULL && atof (ppd_attr_res_screen_freq->value) > 0.0)
-        gtk_print_settings_set_printer_lpi (settings, atof (ppd_attr_res_screen_freq->value));
-      else if (ppd_attr_screen_freq != NULL && atof (ppd_attr_screen_freq->value) > 0.0)
-        gtk_print_settings_set_printer_lpi (settings, atof (ppd_attr_screen_freq->value));
-    }
-
-  if (cairo_surface_get_type (surface) == CAIRO_SURFACE_TYPE_PS)
-    {
-      if (level == 2)
-        cairo_ps_surface_restrict_to_level (surface, CAIRO_PS_LEVEL_2);
-
-      if (level == 3)
-        cairo_ps_surface_restrict_to_level (surface, CAIRO_PS_LEVEL_3);
-    }
-
-  cairo_surface_set_fallback_resolution (surface,
-                                         2.0 * gtk_print_settings_get_printer_lpi (settings),
-                                         2.0 * gtk_print_settings_get_printer_lpi (settings));
-
-  return surface;
-}
-
-typedef struct {
-  GtkPrintJobCompleteFunc callback;
-  GtkPrintJob *job;
-  gpointer user_data;
-  GDestroyNotify dnotify;
-} CupsPrintStreamData;
-
-static void
-cups_free_print_stream_data (CupsPrintStreamData *data)
-{
-  GTK_NOTE (PRINTING,
-            g_print ("CUPS Backend: %s\n", G_STRFUNC));
-
-  if (data->dnotify)
-    data->dnotify (data->user_data);
-  g_object_unref (data->job);
-  g_free (data);
-}
-
-static void
-cups_print_cb (GtkPrintBackendCups *print_backend,
-               GtkCupsResult       *result,
-               gpointer             user_data)
-{
-  GError *error = NULL;
-  CupsPrintStreamData *ps = user_data;
-
-  GDK_THREADS_ENTER ();
-
-  GTK_NOTE (PRINTING,
-            g_print ("CUPS Backend: %s\n", G_STRFUNC)); 
-
-  if (gtk_cups_result_is_error (result))
-    error = g_error_new_literal (gtk_print_error_quark (),
-                                 GTK_PRINT_ERROR_INTERNAL_ERROR,
-                                 gtk_cups_result_get_error_string (result));
-
-  if (ps->callback)
-    ps->callback (ps->job, ps->user_data, error);
-
-  if (error == NULL)
-    {
-      int job_id = 0;
-      ipp_attribute_t *attr;		/* IPP job-id attribute */
-      ipp_t *response = gtk_cups_result_get_response (result);
-
-      if ((attr = ippFindAttribute (response, "job-id", IPP_TAG_INTEGER)) != NULL)
-	job_id = ippGetInteger (attr, 0);
-
-      if (!gtk_print_job_get_track_print_status (ps->job) || job_id == 0)
-	gtk_print_job_set_status (ps->job, GTK_PRINT_STATUS_FINISHED);
-      else
-	{
-	  gtk_print_job_set_status (ps->job, GTK_PRINT_STATUS_PENDING);
-	  cups_begin_polling_info (print_backend, ps->job, job_id);
-	}
-    } 
-  else
-    gtk_print_job_set_status (ps->job, GTK_PRINT_STATUS_FINISHED_ABORTED);
-
-  
-  if (error)
-    g_error_free (error);
-
-  GDK_THREADS_LEAVE ();  
-}
-
-typedef struct {
-  GtkCupsRequest *request;
-  GtkPrinterCups *printer;
-} CupsOptionsData;
-
-static void
-add_cups_options (const gchar *key,
-		  const gchar *value,
-		  gpointer     user_data)
-{
-  CupsOptionsData *data = (CupsOptionsData *) user_data;
-  GtkCupsRequest *request = data->request;
-  GtkPrinterCups *printer = data->printer;
-  gboolean custom_value = FALSE;
-  gchar *new_value = NULL;
-  gint i;
-
-  if (!key || !value)
-    return;
-
-  if (!g_str_has_prefix (key, "cups-"))
-    return;
-
-  if (strcmp (value, "gtk-ignore-value") == 0)
-    return;
-
-  key = key + strlen ("cups-");
-
-  if (printer && printer->ppd_file)
-    {
-      ppd_coption_t *coption;
-      gboolean       found = FALSE;
-      gboolean       custom_values_enabled = FALSE;
-
-      coption = ppdFindCustomOption (printer->ppd_file, key);
-      if (coption && coption->option)
-        {
-          for (i = 0; i < coption->option->num_choices; i++)
-            {
-              /* Are custom values enabled ? */
-              if (g_str_equal (coption->option->choices[i].choice, "Custom"))
-                custom_values_enabled = TRUE;
-
-              /* Is the value among available choices ? */
-              if (g_str_equal (coption->option->choices[i].choice, value))
-                found = TRUE;
-            }
-
-          if (custom_values_enabled && !found)
-            custom_value = TRUE;
-        }
-    }
-
-  /* Add "Custom." prefix to custom values if not already added. */
-  if (custom_value && !g_str_has_prefix (value, "Custom."))
-    {
-      new_value = g_strdup_printf ("Custom.%s", value);
-      gtk_cups_request_encode_option (request, key, new_value);
-      g_free (new_value);
-    }
-  else
-    gtk_cups_request_encode_option (request, key, value);
-}
-
-static void
-gtk_print_backend_cups_print_stream (GtkPrintBackend         *print_backend,
-                                     GtkPrintJob             *job,
-				     GIOChannel              *data_io,
-				     GtkPrintJobCompleteFunc  callback,
-				     gpointer                 user_data,
-				     GDestroyNotify           dnotify)
-{
-  GtkPrinterCups *cups_printer;
-  CupsPrintStreamData *ps;
-  CupsOptionsData *options_data;
-  GtkCupsRequest *request = NULL;
-  GtkPrintSettings *settings;
-  const gchar *title;
-  char  printer_absolute_uri[HTTP_MAX_URI];
-
-  GTK_NOTE (PRINTING,
-            g_print ("CUPS Backend: %s\n", G_STRFUNC));   
-
-  cups_printer = GTK_PRINTER_CUPS (gtk_print_job_get_printer (job));
-  settings = gtk_print_job_get_settings (job);
-
-  request = gtk_cups_request_new_with_username (NULL,
-                                                GTK_CUPS_POST,
-                                                IPP_PRINT_JOB,
-                                                data_io,
-                                                NULL,
-                                                cups_printer->device_uri,
-                                                GTK_PRINT_BACKEND_CUPS (print_backend)->username);
-
-#ifdef HAVE_CUPS_API_1_6
-  if (cups_printer->avahi_browsed)
-    {
-      http_t *http;
-
-      http = httpConnect (cups_printer->hostname, cups_printer->port);
-      if (http)
-        {
-          request = gtk_cups_request_new_with_username (http,
-                                                        GTK_CUPS_POST,
-                                                        IPP_PRINT_JOB,
-                                                        data_io,
-                                                        cups_printer->hostname,
-                                                        cups_printer->device_uri,
-                                                        GTK_PRINT_BACKEND_CUPS (print_backend)->username);
-          g_snprintf (printer_absolute_uri, HTTP_MAX_URI, "%s", cups_printer->printer_uri);
-        }
-      else
-        {
-          GError *error = NULL;
-
-          GTK_NOTE (PRINTING,
-                    g_warning ("CUPS Backend: Error connecting to %s:%d",
-                               cups_printer->hostname,
-                               cups_printer->port));
-
-          error = g_error_new (gtk_print_error_quark (),
-                               GTK_CUPS_ERROR_GENERAL,
-                               "Error connecting to %s",
-                               cups_printer->hostname);
-
-          gtk_print_job_set_status (job, GTK_PRINT_STATUS_FINISHED_ABORTED);
-
-          if (callback)
-            {
-              callback (job, user_data, error);
-            }
-
-          g_clear_error (&error);
-
-          return;
-        }
-    }
-  else
-#endif
-    {
-      request = gtk_cups_request_new_with_username (NULL,
-                                                    GTK_CUPS_POST,
-                                                    IPP_PRINT_JOB,
-                                                    data_io,
-                                                    NULL,
-                                                    cups_printer->device_uri,
-                                                    GTK_PRINT_BACKEND_CUPS (print_backend)->username);
-
-#if (CUPS_VERSION_MAJOR == 1 && CUPS_VERSION_MINOR >= 2) || CUPS_VERSION_MAJOR > 1
-      httpAssembleURIf (HTTP_URI_CODING_ALL,
-                        printer_absolute_uri,
-                        sizeof (printer_absolute_uri),
-                        "ipp",
-                        NULL,
-                        "localhost",
-                        ippPort (),
-                        "/printers/%s",
-                        gtk_printer_get_name (gtk_print_job_get_printer (job)));
-#else
-      g_snprintf (printer_absolute_uri,
-                  sizeof (printer_absolute_uri),
-                  "ipp://localhost:%d/printers/%s",
-                  ippPort (),
-                  gtk_printer_get_name (gtk_print_job_get_printer (job)));
-#endif
-    }
-
-  gtk_cups_request_set_ipp_version (request,
-                                    cups_printer->ipp_version_major,
-                                    cups_printer->ipp_version_minor);
-
-  gtk_cups_request_ipp_add_string (request, IPP_TAG_OPERATION, 
-                                   IPP_TAG_URI, "printer-uri",
-                                   NULL, printer_absolute_uri);
-
-  title = gtk_print_job_get_title (job);
-  if (title)
-    gtk_cups_request_ipp_add_string (request, IPP_TAG_OPERATION, 
-                                     IPP_TAG_NAME, "job-name", 
-                                     NULL, title);
-
-  options_data = g_new0 (CupsOptionsData, 1);
-  options_data->request = request;
-  options_data->printer = cups_printer;
-  gtk_print_settings_foreach (settings, add_cups_options, options_data);
-  g_free (options_data);
-
-  ps = g_new0 (CupsPrintStreamData, 1);
-  ps->callback = callback;
-  ps->user_data = user_data;
-  ps->dnotify = dnotify;
-  ps->job = g_object_ref (job);
-
-  request->need_auth_info = cups_printer->auth_info_required != NULL;
-  request->auth_info_required = g_strdupv (cups_printer->auth_info_required);
-
-  cups_request_execute (GTK_PRINT_BACKEND_CUPS (print_backend),
-                        request,
-                        (GtkPrintCupsResponseCallbackFunc) cups_print_cb,
-                        ps,
-                        (GDestroyNotify)cups_free_print_stream_data);
-}
-
-void overwrite_and_free (gpointer data)
-{
-  gchar *password = (gchar *) data;
-
-  if (password != NULL)
-    {
-      memset (password, 0, strlen (password));
-      g_free (password);
-    }
-}
-
-static void
-gtk_print_backend_cups_init (GtkPrintBackendCups *backend_cups)
-{
-#ifdef HAVE_CUPS_API_1_6
-  gint i;
-#endif
-
-  backend_cups->list_printers_poll = FALSE;  
-  backend_cups->got_default_printer = FALSE;  
-  backend_cups->list_printers_pending = FALSE;
-  backend_cups->list_printers_attempts = 0;
-  backend_cups->reading_ppds = 0;
-
-  backend_cups->requests = NULL;
-  backend_cups->auth = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, overwrite_and_free);
-  backend_cups->authentication_lock = FALSE;
-
-  backend_cups->covers = NULL;
-  backend_cups->number_of_covers = 0;
-
-  backend_cups->default_printer_poll = 0;
-  backend_cups->cups_connection_test = NULL;
-
-  backend_cups->username = NULL;
-
-#ifdef HAVE_CUPS_API_1_6
-  backend_cups->dbus_connection = NULL;
-  backend_cups->avahi_default_printer = NULL;
-  backend_cups->avahi_service_browser_subscription_id = 0;
-  for (i = 0; i < 2; i++)
-    {
-      backend_cups->avahi_service_browser_paths[i] = NULL;
-      backend_cups->avahi_service_browser_subscription_ids[i] = 0;
-    }
-#endif
-
-  cups_get_local_default_printer (backend_cups);
-}
-
-static void
-gtk_print_backend_cups_finalize (GObject *object)
-{
-  GtkPrintBackendCups *backend_cups;
-  
-  GTK_NOTE (PRINTING,
-            g_print ("CUPS Backend: finalizing CUPS backend module\n"));
-
-  backend_cups = GTK_PRINT_BACKEND_CUPS (object);
-
-  g_free (backend_cups->default_printer);
-  backend_cups->default_printer = NULL;
-
-  g_strfreev (backend_cups->covers);
-  backend_cups->number_of_covers = 0;
-
-  gtk_cups_connection_test_free (backend_cups->cups_connection_test);
-  backend_cups->cups_connection_test = NULL;
-
-  g_hash_table_destroy (backend_cups->auth);
-
-  g_free (backend_cups->username);
-
-#ifdef HAVE_CUPS_API_1_6
-  g_clear_object (&backend_cups->avahi_cancellable);
-  g_free (backend_cups->avahi_default_printer);
-  backend_cups->avahi_default_printer = NULL;
-  g_clear_object (&backend_cups->dbus_connection);
-#endif
-
-  backend_parent_class->finalize (object);
-}
-
-static void
-gtk_print_backend_cups_dispose (GObject *object)
-{
-  GtkPrintBackendCups *backend_cups;
-#ifdef HAVE_CUPS_API_1_6
-  gint                 i;
-#endif
-
-  GTK_NOTE (PRINTING,
-            g_print ("CUPS Backend: %s\n", G_STRFUNC));
-
-  backend_cups = GTK_PRINT_BACKEND_CUPS (object);
-
-  if (backend_cups->list_printers_poll > 0)
-    g_source_remove (backend_cups->list_printers_poll);
-  backend_cups->list_printers_poll = 0;
-  backend_cups->list_printers_attempts = 0;
-  
-  if (backend_cups->default_printer_poll > 0)
-    g_source_remove (backend_cups->default_printer_poll);
-  backend_cups->default_printer_poll = 0;
-
-#ifdef HAVE_CUPS_API_1_6
-  g_cancellable_cancel (backend_cups->avahi_cancellable);
-
-  for (i = 0; i < 2; i++)
-    {
-      if (backend_cups->avahi_service_browser_subscription_ids[i] > 0)
-        {
-          backend_cups->avahi_service_browser_subscription_ids[i] = 0;
-        }
-
-      if (backend_cups->avahi_service_browser_paths[i])
-        {
-          g_free (backend_cups->avahi_service_browser_paths[i]);
-          backend_cups->avahi_service_browser_paths[i] = NULL;
-        }
-    }
-
-  if (backend_cups->avahi_service_browser_subscription_id > 0)
-    {
-      backend_cups->avahi_service_browser_subscription_id = 0;
-    }
-#endif
-
-  backend_parent_class->dispose (object);
-}
-
-static gboolean
-is_address_local (const gchar *address)
-{
-  if (address[0] == '/' ||
-      strcmp (address, "127.0.0.1") == 0 ||
-      strcmp (address, "[::1]") == 0)
-    return TRUE;
-  else
-    return FALSE;
-}
-
-#ifndef HAVE_CUPS_API_1_2
-/* Included from CUPS library because of backward compatibility */
-const char *
-httpGetHostname(http_t *http,
-                char   *s,
-                int    slen)
-{
-  struct hostent *host;
-
-  if (!s || slen <= 1)
-    return (NULL);
-
-  if (http)
-    {
-      if (http->hostname[0] == '/')
-        g_strlcpy (s, "localhost", slen);
-      else
-        g_strlcpy (s, http->hostname, slen);
-    }
-  else
-    {
-      if (gethostname (s, slen) < 0)
-        g_strlcpy (s, "localhost", slen);
-
-      if (!strchr (s, '.'))
-        {
-          if ((host = gethostbyname (s)) != NULL && host->h_name)
-            g_strlcpy (s, host->h_name, slen);
-        }
-    }
-  return (s);
-}
-#endif
-
-static void
-gtk_print_backend_cups_set_password (GtkPrintBackend  *backend,
-                                     gchar           **auth_info_required,
-                                     gchar           **auth_info)
-{
-  GtkPrintBackendCups *cups_backend = GTK_PRINT_BACKEND_CUPS (backend);
-  GList *l;
-  char   dispatch_hostname[HTTP_MAX_URI];
-  gchar *key;
-  gchar *username = NULL;
-  gchar *hostname = NULL;
-  gchar *password = NULL;
-  gint   length;
-  gint   i;
-
-  length = g_strv_length (auth_info_required);
-
-  if (auth_info != NULL)
-    for (i = 0; i < length; i++)
-      {
-        if (g_strcmp0 (auth_info_required[i], "username") == 0)
-          username = g_strdup (auth_info[i]);
-        else if (g_strcmp0 (auth_info_required[i], "hostname") == 0)
-          hostname = g_strdup (auth_info[i]);
-        else if (g_strcmp0 (auth_info_required[i], "password") == 0)
-          password = g_strdup (auth_info[i]);
-      }
-
-  if (hostname != NULL && username != NULL && password != NULL)
-    {
-      key = g_strconcat (username, "@", hostname, NULL);
-      g_hash_table_insert (cups_backend->auth, key, g_strdup (password));
-    }
-
-  g_free (cups_backend->username);
-  cups_backend->username = g_strdup (username);
-
-  GTK_NOTE (PRINTING,
-            g_print ("CUPS backend: storing password for %s\n", key));
-
-  for (l = cups_backend->requests; l; l = l->next)
-    {
-      GtkPrintCupsDispatchWatch *dispatch = l->data;
-
-      httpGetHostname (dispatch->request->http, dispatch_hostname, sizeof (dispatch_hostname));
-      if (is_address_local (dispatch_hostname))
-        strcpy (dispatch_hostname, "localhost");
-
-      if (dispatch->request->need_auth_info)
-        {
-          if (auth_info != NULL)
-            {
-              dispatch->request->auth_info = g_new0 (gchar *, length + 1);
-              for (i = 0; i < length; i++)
-                dispatch->request->auth_info[i] = g_strdup (auth_info[i]);
-            }
-          dispatch->backend->authentication_lock = FALSE;
-          dispatch->request->need_auth_info = FALSE;
-        }
-      else if (dispatch->request->password_state == GTK_CUPS_PASSWORD_REQUESTED || auth_info == NULL)
-        {
-          overwrite_and_free (dispatch->request->password);
-          dispatch->request->password = g_strdup (password);
-          g_free (dispatch->request->username);
-          dispatch->request->username = g_strdup (username);
-          dispatch->request->password_state = GTK_CUPS_PASSWORD_HAS;
-          dispatch->backend->authentication_lock = FALSE;
-        }
-    }
-}
-
-static gboolean
-request_password (gpointer data)
-{
-  GtkPrintCupsDispatchWatch *dispatch = data;
-  const gchar               *username;
-  gchar                     *password;
-  gchar                     *prompt = NULL;
-  gchar                     *key = NULL;
-  char                       hostname[HTTP_MAX_URI];
-  gchar                    **auth_info_required;
-  gchar                    **auth_info_default;
-  gchar                    **auth_info_display;
-  gboolean                  *auth_info_visible;
-  gint                       length = 3;
-  gint                       i;
-
-  if (dispatch->backend->authentication_lock)
-    return FALSE;
-
-  httpGetHostname (dispatch->request->http, hostname, sizeof (hostname));
-  if (is_address_local (hostname))
-    strcpy (hostname, "localhost");
-
-  if (dispatch->backend->username != NULL)
-    username = dispatch->backend->username;
-  else
-    username = cupsUser ();
-
-  auth_info_required = g_new0 (gchar*, length + 1);
-  auth_info_required[0] = g_strdup ("hostname");
-  auth_info_required[1] = g_strdup ("username");
-  auth_info_required[2] = g_strdup ("password");
-
-  auth_info_default = g_new0 (gchar*, length + 1);
-  auth_info_default[0] = g_strdup (hostname);
-  auth_info_default[1] = g_strdup (username);
-
-  auth_info_display = g_new0 (gchar*, length + 1);
-  auth_info_display[1] = g_strdup (_("Username:"));
-  auth_info_display[2] = g_strdup (_("Password:"));
-
-  auth_info_visible = g_new0 (gboolean, length + 1);
-  auth_info_visible[1] = TRUE;
-
-  key = g_strconcat (username, "@", hostname, NULL);
-  password = g_hash_table_lookup (dispatch->backend->auth, key);
-
-  if (password && dispatch->request->password_state != GTK_CUPS_PASSWORD_NOT_VALID)
-    {
-      GTK_NOTE (PRINTING,
-                g_print ("CUPS backend: using stored password for %s\n", key));
-
-      overwrite_and_free (dispatch->request->password);
-      dispatch->request->password = g_strdup (password);
-      g_free (dispatch->request->username);
-      dispatch->request->username = g_strdup (username);
-      dispatch->request->password_state = GTK_CUPS_PASSWORD_HAS;
-    }
-  else
-    {
-      const char *job_title = gtk_cups_request_ipp_get_string (dispatch->request, IPP_TAG_NAME, "job-name");
-      const char *printer_uri = gtk_cups_request_ipp_get_string (dispatch->request, IPP_TAG_URI, "printer-uri");
-      char *printer_name = NULL;
-
-      if (printer_uri != NULL && strrchr (printer_uri, '/') != NULL)
-        printer_name = g_strdup (strrchr (printer_uri, '/') + 1);
-
-      if (dispatch->request->password_state == GTK_CUPS_PASSWORD_NOT_VALID)
-        g_hash_table_remove (dispatch->backend->auth, key);
-
-      dispatch->request->password_state = GTK_CUPS_PASSWORD_REQUESTED;
-
-      dispatch->backend->authentication_lock = TRUE;
-
-      switch (ippGetOperation (dispatch->request->ipp_request))
-        {
-          case IPP_PRINT_JOB:
-            if (job_title != NULL && printer_name != NULL)
-              prompt = g_strdup_printf ( _("Authentication is required to print document '%s' on printer %s"), job_title, printer_name);
-            else
-              prompt = g_strdup_printf ( _("Authentication is required to print a document on %s"), hostname);
-            break;
-          case IPP_GET_JOB_ATTRIBUTES:
-            if (job_title != NULL)
-              prompt = g_strdup_printf ( _("Authentication is required to get attributes of job '%s'"), job_title);
-            else
-              prompt = g_strdup ( _("Authentication is required to get attributes of a job"));
-            break;
-          case IPP_GET_PRINTER_ATTRIBUTES:
-            if (printer_name != NULL)
-              prompt = g_strdup_printf ( _("Authentication is required to get attributes of printer %s"), printer_name);
-            else
-              prompt = g_strdup ( _("Authentication is required to get attributes of a printer"));
-            break;
-          case CUPS_GET_DEFAULT:
-            prompt = g_strdup_printf ( _("Authentication is required to get default printer of %s"), hostname);
-            break;
-          case CUPS_GET_PRINTERS:
-            prompt = g_strdup_printf ( _("Authentication is required to get printers from %s"), hostname);
-            break;
-          default:
-            /* work around gcc warning about 0 not being a value for this enum */
-            if (ippGetOperation (dispatch->request->ipp_request) == 0)
-              prompt = g_strdup_printf ( _("Authentication is required to get a file from %s"), hostname);
-            else
-              prompt = g_strdup_printf ( _("Authentication is required on %s"), hostname);
-            break;
-        }
-
-      g_free (printer_name);
-
-      g_signal_emit_by_name (dispatch->backend, "request-password", 
-                             auth_info_required, auth_info_default, auth_info_display, auth_info_visible, prompt);
-
-      g_free (prompt);
-    }
-
-  for (i = 0; i < length; i++)
-    {
-      g_free (auth_info_required[i]);
-      g_free (auth_info_default[i]);
-      g_free (auth_info_display[i]);
-    }
-
-  g_free (auth_info_required);
-  g_free (auth_info_default);
-  g_free (auth_info_display);
-  g_free (auth_info_visible);
-  g_free (key);
-
-  return FALSE;
-}
-
-static void
-cups_dispatch_add_poll (GSource *source)
-{
-  GtkPrintCupsDispatchWatch *dispatch;
-  GtkCupsPollState poll_state;
-
-  dispatch = (GtkPrintCupsDispatchWatch *) source;
-
-  poll_state = gtk_cups_request_get_poll_state (dispatch->request);
-
-  /* Remove the old source if the poll state changed. */
-  if (poll_state != dispatch->poll_state && dispatch->data_poll != NULL)
-    {
-      g_source_remove_poll (source, dispatch->data_poll);
-      g_free (dispatch->data_poll);
-      dispatch->data_poll = NULL;
-    }
-
-  if (dispatch->request->http != NULL)
-    {
-      if (dispatch->data_poll == NULL)
-        {
-	  dispatch->data_poll = g_new0 (GPollFD, 1);
-	  dispatch->poll_state = poll_state;
-
-	  if (poll_state == GTK_CUPS_HTTP_READ)
-	    dispatch->data_poll->events = G_IO_IN | G_IO_HUP | G_IO_ERR | G_IO_PRI;
-	  else if (poll_state == GTK_CUPS_HTTP_WRITE)
-	    dispatch->data_poll->events = G_IO_OUT | G_IO_ERR;
-	  else
-	    dispatch->data_poll->events = 0;
-
-#ifdef HAVE_CUPS_API_1_2
-          dispatch->data_poll->fd = httpGetFd (dispatch->request->http);
-#else
-          dispatch->data_poll->fd = dispatch->request->http->fd;
-#endif
-          g_source_add_poll (source, dispatch->data_poll);
-        }
-    }
-}
-
-static gboolean
-check_auth_info (gpointer user_data)
-{
-  GtkPrintCupsDispatchWatch *dispatch;
-  dispatch = (GtkPrintCupsDispatchWatch *) user_data;
-
-  if (!dispatch->request->need_auth_info)
-    {
-      if (dispatch->request->auth_info == NULL)
-        {
-          dispatch->callback (GTK_PRINT_BACKEND (dispatch->backend),
-                              gtk_cups_request_get_result (dispatch->request),
-                              dispatch->callback_data);
-          g_source_destroy ((GSource *) dispatch);
-        }
-      else
-        {
-          gint length;
-          gint i;
-
-          length = g_strv_length (dispatch->request->auth_info_required);
-
-          gtk_cups_request_ipp_add_strings (dispatch->request,
-                                            IPP_TAG_JOB,
-                                            IPP_TAG_TEXT,
-                                            "auth-info",
-                                            length,
-                                            NULL,
-                                            (const char * const *) dispatch->request->auth_info);
-
-          g_source_attach ((GSource *) dispatch, NULL);
-          g_source_unref ((GSource *) dispatch);
-
-          for (i = 0; i < length; i++)
-            overwrite_and_free (dispatch->request->auth_info[i]);
-          g_free (dispatch->request->auth_info);
-          dispatch->request->auth_info = NULL;
-        }
-
-      return FALSE;
-    }
-
-  return TRUE;
-}
-
-static gboolean
-request_auth_info (gpointer user_data)
-{
-  GtkPrintCupsDispatchWatch  *dispatch;
-  const char                 *job_title;
-  const char                 *printer_uri;
-  gchar                      *prompt = NULL;
-  char                       *printer_name = NULL;
-  gint                        length;
-  gint                        i;
-  gboolean                   *auth_info_visible = NULL;
-  gchar                     **auth_info_default = NULL;
-  gchar                     **auth_info_display = NULL;
-
-  dispatch = (GtkPrintCupsDispatchWatch *) user_data;
-
-  if (dispatch->backend->authentication_lock)
-    return FALSE;
-
-  job_title = gtk_cups_request_ipp_get_string (dispatch->request, IPP_TAG_NAME, "job-name");
-  printer_uri = gtk_cups_request_ipp_get_string (dispatch->request, IPP_TAG_URI, "printer-uri");
-  length = g_strv_length (dispatch->request->auth_info_required);
-
-  auth_info_visible = g_new0 (gboolean, length);
-  auth_info_default = g_new0 (gchar *, length + 1);
-  auth_info_display = g_new0 (gchar *, length + 1);
-
-  for (i = 0; i < length; i++)
-    {
-      if (g_strcmp0 (dispatch->request->auth_info_required[i], "domain") == 0)
-        {
-          auth_info_display[i] = g_strdup (_("Domain:"));
-          auth_info_default[i] = g_strdup ("WORKGROUP");
-          auth_info_visible[i] = TRUE;
-        }
-      else if (g_strcmp0 (dispatch->request->auth_info_required[i], "username") == 0)
-        {
-          auth_info_display[i] = g_strdup (_("Username:"));
-          if (dispatch->backend->username != NULL)
-            auth_info_default[i] = g_strdup (dispatch->backend->username);
-          else
-            auth_info_default[i] = g_strdup (cupsUser ());
-          auth_info_visible[i] = TRUE;
-        }
-      else if (g_strcmp0 (dispatch->request->auth_info_required[i], "password") == 0)
-        {
-          auth_info_display[i] = g_strdup (_("Password:"));
-          auth_info_visible[i] = FALSE;
-        }
-    }
-
-  if (printer_uri != NULL && strrchr (printer_uri, '/') != NULL)
-    printer_name = g_strdup (strrchr (printer_uri, '/') + 1);
-
-  dispatch->backend->authentication_lock = TRUE;
-
-  if (job_title != NULL)
-    {
-      if (printer_name != NULL)
-        prompt = g_strdup_printf ( _("Authentication is required to print document '%s' on printer %s"), job_title, printer_name);
-      else
-        prompt = g_strdup_printf ( _("Authentication is required to print document '%s'"), job_title);
-    }
-  else
-    {
-      if (printer_name != NULL)
-        prompt = g_strdup_printf ( _("Authentication is required to print this document on printer %s"), printer_name);
-      else
-        prompt = g_strdup ( _("Authentication is required to print this document"));
-    }
-
-  g_signal_emit_by_name (dispatch->backend, "request-password",
-                         dispatch->request->auth_info_required,
-                         auth_info_default,
-                         auth_info_display,
-                         auth_info_visible,
-                         prompt);
-
-  for (i = 0; i < length; i++)
-    {
-      g_free (auth_info_default[i]);
-      g_free (auth_info_display[i]);
-    }
-
-  g_free (auth_info_default);
-  g_free (auth_info_display);
-  g_free (printer_name);
-  g_free (prompt);
-
-  g_idle_add (check_auth_info, user_data);
-
-  return FALSE;
-}
-
-static gboolean
-cups_dispatch_watch_check (GSource *source)
-{
-  GtkPrintCupsDispatchWatch *dispatch;
-  GtkCupsPollState poll_state;
-  gboolean result;
-
-  GTK_NOTE (PRINTING,
-            g_print ("CUPS Backend: %s <source %p>\n", G_STRFUNC, source)); 
-
-  dispatch = (GtkPrintCupsDispatchWatch *) source;
-
-  poll_state = gtk_cups_request_get_poll_state (dispatch->request);
-
-  if (poll_state != GTK_CUPS_HTTP_IDLE && !dispatch->request->need_password)
-    if (!(dispatch->data_poll->revents & dispatch->data_poll->events)) 
-       return FALSE;
-  
-  result = gtk_cups_request_read_write (dispatch->request, FALSE);
-  if (result && dispatch->data_poll != NULL)
-    {
-      g_source_remove_poll (source, dispatch->data_poll);
-      g_free (dispatch->data_poll);
-      dispatch->data_poll = NULL;
-    }
-
-  if (dispatch->request->need_password && dispatch->request->password_state != GTK_CUPS_PASSWORD_REQUESTED)
-    {
-      dispatch->request->need_password = FALSE;
-      g_idle_add (request_password, dispatch);
-      result = FALSE;
-    }
-  
-  return result;
-}
-
-static gboolean
-cups_dispatch_watch_prepare (GSource *source,
-			     gint    *timeout_)
-{
-  GtkPrintCupsDispatchWatch *dispatch;
-  gboolean result;
-
-  dispatch = (GtkPrintCupsDispatchWatch *) source;
-
-  GTK_NOTE (PRINTING,
-            g_print ("CUPS Backend: %s <source %p>\n", G_STRFUNC, source));
-
-  *timeout_ = -1;
-
-  result = gtk_cups_request_read_write (dispatch->request, TRUE);
-
-  cups_dispatch_add_poll (source);
-
-  return result;
-}
-
-static gboolean
-cups_dispatch_watch_dispatch (GSource     *source,
-			      GSourceFunc  callback,
-			      gpointer     user_data)
-{
-  GtkPrintCupsDispatchWatch *dispatch;
-  GtkPrintCupsResponseCallbackFunc ep_callback;  
-  GtkCupsResult *result;
-  
-  g_assert (callback != NULL);
-
-  ep_callback = (GtkPrintCupsResponseCallbackFunc) callback;
-  
-  dispatch = (GtkPrintCupsDispatchWatch *) source;
-
-  result = gtk_cups_request_get_result (dispatch->request);
-
-  GTK_NOTE (PRINTING,
-            g_print ("CUPS Backend: %s <source %p>\n", G_STRFUNC, source));
-
-  if (gtk_cups_result_is_error (result))
-    {
-      GTK_NOTE (PRINTING, 
-                g_print("Error result: %s (type %i, status %i, code %i)\n", 
-                        gtk_cups_result_get_error_string (result),
-                        gtk_cups_result_get_error_type (result),
-                        gtk_cups_result_get_error_status (result),
-                        gtk_cups_result_get_error_code (result)));
-     }
-
-  ep_callback (GTK_PRINT_BACKEND (dispatch->backend), result, user_data);
-    
-  return FALSE;
-}
-
-static void
-cups_dispatch_watch_finalize (GSource *source)
-{
-  GtkPrintCupsDispatchWatch *dispatch;
-  GtkCupsResult *result;
-
-  GTK_NOTE (PRINTING,
-            g_print ("CUPS Backend: %s <source %p>\n", G_STRFUNC, source));
-
-  dispatch = (GtkPrintCupsDispatchWatch *) source;
-
-  result = gtk_cups_request_get_result (dispatch->request);
-  if (gtk_cups_result_get_error_type (result) == GTK_CUPS_ERROR_AUTH)
-    {
-      const gchar *username;
-      gchar        hostname[HTTP_MAX_URI];
-      gchar       *key;
-    
-      httpGetHostname (dispatch->request->http, hostname, sizeof (hostname));
-      if (is_address_local (hostname))
-        strcpy (hostname, "localhost");
-
-      if (dispatch->backend->username != NULL)
-        username = dispatch->backend->username;
-      else
-        username = cupsUser ();
-
-      key = g_strconcat (username, "@", hostname, NULL);
-      GTK_NOTE (PRINTING,
-                g_print ("CUPS backend: removing stored password for %s\n", key));
-      g_hash_table_remove (dispatch->backend->auth, key);
-      g_free (key);
-      
-      if (dispatch->backend)
-        dispatch->backend->authentication_lock = FALSE;
-    }
-
-  gtk_cups_request_free (dispatch->request);
-
-  if (dispatch->backend)
-    {
-      /* We need to unref this at idle time, because it might be the
-       * last reference to this module causing the code to be
-       * unloaded (including this particular function!)
-       * Update: Doing this at idle caused a deadlock taking the
-       * mainloop context lock while being in a GSource callout for
-       * multithreaded apps. So, for now we just disable unloading
-       * of print backends. See _gtk_print_backend_create for the
-       * disabling.
-       */
-
-      dispatch->backend->requests = g_list_remove (dispatch->backend->requests, dispatch);
-
-      
-      g_object_unref (dispatch->backend);
-      dispatch->backend = NULL;
-    }
-
-  if (dispatch->data_poll)
-    {
-      g_source_remove_poll (source, dispatch->data_poll);
-      g_free (dispatch->data_poll);
-      dispatch->data_poll = NULL;
-    }
-}
-
-static GSourceFuncs _cups_dispatch_watch_funcs = {
-  cups_dispatch_watch_prepare,
-  cups_dispatch_watch_check,
-  cups_dispatch_watch_dispatch,
-  cups_dispatch_watch_finalize
-};
-
-
-static void
-cups_request_execute (GtkPrintBackendCups              *print_backend,
-                      GtkCupsRequest                   *request,
-                      GtkPrintCupsResponseCallbackFunc  callback,
-                      gpointer                          user_data,
-                      GDestroyNotify                    notify)
-{
-  GtkPrintCupsDispatchWatch *dispatch;
-
-  dispatch = (GtkPrintCupsDispatchWatch *) g_source_new (&_cups_dispatch_watch_funcs, 
-                                                         sizeof (GtkPrintCupsDispatchWatch));
-  g_source_set_name (&dispatch->source, "GTK+ CUPS backend");
-
-  GTK_NOTE (PRINTING,
-            g_print ("CUPS Backend: %s <source %p> - Executing cups request on server '%s' and resource '%s'\n", G_STRFUNC, dispatch, request->server, request->resource));
-
-  dispatch->request = request;
-  dispatch->backend = g_object_ref (print_backend);
-  dispatch->poll_state = GTK_CUPS_HTTP_IDLE;
-  dispatch->data_poll = NULL;
-  dispatch->callback = NULL;
-  dispatch->callback_data = NULL;
-
-  print_backend->requests = g_list_prepend (print_backend->requests, dispatch);
-
-  g_source_set_callback ((GSource *) dispatch, (GSourceFunc) callback, user_data, notify);
-
-  if (request->need_auth_info)
-    {
-      dispatch->callback = callback;
-      dispatch->callback_data = user_data;
-      request_auth_info (dispatch);
-    }
-  else
-    {
-      g_source_attach ((GSource *) dispatch, NULL);
-      g_source_unref ((GSource *) dispatch);
-    }
-}
-
-#if 0
-static void
-cups_request_printer_info_cb (GtkPrintBackendCups *backend,
-                              GtkCupsResult       *result,
-                              gpointer             user_data)
-{
-  ipp_attribute_t *attr;
-  ipp_t *response;
-  gchar *printer_name;
-  GtkPrinterCups *cups_printer;
-  GtkPrinter *printer;
-  gchar *loc;
-  gchar *desc;
-  gchar *state_msg;
-  int job_count;
-  gboolean status_changed;  
-
-  g_assert (GTK_IS_PRINT_BACKEND_CUPS (backend));
-
-  printer_name = (gchar *)user_data;
-  printer = gtk_print_backend_find_printer (GTK_PRINT_BACKEND (backend),
-					    printer_name);
-
-  GTK_NOTE (PRINTING,
-            g_print ("CUPS Backend: %s - Got printer info for printer '%s'\n", G_STRFUNC, printer_name));
-
-  if (!printer)
-    {
-      GTK_NOTE (PRINTING,
-            g_print ("CUPS Backend: Could not find printer called '%s'\n", printer_name));
-      return;
-    }
-
-  cups_printer = GTK_PRINTER_CUPS (printer);
-  
-  if (gtk_cups_result_is_error (result))
-    {
-      if (gtk_printer_is_new (printer))
-	{
-	  gtk_print_backend_remove_printer (GTK_PRINT_BACKEND (backend),
-					    printer);
-	  return;
-	}
-      else
-	return; /* TODO: mark as inactive printer */
-    }
-
-  response = gtk_cups_result_get_response (result);
-
-  /* TODO: determine printer type and use correct icon */
-  gtk_printer_set_icon_name (printer, "gtk-print");
- 
-  state_msg = "";
-  loc = "";
-  desc = "";
-  job_count = 0;
-  for (attr = response->attrs; attr != NULL; attr = attr->next) 
-    {
-      if (!attr->name)
-        continue;
-
-      _CUPS_MAP_ATTR_STR (attr, loc, "printer-location");
-      _CUPS_MAP_ATTR_STR (attr, desc, "printer-info");
-      _CUPS_MAP_ATTR_STR (attr, state_msg, "printer-state-message");
-      _CUPS_MAP_ATTR_INT (attr, cups_printer->state, "printer-state");
-      _CUPS_MAP_ATTR_INT (attr, job_count, "queued-job-count");
-    }
-
-  status_changed = gtk_printer_set_job_count (printer, job_count);
-  
-  status_changed |= gtk_printer_set_location (printer, loc);
-  status_changed |= gtk_printer_set_description (printer, desc);
-  status_changed |= gtk_printer_set_state_message (printer, state_msg);
-
-  if (status_changed)
-    g_signal_emit_by_name (GTK_PRINT_BACKEND (backend),
-			   "printer-status-changed", printer); 
-}
-
-static void
-cups_request_printer_info (GtkPrintBackendCups *print_backend,
-                           const gchar         *printer_name)
-{
-  GtkCupsRequest *request;
-  gchar *printer_uri;
-  static const char * const pattrs[] =	/* Attributes we're interested in */
-    {
-      "printer-location",
-      "printer-info",
-      "printer-state-message",
-      "printer-state",
-      "queued-job-count",
-      "job-sheets-supported",
-      "job-sheets-default"
-    };
-
-  request = gtk_cups_request_new_with_username (NULL,
-                                                GTK_CUPS_POST,
-                                                IPP_GET_PRINTER_ATTRIBUTES,
-                                                NULL,
-                                                NULL,
-                                                NULL,
-                                                print_backend->username);
-
-  printer_uri = g_strdup_printf ("ipp://localhost/printers/%s",
-                                  printer_name);
-  gtk_cups_request_ipp_add_string (request, IPP_TAG_OPERATION, IPP_TAG_URI,
-                                   "printer-uri", NULL, printer_uri);
-
-  GTK_NOTE (PRINTING,
-            g_print ("CUPS Backend: %s - Requesting printer info for URI '%s'\n", G_STRFUNC, printer_uri));
-
-  g_free (printer_uri);
-
-  gtk_cups_request_ipp_add_strings (request, IPP_TAG_OPERATION, IPP_TAG_KEYWORD,
-				    "requested-attributes", G_N_ELEMENTS (pattrs),
-				    NULL, pattrs);
- 
-  cups_request_execute (print_backend,
-                        request,
-                        (GtkPrintCupsResponseCallbackFunc) cups_request_printer_info_cb,
-                        g_strdup (printer_name),
-                        (GDestroyNotify) g_free);
-}
-#endif
-
-typedef struct {
-  GtkPrintBackendCups *print_backend;
-  GtkPrintJob *job;
-  int job_id;
-  int counter;
-} CupsJobPollData;
-
-static void
-job_object_died	(gpointer  user_data,
-		 GObject  *where_the_object_was)
-{
-  CupsJobPollData *data = user_data;
-  data->job = NULL;
-}
-
-static void
-cups_job_poll_data_free (CupsJobPollData *data)
-{
-  if (data->job)
-    g_object_weak_unref (G_OBJECT (data->job), job_object_died, data);
-    
-  g_free (data);
-}
-
-static void
-cups_request_job_info_cb (GtkPrintBackendCups *print_backend,
-			  GtkCupsResult       *result,
-			  gpointer             user_data)
-{
-  CupsJobPollData *data = user_data;
-  ipp_attribute_t *attr;
-  ipp_t *response;
-  int state;
-  gboolean done;
-
-  GDK_THREADS_ENTER ();
-
-  if (data->job == NULL)
-    {
-      cups_job_poll_data_free (data);
-      goto done;
-    }
-
-  data->counter++;
-
-  response = gtk_cups_result_get_response (result);
-
-  state = 0;
-
-#ifdef HAVE_CUPS_API_1_6
-  attr = ippFindAttribute (response, "job-state", IPP_TAG_ENUM);
-  state = ippGetInteger (attr, 0);
-#else
-  for (attr = response->attrs; attr != NULL; attr = attr->next) 
-    {
-      if (!attr->name)
-        continue;
-      
-      _CUPS_MAP_ATTR_INT (attr, state, "job-state");
-    }
-#endif
-
-  done = FALSE;
-  switch (state)
-    {
-    case IPP_JOB_PENDING:
-    case IPP_JOB_HELD:
-    case IPP_JOB_STOPPED:
-      gtk_print_job_set_status (data->job,
-				GTK_PRINT_STATUS_PENDING);
-      break;
-    case IPP_JOB_PROCESSING:
-      gtk_print_job_set_status (data->job,
-				GTK_PRINT_STATUS_PRINTING);
-      break;
-    default:
-    case IPP_JOB_CANCELLED:
-    case IPP_JOB_ABORTED:
-      gtk_print_job_set_status (data->job,
-				GTK_PRINT_STATUS_FINISHED_ABORTED);
-      done = TRUE;
-      break;
-    case 0:
-    case IPP_JOB_COMPLETED:
-      gtk_print_job_set_status (data->job,
-				GTK_PRINT_STATUS_FINISHED);
-      done = TRUE;
-      break;
-    }
-
-  if (!done && data->job != NULL)
-    {
-      guint32 timeout;
-
-      if (data->counter < 5)
-	timeout = 100;
-      else if (data->counter < 10)
-	timeout = 500;
-      else
-	timeout = 1000;
-      
-      g_timeout_add (timeout, cups_job_info_poll_timeout, data);
-    }
-  else
-    cups_job_poll_data_free (data);    
-
-done:
-  GDK_THREADS_LEAVE ();
-}
-
-static void
-cups_request_job_info (CupsJobPollData *data)
-{
-  GtkCupsRequest *request;
-  gchar *job_uri;
-
-  request = gtk_cups_request_new_with_username (NULL,
-                                                GTK_CUPS_POST,
-                                                IPP_GET_JOB_ATTRIBUTES,
-                                                NULL,
-                                                NULL,
-                                                NULL,
-                                                data->print_backend->username);
-
-  job_uri = g_strdup_printf ("ipp://localhost/jobs/%d", data->job_id);
-  gtk_cups_request_ipp_add_string (request, IPP_TAG_OPERATION, IPP_TAG_URI,
-                                   "job-uri", NULL, job_uri);
-  g_free (job_uri);
-
-  cups_request_execute (data->print_backend,
-                        request,
-                        (GtkPrintCupsResponseCallbackFunc) cups_request_job_info_cb,
-                        data,
-                        NULL);
-}
-
-static gboolean
-cups_job_info_poll_timeout (gpointer user_data)
-{
-  CupsJobPollData *data = user_data;
-  
-  if (data->job == NULL)
-    cups_job_poll_data_free (data);
-  else
-    cups_request_job_info (data);
-  
-  return FALSE;
-}
-
-static void
-cups_begin_polling_info (GtkPrintBackendCups *print_backend,
-			 GtkPrintJob         *job,
-			 gint                 job_id)
-{
-  CupsJobPollData *data;
-
-  data = g_new0 (CupsJobPollData, 1);
-
-  data->print_backend = print_backend;
-  data->job = job;
-  data->job_id = job_id;
-  data->counter = 0;
-
-  g_object_weak_ref (G_OBJECT (job), job_object_died, data);
-
-  cups_request_job_info (data);
-}
-
-static void
-mark_printer_inactive (GtkPrinter      *printer, 
-                       GtkPrintBackend *backend)
-{
-  gtk_printer_set_is_active (printer, FALSE);
-  g_signal_emit_by_name (backend, "printer-removed", printer);
-}
-
-static gint
-find_printer (GtkPrinter  *printer, 
-	      const gchar *find_name)
-{
-  const gchar *printer_name;
-
-  printer_name = gtk_printer_get_name (printer);
-  return g_ascii_strcasecmp (printer_name, find_name);
-}
-/* Printer messages we're interested in */
-static const char * const printer_messages[] =
-  {
-    "toner-low",
-    "toner-empty",
-    "developer-low",
-    "developer-empty",
-    "marker-supply-low",
-    "marker-supply-empty",
-    "cover-open",
-    "door-open",
-    "media-low",
-    "media-empty",
-    "offline",
-    "other"
-  };
-/* Our translatable versions of the printer messages */
-static const char * printer_strings[] =
-  {
-    N_("Printer '%s' is low on toner."),
-    N_("Printer '%s' has no toner left."),
-    /* Translators: "Developer" like on photo development context */
-    N_("Printer '%s' is low on developer."),
-    /* Translators: "Developer" like on photo development context */
-    N_("Printer '%s' is out of developer."),
-    /* Translators: "marker" is one color bin of the printer */
-    N_("Printer '%s' is low on at least one marker supply."),
-    /* Translators: "marker" is one color bin of the printer */
-    N_("Printer '%s' is out of at least one marker supply."),
-    N_("The cover is open on printer '%s'."),
-    N_("The door is open on printer '%s'."),
-    N_("Printer '%s' is low on paper."),
-    N_("Printer '%s' is out of paper."),
-    N_("Printer '%s' is currently offline."),
-    N_("There is a problem on printer '%s'.")
-  };
-
-/* Attributes we're interested in for printers */
-static const char * const printer_attrs[] =
-  {
-    "printer-name",
-    "printer-uri-supported",
-    "member-uris",
-    "printer-location",
-    "printer-info",
-    "printer-state-message",
-    "printer-state-reasons",
-    "printer-state",
-    "queued-job-count",
-    "printer-is-accepting-jobs",
-    "job-sheets-supported",
-    "job-sheets-default",
-    "printer-type",
-    "auth-info-required",
-    "number-up-default",
-    "ipp-versions-supported",
-    "multiple-document-handling-supported",
-    "copies-supported",
-    "number-up-supported"
-  };
-
-typedef enum
-  {
-    GTK_PRINTER_STATE_LEVEL_NONE = 0,
-    GTK_PRINTER_STATE_LEVEL_INFO = 1,
-    GTK_PRINTER_STATE_LEVEL_WARNING = 2,
-    GTK_PRINTER_STATE_LEVEL_ERROR = 3
-  } PrinterStateLevel;
-
-typedef struct
-{
-  const gchar *printer_name;
-  const gchar *printer_uri;
-  const gchar *member_uris;
-  const gchar *location;
-  const gchar *description;
-  gchar *state_msg;
-  const gchar *reason_msg;
-  PrinterStateLevel reason_level;
-  gint state;
-  gint job_count;
-  gboolean is_paused;
-  gboolean is_accepting_jobs;
-  const gchar *default_cover_before;
-  const gchar *default_cover_after;
-  gboolean default_printer;
-  gboolean got_printer_type;
-  gboolean remote_printer;
-#ifdef HAVE_CUPS_API_1_6
-  gboolean avahi_printer;
-#endif
-  gchar  **auth_info_required;
-  guchar   ipp_version_major;
-  guchar   ipp_version_minor;
-  gboolean supports_copies;
-  gboolean supports_collate;
-  gboolean supports_number_up;
-} PrinterSetupInfo;
-
-static void
-get_ipp_version (const char *ipp_version_string,
-                 guchar     *ipp_version_major,
-                 guchar     *ipp_version_minor)
-{
-  gchar **ipp_version_strv;
-  gchar  *endptr;
-
-  *ipp_version_major = 1;
-  *ipp_version_minor = 1;
-
-  if (ipp_version_string)
-    {
-      ipp_version_strv = g_strsplit (ipp_version_string, ".", 0);
-
-      if (ipp_version_strv)
-        {
-          if (g_strv_length (ipp_version_strv) == 2)
-            {
-              *ipp_version_major = (guchar) g_ascii_strtoull (ipp_version_strv[0], &endptr, 10);
-              if (endptr == ipp_version_strv[0])
-                *ipp_version_major = 1;
-
-              *ipp_version_minor = (guchar) g_ascii_strtoull (ipp_version_strv[1], &endptr, 10);
-              if (endptr == ipp_version_strv[1])
-                *ipp_version_minor = 1;
-            }
-
-          g_strfreev (ipp_version_strv);
-        }
-    }
-}
-
-static void
-get_server_ipp_version (guchar *ipp_version_major,
-                        guchar *ipp_version_minor)
-{
-  *ipp_version_major = 1;
-  *ipp_version_minor = 1;
-
-  if (IPP_VERSION && strlen (IPP_VERSION) == 2)
-    {
-      *ipp_version_major = (unsigned char) IPP_VERSION[0];
-      *ipp_version_minor = (unsigned char) IPP_VERSION[1];
-    }
-}
-
-static gint
-ipp_version_cmp (guchar ipp_version_major1,
-                 guchar ipp_version_minor1,
-                 guchar ipp_version_major2,
-                 guchar ipp_version_minor2)
-{
-  if (ipp_version_major1 == ipp_version_major2 &&
-      ipp_version_minor1 == ipp_version_minor2)
-    {
-      return 0;
-    }
-  else if (ipp_version_major1 < ipp_version_major2 ||
-           (ipp_version_major1 == ipp_version_major2 &&
-            ipp_version_minor1 < ipp_version_minor2))
-    {
-      return -1;
-    }
-  else
-    {
-      return 1;
-    }
-}
-
-static void
-cups_printer_handle_attribute (GtkPrintBackendCups *cups_backend,
-			       ipp_attribute_t *attr,
-			       PrinterSetupInfo *info)
-{
-  gint i,j;
-
-  if (strcmp (ippGetName (attr), "printer-name") == 0 &&
-      ippGetValueTag (attr) == IPP_TAG_NAME)
-    info->printer_name = ippGetString (attr, 0, NULL);
-  else if (strcmp (ippGetName (attr), "printer-uri-supported") == 0 &&
-	   ippGetValueTag (attr) == IPP_TAG_URI)
-    info->printer_uri = ippGetString (attr, 0, NULL);
-  else if (strcmp (ippGetName (attr), "member-uris") == 0 &&
-	   ippGetValueTag (attr) == IPP_TAG_URI)
-    info->member_uris = ippGetString (attr, 0, NULL);
-  else if (strcmp (ippGetName (attr), "printer-location") == 0)
-    info->location = ippGetString (attr, 0, NULL);
-  else if (strcmp (ippGetName (attr), "printer-info") == 0)
-    info->description = ippGetString (attr, 0, NULL);
-  else if (strcmp (ippGetName (attr), "printer-state-message") == 0)
-    info->state_msg = g_strdup (ippGetString (attr, 0, NULL));
-  else if (strcmp (ippGetName (attr), "printer-state-reasons") == 0)
-    /* Store most important reason to reason_msg and set
-       its importance at printer_state_reason_level */
-    {
-      for (i = 0; i < ippGetCount (attr); i++)
-	{
-	  gboolean interested_in = FALSE;
-	  if (strcmp (ippGetString (attr, i, NULL), "none") == 0)
-	    continue;
-	  /* Sets is_paused flag for paused printer. */
-	  if (strcmp (ippGetString (attr, i, NULL), "paused") == 0)
-	    {
-	      info->is_paused = TRUE;
-	    }
-
-	  for (j = 0; j < G_N_ELEMENTS (printer_messages); j++)
-	    if (strncmp (ippGetString (attr, i, NULL), printer_messages[j], strlen (printer_messages[j])) == 0)
-	      {
-		interested_in = TRUE;
-		break;
-	      }
-
-	  if (!interested_in)
-	    continue;
-	  if (g_str_has_suffix (ippGetString (attr, i, NULL), "-report"))
-	    {
-	      if (info->reason_level <= GTK_PRINTER_STATE_LEVEL_INFO)
-		{
-		  info->reason_msg = ippGetString (attr, i, NULL);
-		  info->reason_level = GTK_PRINTER_STATE_LEVEL_INFO;
-		}
-	    }
-	  else if (g_str_has_suffix (ippGetString (attr, i, NULL), "-warning"))
-	    {
-	      if (info->reason_level <= GTK_PRINTER_STATE_LEVEL_WARNING)
-		{
-		  info->reason_msg = ippGetString (attr, i, NULL);
-		  info->reason_level = GTK_PRINTER_STATE_LEVEL_WARNING;
-		}
-	    }
-	  else  /* It is error in the case of no suffix. */
-	    {
-	      info->reason_msg = ippGetString (attr, i, NULL);
-	      info->reason_level = GTK_PRINTER_STATE_LEVEL_ERROR;
-	    }
-	}
-    }
-  else if (strcmp (ippGetName (attr), "printer-state") == 0)
-    info->state = ippGetInteger (attr, 0);
-  else if (strcmp (ippGetName (attr), "queued-job-count") == 0)
-    info->job_count = ippGetInteger (attr, 0);
-  else if (strcmp (ippGetName (attr), "printer-is-accepting-jobs") == 0)
-    {
-      if (ippGetBoolean (attr, 0) == 1)
-	info->is_accepting_jobs = TRUE;
-      else
-	info->is_accepting_jobs = FALSE;
-    }
-  else if (strcmp (ippGetName (attr), "job-sheets-supported") == 0)
-    {
-      if (cups_backend->covers == NULL)
-	{
-	  cups_backend->number_of_covers = ippGetCount (attr);
-	  cups_backend->covers = g_new (char *, cups_backend->number_of_covers + 1);
-	  for (i = 0; i < cups_backend->number_of_covers; i++)
-	    cups_backend->covers[i] = g_strdup (ippGetString (attr, i, NULL));
-	  cups_backend->covers[cups_backend->number_of_covers] = NULL;
-	}
-    }
-  else if (strcmp (ippGetName (attr), "job-sheets-default") == 0)
-    {
-      if (ippGetCount (attr) == 2)
-	{
-	  info->default_cover_before = ippGetString (attr, 0, NULL);
-	  info->default_cover_after = ippGetString (attr, 1, NULL);
-	}
-    }
-  else if (strcmp (ippGetName (attr), "printer-type") == 0)
-    {
-      info->got_printer_type = TRUE;
-      if (ippGetInteger (attr, 0) & 0x00020000)
-	info->default_printer = TRUE;
-      else
-	info->default_printer = FALSE;
-
-      if (ippGetInteger (attr, 0) & 0x00000002)
-	info->remote_printer = TRUE;
-      else
-	info->remote_printer = FALSE;
-    }
-  else if (strcmp (ippGetName (attr), "auth-info-required") == 0)
-    {
-      if (strcmp (ippGetString (attr, 0, NULL), "none") != 0)
-	{
-	  info->auth_info_required = g_new0 (gchar *, ippGetCount (attr) + 1);
-	  for (i = 0; i < ippGetCount (attr); i++)
-	    info->auth_info_required[i] = g_strdup (ippGetString (attr, i, NULL));
-	}
-    }
-  else if (g_strcmp0 (ippGetName (attr), "ipp-versions-supported") == 0)
-    {
-      guchar server_ipp_version_major;
-      guchar server_ipp_version_minor;
-      guchar ipp_version_major;
-      guchar ipp_version_minor;
-
-      get_server_ipp_version (&server_ipp_version_major,
-                              &server_ipp_version_minor);
-
-      for (i = 0; i < ippGetCount (attr); i++)
-        {
-          get_ipp_version (ippGetString (attr, i, NULL),
-                           &ipp_version_major,
-                           &ipp_version_minor);
-
-          if (ipp_version_cmp (ipp_version_major,
-                               ipp_version_minor,
-                               info->ipp_version_major,
-                               info->ipp_version_minor) > 0 &&
-              ipp_version_cmp (ipp_version_major,
-                               ipp_version_minor,
-                               server_ipp_version_major,
-                               server_ipp_version_minor) <= 0)
-            {
-              info->ipp_version_major = ipp_version_major;
-              info->ipp_version_minor = ipp_version_minor;
-            }
-        }
-    }
-  else if (g_strcmp0 (ippGetName (attr), "number-up-supported") == 0)
-    {
-      if (ippGetCount (attr) == 6)
-        {
-          info->supports_number_up = TRUE;
-        }
-    }
-  else if (g_strcmp0 (ippGetName (attr), "copies-supported") == 0)
-    {
-      int upper = 1;
-
-      ippGetRange (attr, 0, &upper);
-      if (upper > 1)
-        {
-          info->supports_copies = TRUE;
-        }
-    }
-  else if (g_strcmp0 (ippGetName (attr), "multiple-document-handling-supported") == 0)
-    {
-      for (i = 0; i < ippGetCount (attr); i++)
-        {
-          if (g_strcmp0 (ippGetString (attr, i, NULL), "separate-documents-collated-copies") == 0)
-            {
-              info->supports_collate = TRUE;
-            }
-        }
-    }
-  else
-    {
-      GTK_NOTE (PRINTING,
-		g_print ("CUPS Backend: Attribute %s ignored\n", ippGetName (attr)));
-    }
-
-}
-
-static GtkPrinter*
-cups_create_printer (GtkPrintBackendCups *cups_backend,
-		     PrinterSetupInfo *info)
-{
-  GtkPrinterCups *cups_printer;
-  GtkPrinter *printer;
-  char uri[HTTP_MAX_URI];	/* Printer URI */
-  char method[HTTP_MAX_URI];	/* Method/scheme name */
-  char username[HTTP_MAX_URI];	/* Username:password */
-  char hostname[HTTP_MAX_URI];	/* Hostname */
-  char resource[HTTP_MAX_URI];	/* Resource name */
-  int  port;			/* Port number */
-  char *cups_server;            /* CUPS server */
-  GtkPrintBackend *backend = GTK_PRINT_BACKEND (cups_backend);
-
-  cups_printer = gtk_printer_cups_new (info->printer_name, backend);
-
-  cups_printer->device_uri = g_strdup_printf ("/printers/%s",
-					      info->printer_name);
-
-  /* Check to see if we are looking at a class */
-  if (info->member_uris)
-    {
-      cups_printer->printer_uri = g_strdup (info->member_uris);
-      /* TODO if member_uris is a class we need to recursivly find a printer */
-      GTK_NOTE (PRINTING,
-		g_print ("CUPS Backend: Found class with printer %s\n",
-			 info->member_uris));
-    }
-  else
-    {
-      cups_printer->printer_uri = g_strdup (info->printer_uri);
-      GTK_NOTE (PRINTING,
-		g_print ("CUPS Backend: Found printer %s\n", info->printer_uri));
-    }
-
-#ifdef HAVE_CUPS_API_1_2
-  httpSeparateURI (HTTP_URI_CODING_ALL, cups_printer->printer_uri, 
-		   method, sizeof (method), 
-		   username, sizeof (username),
-		   hostname, sizeof (hostname),
-		   &port, 
-		   resource, sizeof (resource));
-
-#else
-  httpSeparate (cups_printer->printer_uri, 
-		method, 
-		username, 
-		hostname,
-		&port, 
-		resource);
-#endif
-
-  if (strncmp (resource, "/printers/", 10) == 0)
-    {
-      cups_printer->ppd_name = g_strdup (resource + 10);
-      GTK_NOTE (PRINTING,
-		g_print ("CUPS Backend: Setting ppd name '%s' for printer/class '%s'\n", cups_printer->ppd_name, info->printer_name));
-    }
-
-  gethostname (uri, sizeof (uri));
-  cups_server = g_strdup (cupsServer());
-
-  if (strcasecmp (uri, hostname) == 0)
-    strcpy (hostname, "localhost");
-
-  /* if the cups server is local and listening at a unix domain socket 
-   * then use the socket connection
-   */
-  if ((strstr (hostname, "localhost") != NULL) &&
-      (cups_server[0] == '/'))
-    strcpy (hostname, cups_server);
-
-  g_free (cups_server);
-
-  cups_printer->default_cover_before = g_strdup (info->default_cover_before);
-  cups_printer->default_cover_after = g_strdup (info->default_cover_after);
-
-  cups_printer->hostname = g_strdup (hostname);
-  cups_printer->port = port;
-
-  cups_printer->auth_info_required = g_strdupv (info->auth_info_required);
-  g_strfreev (info->auth_info_required);
-
-  printer = GTK_PRINTER (cups_printer);
-
-  if (cups_backend->default_printer != NULL &&
-      strcmp (cups_backend->default_printer, gtk_printer_get_name (printer)) == 0)
-    gtk_printer_set_is_default (printer, TRUE);
-
-#ifdef HAVE_CUPS_API_1_6
-  cups_printer->avahi_browsed = info->avahi_printer;
-#endif
-
-  gtk_print_backend_add_printer (backend, printer);
-  return printer;
-}
-
-static void
-set_printer_icon_name_from_info (GtkPrinter       *printer,
-                                 PrinterSetupInfo *info)
-{
-  /* Set printer icon according to importance
-     (none, report, warning, error - report is omitted). */
-  if (info->reason_level == GTK_PRINTER_STATE_LEVEL_ERROR)
-    gtk_printer_set_icon_name (printer, "printer-error");
-  else if (info->reason_level == GTK_PRINTER_STATE_LEVEL_WARNING)
-    gtk_printer_set_icon_name (printer, "printer-warning");
-  else if (gtk_printer_is_paused (printer))
-    gtk_printer_set_icon_name (printer, "printer-paused");
-  else
-    gtk_printer_set_icon_name (printer, "printer");
-}
-
-static void
-set_info_state_message (PrinterSetupInfo *info)
-{
-  gint i;
-
-  if (info->state_msg && strlen (info->state_msg) == 0)
-    {
-      gchar *tmp_msg2 = NULL;
-      if (info->is_paused && !info->is_accepting_jobs)
-        /* Translators: this is a printer status. */
-        tmp_msg2 = g_strdup ( _("Paused; Rejecting Jobs"));
-      if (info->is_paused && info->is_accepting_jobs)
-        /* Translators: this is a printer status. */
-        tmp_msg2 = g_strdup ( _("Paused"));
-      if (!info->is_paused && !info->is_accepting_jobs)
-        /* Translators: this is a printer status. */
-        tmp_msg2 = g_strdup ( _("Rejecting Jobs"));
-
-      if (tmp_msg2 != NULL)
-        {
-          g_free (info->state_msg);
-          info->state_msg = tmp_msg2;
-        }
-    }
-
-  /* Set description of the reason and combine it with printer-state-message. */
-  if (info->reason_msg)
-    {
-      gchar *reason_msg_desc = NULL;
-      gboolean found = FALSE;
-
-      for (i = 0; i < G_N_ELEMENTS (printer_messages); i++)
-        {
-          if (strncmp (info->reason_msg, printer_messages[i],
-                       strlen (printer_messages[i])) == 0)
-            {
-              reason_msg_desc = g_strdup_printf (printer_strings[i],
-                                                 info->printer_name);
-              found = TRUE;
-              break;
-            }
-        }
-
-      if (!found)
-        info->reason_level = GTK_PRINTER_STATE_LEVEL_NONE;
-
-      if (info->reason_level >= GTK_PRINTER_STATE_LEVEL_WARNING)
-        {
-          if (info->state_msg == NULL || info->state_msg[0] == '\0')
-            {
-              g_free (info->state_msg);
-              info->state_msg = reason_msg_desc;
-              reason_msg_desc = NULL;
-            }
-          else
-            {
-              gchar *tmp_msg = NULL;
-              /* Translators: this string connects multiple printer states together. */
-              tmp_msg = g_strjoin ( _("; "), info->state_msg,
-                                   reason_msg_desc, NULL);
-              g_free (info->state_msg);
-              info->state_msg = tmp_msg;
-            }
-        }
-
-      g_free (reason_msg_desc);
-    }
-}
-
-static void
-set_default_printer (GtkPrintBackendCups *cups_backend,
-                     const gchar         *default_printer_name)
-{
-  cups_backend->default_printer = g_strdup (default_printer_name);
-  cups_backend->got_default_printer = TRUE;
-
-  if (cups_backend->default_printer != NULL)
-    {
-      GtkPrinter *default_printer = NULL;
-      default_printer = gtk_print_backend_find_printer (GTK_PRINT_BACKEND (cups_backend),
-                                                        cups_backend->default_printer);
-      if (default_printer != NULL)
-        {
-          gtk_printer_set_is_default (default_printer, TRUE);
-          g_signal_emit_by_name (GTK_PRINT_BACKEND (cups_backend),
-                                 "printer-status-changed", default_printer);
-        }
-    }
-}
-
-#ifdef HAVE_CUPS_API_1_6
-typedef struct
-{
-  gchar *name;
-  gchar *type;
-  gchar *domain;
-  gchar *host;
-  gint   port;
-} AvahiService;
-
-void
-avahi_service_free (AvahiService *service)
-{
-  if (service)
-    {
-      g_free (service->name);
-      g_free (service->type);
-      g_free (service->domain);
-      g_free (service->host);
-      g_free (service);
-    }
-}
-
-static void
-cups_request_avahi_printer_info_cb (GtkPrintBackendCups *cups_backend,
-                                    GtkCupsResult       *result,
-                                    gpointer             user_data)
-{
-  PrinterSetupInfo *info = g_slice_new0 (PrinterSetupInfo);
-  GtkPrintBackend  *backend = GTK_PRINT_BACKEND (cups_backend);
-  ipp_attribute_t  *attr;
-  AvahiService     *service = (AvahiService *) user_data;
-  GtkPrinter       *printer;
-  gboolean          list_has_changed = FALSE;
-  gboolean          status_changed = FALSE;
-  ipp_t            *response;
-
-  gdk_threads_enter ();
-
-  GTK_NOTE (PRINTING,
-            g_print ("CUPS Backend: %s\n", G_STRFUNC));
-
-  if (gtk_cups_result_is_error (result))
-    {
-      GTK_NOTE (PRINTING,
-                g_warning ("CUPS Backend: Error getting printer info: %s %d %d",
-                           gtk_cups_result_get_error_string (result),
-                           gtk_cups_result_get_error_type (result),
-                           gtk_cups_result_get_error_code (result)));
-
-      goto done;
-    }
-
-  response = gtk_cups_result_get_response (result);
-  attr = ippFirstAttribute (response);
-  while (attr && ippGetGroupTag (attr) != IPP_TAG_PRINTER)
-    attr = ippNextAttribute (response);
-
-  if (attr)
-    {
-      while (attr && ippGetGroupTag (attr) == IPP_TAG_PRINTER)
-        {
-          cups_printer_handle_attribute (cups_backend, attr, info);
-          attr = ippNextAttribute (response);
-        }
-
-      if (info->printer_name && info->printer_uri)
-        {
-          info->avahi_printer = TRUE;
-
-          if (info->got_printer_type &&
-              info->default_printer &&
-              cups_backend->avahi_default_printer == NULL)
-            cups_backend->avahi_default_printer = g_strdup (info->printer_name);
-
-          set_info_state_message (info);
-
-          printer = gtk_print_backend_find_printer (backend, info->printer_name);
-          if (!printer)
-            {
-              printer = cups_create_printer (cups_backend, info);
-              list_has_changed = TRUE;
-            }
-          else
-            {
-              g_object_ref (printer);
-            }
-
-          gtk_printer_set_is_paused (printer, info->is_paused);
-          gtk_printer_set_is_accepting_jobs (printer, info->is_accepting_jobs);
-
-          if (!gtk_printer_is_active (printer))
-            {
-              gtk_printer_set_is_active (printer, TRUE);
-              gtk_printer_set_is_new (printer, TRUE);
-              list_has_changed = TRUE;
-            }
-
-          GTK_PRINTER_CUPS (printer)->remote = info->remote_printer;
-          GTK_PRINTER_CUPS (printer)->avahi_name = g_strdup (service->name);
-          GTK_PRINTER_CUPS (printer)->avahi_type = g_strdup (service->type);
-          GTK_PRINTER_CUPS (printer)->avahi_domain = g_strdup (service->domain);
-          GTK_PRINTER_CUPS (printer)->hostname = g_strdup (service->host);
-          GTK_PRINTER_CUPS (printer)->port = service->port;
-          GTK_PRINTER_CUPS (printer)->state = info->state;
-          GTK_PRINTER_CUPS (printer)->ipp_version_major = info->ipp_version_major;
-          GTK_PRINTER_CUPS (printer)->ipp_version_minor = info->ipp_version_minor;
-          GTK_PRINTER_CUPS (printer)->supports_copies = info->supports_copies;
-          GTK_PRINTER_CUPS (printer)->supports_collate = info->supports_collate;
-          GTK_PRINTER_CUPS (printer)->supports_number_up = info->supports_number_up;
-          status_changed = gtk_printer_set_job_count (printer, info->job_count);
-          status_changed |= gtk_printer_set_location (printer, info->location);
-          status_changed |= gtk_printer_set_description (printer, info->description);
-          status_changed |= gtk_printer_set_state_message (printer, info->state_msg);
-          status_changed |= gtk_printer_set_is_accepting_jobs (printer, info->is_accepting_jobs);
-
-          set_printer_icon_name_from_info (printer, info);
-
-          if (gtk_printer_is_new (printer))
-            {
-              g_signal_emit_by_name (backend, "printer-added", printer);
-              gtk_printer_set_is_new (printer, FALSE);
-            }
-
-          if (status_changed)
-            g_signal_emit_by_name (GTK_PRINT_BACKEND (backend),
-                                   "printer-status-changed", printer);
-
-          /* The ref is held by GtkPrintBackend, in add_printer() */
-          g_object_unref (printer);
-        }
-    }
-
-done:
-  if (list_has_changed)
-    g_signal_emit_by_name (backend, "printer-list-changed");
-
-  if (!cups_backend->got_default_printer &&
-      gtk_print_backend_printer_list_is_done (backend) &&
-      cups_backend->avahi_default_printer != NULL)
-    {
-      set_default_printer (cups_backend, cups_backend->avahi_default_printer);
-    }
-
-  g_slice_free (PrinterSetupInfo, info);
-
-  gdk_threads_leave ();
-}
-
-static void
-cups_request_avahi_printer_info (const gchar         *printer_uri,
-                                 const gchar         *host,
-                                 gint                 port,
-                                 const gchar         *name,
-                                 const gchar         *type,
-                                 const gchar         *domain,
-                                 GtkPrintBackendCups *backend)
-{
-  GtkCupsRequest *request;
-  AvahiService   *service;
-  http_t         *http;
-
-  http = httpConnect (host, port);
-  if (http)
-    {
-      service = (AvahiService *) g_new0 (AvahiService, 1);
-      service->name = g_strdup (name);
-      service->type = g_strdup (type);
-      service->domain = g_strdup (domain);
-      service->host = g_strdup (host);
-      service->port = port;
-
-      request = gtk_cups_request_new_with_username (http,
-                                                    GTK_CUPS_POST,
-                                                    IPP_GET_PRINTER_ATTRIBUTES,
-                                                    NULL,
-                                                    NULL,
-                                                    NULL,
-                                                    backend->username);
-
-      gtk_cups_request_set_ipp_version (request, 1, 1);
-
-      gtk_cups_request_ipp_add_string (request, IPP_TAG_OPERATION, IPP_TAG_URI,
-                                       "printer-uri", NULL, printer_uri);
-
-      gtk_cups_request_ipp_add_strings (request, IPP_TAG_OPERATION, IPP_TAG_KEYWORD,
-                                        "requested-attributes", G_N_ELEMENTS (printer_attrs),
-                                        NULL, printer_attrs);
-
-      cups_request_execute (backend,
-                            request,
-                            (GtkPrintCupsResponseCallbackFunc) cups_request_avahi_printer_info_cb,
-                            service,
-                            (GDestroyNotify) avahi_service_free);
-    }
-}
-
-typedef struct
-{
-  gchar               *printer_uri;
-  gchar               *host;
-  gint                 port;
-  gchar               *name;
-  gchar               *type;
-  gchar               *domain;
-  GtkPrintBackendCups *backend;
-} AvahiConnectionTestData;
-
-static void
-avahi_connection_test_cb (GObject      *source_object,
-                          GAsyncResult *res,
-                          gpointer      user_data)
-{
-  AvahiConnectionTestData *data = (AvahiConnectionTestData *) user_data;
-  GSocketConnection       *connection;
-
-  connection = g_socket_client_connect_to_host_finish (G_SOCKET_CLIENT (source_object),
-                                                       res,
-                                                       NULL);
-  g_object_unref (source_object);
-
-  if (connection != NULL)
-    {
-      g_io_stream_close (G_IO_STREAM (connection), NULL, NULL);
-      g_object_unref (connection);
-
-      cups_request_avahi_printer_info (data->printer_uri,
-                                       data->host,
-                                       data->port,
-                                       data->name,
-                                       data->type,
-                                       data->domain,
-                                       data->backend);
-    }
-
-  g_free (data->printer_uri);
-  g_free (data->host);
-  g_free (data->name);
-  g_free (data->type);
-  g_free (data->domain);
-  g_free (data);
-}
-
-static void
-avahi_service_resolver_cb (GObject      *source_object,
-                           GAsyncResult *res,
-                           gpointer      user_data)
-{
-}
-
-static void
-avahi_service_browser_signal_handler (void *connection,
-                                      const gchar     *sender_name,
-                                      const gchar     *object_path,
-                                      const gchar     *interface_name,
-                                      const gchar     *signal_name,
-                                      GVariant        *parameters,
-                                      gpointer         user_data)
-{
-}
-
-static void
-avahi_service_browser_new_cb (GObject      *source_object,
-                              GAsyncResult *res,
-                              gpointer      user_data)
-{
-}
-
-static void
-avahi_create_browsers (GObject      *source_object,
-                       GAsyncResult *res,
-                       gpointer      user_data)
-{
-}
-
-static void
-avahi_request_printer_list (GtkPrintBackendCups *cups_backend)
-{
-  cups_backend->avahi_cancellable = g_cancellable_new ();
-}
-#endif
-
-static void
-cups_request_printer_list_cb (GtkPrintBackendCups *cups_backend,
-                              GtkCupsResult       *result,
-                              gpointer             user_data)
-{
-  GtkPrintBackend *backend = GTK_PRINT_BACKEND (cups_backend);
-  ipp_attribute_t *attr;
-  ipp_t *response;
-  gboolean list_has_changed;
-  GList *removed_printer_checklist;
-  gchar *remote_default_printer = NULL;
-  GList *iter;
-
-  GDK_THREADS_ENTER ();
-
-  list_has_changed = FALSE;
-
-  GTK_NOTE (PRINTING,
-            g_print ("CUPS Backend: %s\n", G_STRFUNC));
-
-  cups_backend->list_printers_pending = FALSE;
-
-  if (gtk_cups_result_is_error (result))
-    {
-      GTK_NOTE (PRINTING, 
-                g_warning ("CUPS Backend: Error getting printer list: %s %d %d", 
-                           gtk_cups_result_get_error_string (result),
-                           gtk_cups_result_get_error_type (result),
-                           gtk_cups_result_get_error_code (result)));
-
-      if (gtk_cups_result_get_error_type (result) == GTK_CUPS_ERROR_AUTH &&
-          gtk_cups_result_get_error_code (result) == 1)
-        {
-          /* Canceled by user, stop popping up more password dialogs */
-          if (cups_backend->list_printers_poll > 0)
-            g_source_remove (cups_backend->list_printers_poll);
-          cups_backend->list_printers_poll = 0;
-          cups_backend->list_printers_attempts = 0;
-        }
-
-      goto done;
-    }
-  
-  /* Gather the names of the printers in the current queue
-   * so we may check to see if they were removed 
-   */
-  removed_printer_checklist = gtk_print_backend_get_printer_list (backend);
-								  
-  response = gtk_cups_result_get_response (result);
-#ifdef HAVE_CUPS_API_1_6
-  for (attr = ippFirstAttribute (response); attr != NULL;
-       attr = ippNextAttribute (response))
-    {
-      GtkPrinter *printer;
-      gboolean status_changed = FALSE;
-      GList *node;
-      PrinterSetupInfo *info = g_slice_new0 (PrinterSetupInfo);
-
-      /* Skip leading attributes until we hit a printer...
-       */
-      while (attr != NULL && ippGetGroupTag (attr) != IPP_TAG_PRINTER)
-        attr = ippNextAttribute (response);
-
-      if (attr == NULL)
-        break;
-      while (attr != NULL && ippGetGroupTag (attr) == IPP_TAG_PRINTER)
-      {
-	cups_printer_handle_attribute (cups_backend, attr, info);
-        attr = ippNextAttribute (response);
-      }
-#else
-  for (attr = response->attrs; attr != NULL; attr = attr->next)
-    {
-      GtkPrinter *printer;
-      gboolean status_changed = FALSE;
-      GList *node;
-      PrinterSetupInfo *info = g_slice_new0 (PrinterSetupInfo);
-
-      /* Skip leading attributes until we hit a printer...
-       */
-      while (attr != NULL && ippGetGroupTag (attr) != IPP_TAG_PRINTER)
-        attr = attr->next;
-
-      if (attr == NULL)
-        break;
-      while (attr != NULL && ippGetGroupTag (attr) == IPP_TAG_PRINTER)
-      {
-	cups_printer_handle_attribute (cups_backend, attr, info);
-        attr = attr->next;
-      }
-#endif
-
-      if (info->printer_name == NULL ||
-	  (info->printer_uri == NULL && info->member_uris == NULL))
-      {
-        if (attr == NULL)
-	  break;
-	else
-          continue;
-      }
-
-      if (info->got_printer_type)
-        {
-          if (info->default_printer && !cups_backend->got_default_printer)
-            {
-              if (!info->remote_printer)
-                {
-                  cups_backend->got_default_printer = TRUE;
-                  cups_backend->default_printer = g_strdup (info->printer_name);
-                }
-              else
-                {
-                  if (remote_default_printer == NULL)
-                    remote_default_printer = g_strdup (info->printer_name);
-                }
-            }
-        }
-      else
-        {
-          if (!cups_backend->got_default_printer)
-            cups_get_default_printer (cups_backend);
-        }
-
-      /* remove name from checklist if it was found */
-      node = g_list_find_custom (removed_printer_checklist,
-				 info->printer_name,
-				 (GCompareFunc) find_printer);
-      removed_printer_checklist = g_list_delete_link (removed_printer_checklist,
-						      node);
- 
-      printer = gtk_print_backend_find_printer (backend, info->printer_name);
-      if (!printer)
-        {
-	  printer = cups_create_printer (cups_backend, info);
- 	  list_has_changed = TRUE;
-        }
-      else
-	g_object_ref (printer);
-
-      GTK_PRINTER_CUPS (printer)->remote = info->remote_printer;
-
-      gtk_printer_set_is_paused (printer, info->is_paused);
-      gtk_printer_set_is_accepting_jobs (printer, info->is_accepting_jobs);
-
-      if (!gtk_printer_is_active (printer))
-        {
-	  gtk_printer_set_is_active (printer, TRUE);
-	  gtk_printer_set_is_new (printer, TRUE);
-          list_has_changed = TRUE;
-        }
-
-      if (gtk_printer_is_new (printer))
-        {
-	  g_signal_emit_by_name (backend, "printer-added", printer);
-
-	  gtk_printer_set_is_new (printer, FALSE);
-        }
-
-#if 0
-      /* Getting printer info with separate requests overwhelms cups
-       * when the printer list has more than a handful of printers.
-       */
-      cups_request_printer_info (cups_backend, gtk_printer_get_name (printer));
-#endif
-
-      GTK_PRINTER_CUPS (printer)->state = info->state;
-      GTK_PRINTER_CUPS (printer)->ipp_version_major = info->ipp_version_major;
-      GTK_PRINTER_CUPS (printer)->ipp_version_minor = info->ipp_version_minor;
-      GTK_PRINTER_CUPS (printer)->supports_copies = info->supports_copies;
-      GTK_PRINTER_CUPS (printer)->supports_collate = info->supports_collate;
-      GTK_PRINTER_CUPS (printer)->supports_number_up = info->supports_number_up;
-      status_changed = gtk_printer_set_job_count (printer, info->job_count);
-      status_changed |= gtk_printer_set_location (printer, info->location);
-      status_changed |= gtk_printer_set_description (printer,
-						     info->description);
-
-      set_info_state_message (info);
-
-      status_changed |= gtk_printer_set_state_message (printer, info->state_msg);
-      status_changed |= gtk_printer_set_is_accepting_jobs (printer, info->is_accepting_jobs);
-
-      set_printer_icon_name_from_info (printer, info);
-
-      if (status_changed)
-        g_signal_emit_by_name (GTK_PRINT_BACKEND (backend),
-                               "printer-status-changed", printer);
-
-      /* The ref is held by GtkPrintBackend, in add_printer() */
-      g_object_unref (printer);
-      g_free (info->state_msg);
-      g_slice_free (PrinterSetupInfo, info);
-
-      if (attr == NULL)
-        break;
-    }
-
-  /* look at the removed printers checklist and mark any printer
-     as inactive if it is in the list, emitting a printer_removed signal */
-  if (removed_printer_checklist != NULL)
-    {
-      for (iter = removed_printer_checklist; iter; iter = iter->next)
-        {
-#ifdef HAVE_CUPS_API_1_6
-          if (!GTK_PRINTER_CUPS (iter->data)->avahi_browsed)
-#endif
-            {
-              mark_printer_inactive (GTK_PRINTER (iter->data), backend);
-              list_has_changed = TRUE;
-            }
-        }
-
-      g_list_free (removed_printer_checklist);
-    }
-  
-done:
-  if (list_has_changed)
-    g_signal_emit_by_name (backend, "printer-list-changed");
-  
-  gtk_print_backend_set_list_done (backend);
-
-  if (!cups_backend->got_default_printer && remote_default_printer != NULL)
-    {
-      set_default_printer (cups_backend, remote_default_printer);
-      g_free (remote_default_printer);
-    }
-
-#ifdef HAVE_CUPS_API_1_6
-  if (!cups_backend->got_default_printer && cups_backend->avahi_default_printer != NULL)
-    {
-      set_default_printer (cups_backend, cups_backend->avahi_default_printer);
-    }
-#endif
-
-  GDK_THREADS_LEAVE ();
-}
-
-static void
-update_backend_status (GtkPrintBackendCups    *cups_backend,
-                       GtkCupsConnectionState  state)
-{
-  switch (state)
-    {
-    case GTK_CUPS_CONNECTION_NOT_AVAILABLE:
-      g_object_set (cups_backend, "status", GTK_PRINT_BACKEND_STATUS_UNAVAILABLE, NULL);
-      break;
-    case GTK_CUPS_CONNECTION_AVAILABLE:
-      g_object_set (cups_backend, "status", GTK_PRINT_BACKEND_STATUS_OK, NULL);
-      break;
-    default: ;
-    }
-}
-
-static gboolean
-cups_request_printer_list (GtkPrintBackendCups *cups_backend)
-{
-  GtkCupsConnectionState state;
-  GtkCupsRequest *request;
-
-  if (cups_backend->reading_ppds > 0 || cups_backend->list_printers_pending)
-    return TRUE;
-
-  state = gtk_cups_connection_test_get_state (cups_backend->cups_connection_test);
-  update_backend_status (cups_backend, state);
-
-  if (cups_backend->list_printers_attempts == 60)
-    {
-      cups_backend->list_printers_attempts = -1;
-      if (cups_backend->list_printers_poll > 0)
-        g_source_remove (cups_backend->list_printers_poll);
-      cups_backend->list_printers_poll = gdk_threads_add_timeout (200,
-                                           (GSourceFunc) cups_request_printer_list,
-                                           cups_backend);
-    }
-  else if (cups_backend->list_printers_attempts != -1)
-    cups_backend->list_printers_attempts++;
-
-  if (state == GTK_CUPS_CONNECTION_IN_PROGRESS || state == GTK_CUPS_CONNECTION_NOT_AVAILABLE)
-    return TRUE;
-  else
-    if (cups_backend->list_printers_attempts > 0)
-      cups_backend->list_printers_attempts = 60;
-
-  cups_backend->list_printers_pending = TRUE;
-
-  request = gtk_cups_request_new_with_username (NULL,
-                                                GTK_CUPS_POST,
-                                                CUPS_GET_PRINTERS,
-                                                NULL,
-                                                NULL,
-                                                NULL,
-                                                cups_backend->username);
-
-  gtk_cups_request_ipp_add_strings (request, IPP_TAG_OPERATION, IPP_TAG_KEYWORD,
-				    "requested-attributes", G_N_ELEMENTS (printer_attrs),
-				    NULL, printer_attrs);
-
-  cups_request_execute (cups_backend,
-                        request,
-                        (GtkPrintCupsResponseCallbackFunc) cups_request_printer_list_cb,
-		        request,
-		        NULL);
-
-  return TRUE;
-}
-
-static void
-cups_get_printer_list (GtkPrintBackend *backend)
-{
-  GtkPrintBackendCups *cups_backend;
-
-  cups_backend = GTK_PRINT_BACKEND_CUPS (backend);
-
-  if (cups_backend->cups_connection_test == NULL)
-    cups_backend->cups_connection_test = gtk_cups_connection_test_new (NULL, -1);
-
-  if (cups_backend->list_printers_poll == 0)
-    {
-      if (cups_request_printer_list (cups_backend))
-        cups_backend->list_printers_poll = gdk_threads_add_timeout (50,
-                                             (GSourceFunc) cups_request_printer_list,
-                                             backend);
-
-#ifdef HAVE_CUPS_API_1_6
-      avahi_request_printer_list (cups_backend);
-#endif
-    }
-}
-
-typedef struct {
-  GtkPrinterCups *printer;
-  GIOChannel *ppd_io;
-  http_t *http;
-} GetPPDData;
-
-static void
-get_ppd_data_free (GetPPDData *data)
-{
-  GTK_NOTE (PRINTING,
-            g_print ("CUPS Backend: %s\n", G_STRFUNC));
-  httpClose (data->http);
-  g_io_channel_unref (data->ppd_io);
-  g_object_unref (data->printer);
-  g_free (data);
-}
-
-static void
-cups_request_ppd_cb (GtkPrintBackendCups *print_backend,
-                     GtkCupsResult       *result,
-                     GetPPDData          *data)
-{
-  ipp_t *response;
-  GtkPrinter *printer;
-
-  GDK_THREADS_ENTER ();
-
-  GTK_NOTE (PRINTING,
-            g_print ("CUPS Backend: %s\n", G_STRFUNC));
-
-  printer = GTK_PRINTER (data->printer);
-  GTK_PRINTER_CUPS (printer)->reading_ppd = FALSE;
-  print_backend->reading_ppds--;
-
-  if (gtk_cups_result_is_error (result))
-    {
-      gboolean success = FALSE;
-
-      /* If we get a 404 then it is just a raw printer without a ppd
-         and not an error. Standalone Avahi printers also don't have
-         PPD files. */
-      if (((gtk_cups_result_get_error_type (result) == GTK_CUPS_ERROR_HTTP) &&
-           (gtk_cups_result_get_error_status (result) == HTTP_NOT_FOUND))
-#ifdef HAVE_CUPS_API_1_6
-           || GTK_PRINTER_CUPS (printer)->avahi_browsed
-#endif
-           )
-        {
-          gtk_printer_set_has_details (printer, TRUE);
-          success = TRUE;
-        } 
-        
-      g_signal_emit_by_name (printer, "details-acquired", success);
-      goto done;
-    }
-
-  response = gtk_cups_result_get_response (result);
-
-  /* let ppdOpenFd take over the ownership of the open file */
-  g_io_channel_seek_position (data->ppd_io, 0, G_SEEK_SET, NULL);
-  data->printer->ppd_file = ppdOpenFd (dup (g_io_channel_unix_get_fd (data->ppd_io)));
-
-  ppdMarkDefaults (data->printer->ppd_file);
-  
-  gtk_printer_set_has_details (printer, TRUE);
-  g_signal_emit_by_name (printer, "details-acquired", TRUE);
-
-done:
-  GDK_THREADS_LEAVE ();
-}
-
-static gboolean
-cups_request_ppd (GtkPrinter *printer)
-{
-  GError *error;
-  GtkPrintBackend *print_backend;
-  GtkPrinterCups *cups_printer;
-  GtkCupsRequest *request;
-  char *ppd_filename = NULL;
-  gchar *resource;
-  http_t *http;
-  GetPPDData *data;
-  int fd;
-
-  cups_printer = GTK_PRINTER_CUPS (printer);
-
-  error = NULL;
-
-  GTK_NOTE (PRINTING,
-            g_print ("CUPS Backend: %s\n", G_STRFUNC));
-
-  if (cups_printer->remote)
-    {
-      GtkCupsConnectionState state;
-
-      state = gtk_cups_connection_test_get_state (cups_printer->remote_cups_connection_test);
-
-      if (state == GTK_CUPS_CONNECTION_IN_PROGRESS)
-        {
-          if (cups_printer->get_remote_ppd_attempts == 60)
-            {
-              cups_printer->get_remote_ppd_attempts = -1;
-              if (cups_printer->get_remote_ppd_poll > 0)
-                g_source_remove (cups_printer->get_remote_ppd_poll);
-              cups_printer->get_remote_ppd_poll = gdk_threads_add_timeout (200,
-                                                    (GSourceFunc) cups_request_ppd,
-                                                    printer);
-            }
-          else if (cups_printer->get_remote_ppd_attempts != -1)
-            cups_printer->get_remote_ppd_attempts++;
-
-          return TRUE;
-        }
-
-      gtk_cups_connection_test_free (cups_printer->remote_cups_connection_test);
-      cups_printer->remote_cups_connection_test = NULL;
-      cups_printer->get_remote_ppd_poll = 0;
-      cups_printer->get_remote_ppd_attempts = 0;
-
-      if (state == GTK_CUPS_CONNECTION_NOT_AVAILABLE)
-        {
-          g_signal_emit_by_name (printer, "details-acquired", FALSE);
-          return FALSE;
-        }
-    }
-
-  http = httpConnectEncrypt (cups_printer->hostname, 
-			     cups_printer->port,
-			     cupsEncryption ());
-  
-  data = g_new0 (GetPPDData, 1);
-
-  fd = g_file_open_tmp ("gtkprint_ppd_XXXXXX", 
-                        &ppd_filename, 
-                        &error);
-
-#ifdef G_ENABLE_DEBUG 
-  /* If we are debugging printing don't delete the tmp files */
-  if (!(gtk_debug_flags & GTK_DEBUG_PRINTING))
-    unlink (ppd_filename);
-#else
-  unlink (ppd_filename);
-#endif /* G_ENABLE_DEBUG */
-
-  if (error != NULL)
-    {
-      GTK_NOTE (PRINTING, 
-                g_warning ("CUPS Backend: Failed to create temp file, %s\n", 
-                           error->message));
-      g_error_free (error);
-      httpClose (http);
-      g_free (ppd_filename);
-      g_free (data);
-
-      g_signal_emit_by_name (printer, "details-acquired", FALSE);
-      return FALSE;
-    }
-    
-  data->http = http;
-  fchmod (fd, S_IRUSR | S_IWUSR);
-  data->ppd_io = g_io_channel_unix_new (fd);
-  g_io_channel_set_encoding (data->ppd_io, NULL, NULL);
-  g_io_channel_set_close_on_unref (data->ppd_io, TRUE);
-
-  data->printer = GTK_PRINTER_CUPS (g_object_ref (printer));
-
-  resource = g_strdup_printf ("/printers/%s.ppd", 
-                              gtk_printer_cups_get_ppd_name (GTK_PRINTER_CUPS (printer)));
-
-  print_backend = gtk_printer_get_backend (printer);
-
-  request = gtk_cups_request_new_with_username (data->http,
-                                                GTK_CUPS_GET,
-                                                0,
-                                                data->ppd_io,
-                                                cups_printer->hostname,
-                                                resource,
-                                                GTK_PRINT_BACKEND_CUPS (print_backend)->username);
-
-  gtk_cups_request_set_ipp_version (request,
-                                    cups_printer->ipp_version_major,
-                                    cups_printer->ipp_version_minor);
-
-  GTK_NOTE (PRINTING,
-            g_print ("CUPS Backend: Requesting resource %s to be written to temp file %s\n", resource, ppd_filename));
-
-
-  cups_printer->reading_ppd = TRUE;
-  GTK_PRINT_BACKEND_CUPS (print_backend)->reading_ppds++;
-
-  cups_request_execute (GTK_PRINT_BACKEND_CUPS (print_backend),
-                        request,
-                        (GtkPrintCupsResponseCallbackFunc) cups_request_ppd_cb,
-                        data,
-                        (GDestroyNotify)get_ppd_data_free);
-
-  g_free (resource);
-  g_free (ppd_filename);
-
-  return FALSE;
-}
-
-/* Ordering matters for default preference */
-static const char *lpoptions_locations[] = {
-  "/etc/cups/lpoptions",
-  ".lpoptions", 
-  ".cups/lpoptions"
-};
-
-static void
-cups_parse_user_default_printer (const char  *filename,
-                                 char       **printer_name)
-{
-  FILE *fp;
-  char line[1024], *lineptr, *defname = NULL;
-  
-  if ((fp = g_fopen (filename, "r")) == NULL)
-    return;
-
-  while (fgets (line, sizeof (line), fp) != NULL)
-    {
-      if (strncasecmp (line, "default", 7) != 0 || !isspace (line[7]))
-        continue;
-
-      lineptr = line + 8;
-      while (isspace (*lineptr))
-        lineptr++;
-
-      if (!*lineptr)
-        continue;
-
-      defname = lineptr;
-      while (!isspace (*lineptr) && *lineptr && *lineptr != '/')
-        lineptr++;
-
-      *lineptr = '\0';
-
-      if (*printer_name != NULL)
-        g_free (*printer_name);
-
-      *printer_name = g_strdup (defname);
-    }
-
-  fclose (fp);
-}
-
-static void
-cups_get_user_default_printer (char **printer_name)
-{
-  int i;
-
-  for (i = 0; i < G_N_ELEMENTS (lpoptions_locations); i++)
-    {
-      if (g_path_is_absolute (lpoptions_locations[i]))
-        {
-          cups_parse_user_default_printer (lpoptions_locations[i],
-                                           printer_name);
-        }
-      else 
-        {
-          char *filename;
-
-          filename = g_build_filename (g_get_home_dir (), 
-                                       lpoptions_locations[i], NULL);
-          cups_parse_user_default_printer (filename, printer_name);
-          g_free (filename);
-        }
-    }
-}
-
-static int
-cups_parse_user_options (const char     *filename,
-                         const char     *printer_name,
-                         int             num_options,
-                         cups_option_t **options)
-{
-  FILE *fp;
-  gchar line[1024], *lineptr, *name;
-
-  if ((fp = g_fopen (filename, "r")) == NULL)
-    return num_options;
-
-  while (fgets (line, sizeof (line), fp) != NULL)
-    {
-      if (strncasecmp (line, "dest", 4) == 0 && isspace (line[4]))
-        lineptr = line + 4;
-      else if (strncasecmp (line, "default", 7) == 0 && isspace (line[7]))
-        lineptr = line + 7;
-      else
-        continue;
-
-      /* Skip leading whitespace */
-      while (isspace (*lineptr))
-        lineptr++;
-
-      if (!*lineptr)
-        continue;
-
-      /* NUL-terminate the name, stripping the instance name */
-      name = lineptr;
-      while (!isspace (*lineptr) && *lineptr)
-        {
-          if (*lineptr == '/')
-            *lineptr = '\0';
-          lineptr++;
-        }
-
-      if (!*lineptr)
-        continue;
-
-      *lineptr++ = '\0';
-
-      if (strncasecmp (name, printer_name, strlen (printer_name)) != 0)
-          continue;
-
-      /* We found our printer, parse the options */
-      num_options = cupsParseOptions (lineptr, num_options, options);
-    }
-
-  fclose (fp);
-
-  return num_options;
-}
-
-static int
-cups_get_user_options (const char     *printer_name,
-                       int             num_options,
-                       cups_option_t **options)
-{
-  int i;
-
-  for (i = 0; i < G_N_ELEMENTS (lpoptions_locations); i++)
-    {
-      if (g_path_is_absolute (lpoptions_locations[i]))
-        { 
-           num_options = cups_parse_user_options (lpoptions_locations[i],
-                                                  printer_name,
-                                                  num_options,
-                                                  options);
-        }
-      else
-        {
-          char *filename;
-
-          filename = g_build_filename (g_get_home_dir (), 
-                                       lpoptions_locations[i], NULL);
-          num_options = cups_parse_user_options (filename, printer_name,
-                                                 num_options, options);
-          g_free (filename);
-        }
-    }
-
-  return num_options;
-}
-
-/* This function requests default printer from a CUPS server in regular intervals.
- * In the case of unreachable CUPS server the request is repeated later.
- * The default printer is not requested in the case of previous success.
- */
-static void
-cups_get_default_printer (GtkPrintBackendCups *backend)
-{
-  GtkPrintBackendCups *cups_backend;
-
-  cups_backend = backend;
-
-  if (cups_backend->cups_connection_test == NULL)
-    cups_backend->cups_connection_test = gtk_cups_connection_test_new (NULL, -1);
-
-  if (cups_backend->default_printer_poll == 0)
-    {
-      if (cups_request_default_printer (cups_backend))
-        cups_backend->default_printer_poll = gdk_threads_add_timeout (200,
-                                               (GSourceFunc) cups_request_default_printer,
-                                               backend);
-    }
-}
-
-/* This function gets default printer from local settings.*/
-static void
-cups_get_local_default_printer (GtkPrintBackendCups *backend)
-{
-  const char *str;
-  char *name = NULL;
-
-  if ((str = g_getenv ("LPDEST")) != NULL)
-    {
-      backend->default_printer = g_strdup (str);
-      backend->got_default_printer = TRUE;
-      return;
-    }
-  else if ((str = g_getenv ("PRINTER")) != NULL &&
-	   strcmp (str, "lp") != 0)
-    {
-      backend->default_printer = g_strdup (str);
-      backend->got_default_printer = TRUE;
-      return;
-    }
-  
-  /* Figure out user setting for default printer */  
-  cups_get_user_default_printer (&name);
-  if (name != NULL)
-    {
-      backend->default_printer = name;
-      backend->got_default_printer = TRUE;
-      return;
-    }
-}
-
-static void
-cups_request_default_printer_cb (GtkPrintBackendCups *print_backend,
-				 GtkCupsResult       *result,
-				 gpointer             user_data)
-{
-  ipp_t *response;
-  ipp_attribute_t *attr;
-  GtkPrinter *printer;
-
-  GDK_THREADS_ENTER ();
-
-  if (gtk_cups_result_is_error (result))
-    {
-      if (gtk_cups_result_get_error_type (result) == GTK_CUPS_ERROR_AUTH &&
-          gtk_cups_result_get_error_code (result) == 1)
-        {
-          /* Canceled by user, stop popping up more password dialogs */
-          if (print_backend->list_printers_poll > 0)
-            g_source_remove (print_backend->list_printers_poll);
-          print_backend->list_printers_poll = 0;
-        }
-
-      return;
-    }
-
-  response = gtk_cups_result_get_response (result);
-  
-  if ((attr = ippFindAttribute (response, "printer-name", IPP_TAG_NAME)) != NULL)
-      print_backend->default_printer = g_strdup (ippGetString (attr, 0, NULL));
-
-  print_backend->got_default_printer = TRUE;
-
-  if (print_backend->default_printer != NULL)
-    {
-      printer = gtk_print_backend_find_printer (GTK_PRINT_BACKEND (print_backend), print_backend->default_printer);
-      if (printer != NULL)
-        {
-          gtk_printer_set_is_default (printer, TRUE);
-          g_signal_emit_by_name (GTK_PRINT_BACKEND (print_backend), "printer-status-changed", printer);
-        }
-    }
-
-  /* Make sure to kick off get_printers if we are polling it, 
-   * as we could have blocked this reading the default printer 
-   */
-  if (print_backend->list_printers_poll != 0)
-    cups_request_printer_list (print_backend);
-
-  GDK_THREADS_LEAVE ();
-}
-
-static gboolean
-cups_request_default_printer (GtkPrintBackendCups *print_backend)
-{
-  GtkCupsConnectionState state;
-  GtkCupsRequest *request;
-
-  state = gtk_cups_connection_test_get_state (print_backend->cups_connection_test);
-  update_backend_status (print_backend, state);
-
-  if (state == GTK_CUPS_CONNECTION_IN_PROGRESS || state == GTK_CUPS_CONNECTION_NOT_AVAILABLE)
-    return TRUE;
-
-  request = gtk_cups_request_new_with_username (NULL,
-                                                GTK_CUPS_POST,
-                                                CUPS_GET_DEFAULT,
-                                                NULL,
-                                                NULL,
-                                                NULL,
-                                                print_backend->username);
-  
-  cups_request_execute (print_backend,
-                        request,
-                        (GtkPrintCupsResponseCallbackFunc) cups_request_default_printer_cb,
-		        g_object_ref (print_backend),
-		        g_object_unref);
-
-  return FALSE;
-}
-
-static void
-cups_printer_request_details (GtkPrinter *printer)
-{
-  GtkPrinterCups *cups_printer;
-
-  cups_printer = GTK_PRINTER_CUPS (printer);
-  if (!cups_printer->reading_ppd && 
-      gtk_printer_cups_get_ppd (cups_printer) == NULL)
-    {
-      if (cups_printer->remote)
-        {
-          if (cups_printer->get_remote_ppd_poll == 0)
-            {
-              cups_printer->remote_cups_connection_test =
-                gtk_cups_connection_test_new (cups_printer->hostname,
-                                              cups_printer->port);
-
-              if (cups_request_ppd (printer))
-                cups_printer->get_remote_ppd_poll = gdk_threads_add_timeout (50,
-                                                    (GSourceFunc) cups_request_ppd,
-                                                    printer);
-            }
-        }
-      else
-        cups_request_ppd (printer);
-    }
-}
-
-static char *
-ppd_text_to_utf8 (ppd_file_t *ppd_file, 
-		  const char *text)
-{
-  const char *encoding = NULL;
-  char *res;
-  
-  if (g_ascii_strcasecmp (ppd_file->lang_encoding, "UTF-8") == 0)
-    {
-      return g_strdup (text);
-    }
-  else if (g_ascii_strcasecmp (ppd_file->lang_encoding, "ISOLatin1") == 0)
-    {
-      encoding = "ISO-8859-1";
-    }
-  else if (g_ascii_strcasecmp (ppd_file->lang_encoding, "ISOLatin2") == 0)
-    {
-      encoding = "ISO-8859-2";
-    }
-  else if (g_ascii_strcasecmp (ppd_file->lang_encoding, "ISOLatin5") == 0)
-    {
-      encoding = "ISO-8859-5";
-    }
-  else if (g_ascii_strcasecmp (ppd_file->lang_encoding, "JIS83-RKSJ") == 0)
-    {
-      encoding = "SHIFT-JIS";
-    }
-  else if (g_ascii_strcasecmp (ppd_file->lang_encoding, "MacStandard") == 0)
-    {
-      encoding = "MACINTOSH";
-    }
-  else if (g_ascii_strcasecmp (ppd_file->lang_encoding, "WindowsANSI") == 0)
-    {
-      encoding = "WINDOWS-1252";
-    }
-  else 
-    {
-      /* Fallback, try iso-8859-1... */
-      encoding = "ISO-8859-1";
-    }
-
-  res = g_convert (text, -1, "UTF-8", encoding, NULL, NULL, NULL);
-
-  if (res == NULL)
-    {
-      GTK_NOTE (PRINTING,
-                g_warning ("CUPS Backend: Unable to convert PPD text\n"));
-      res = g_strdup ("???");
-    }
-  
-  return res;
-}
-
-/* TODO: Add more translations for common settings here */
-
-static const struct {
-  const char *keyword;
-  const char *translation;
-} cups_option_translations[] = {
-  { "Duplex", N_("Two Sided") },
-  { "MediaType", N_("Paper Type") },
-  { "InputSlot", N_("Paper Source") },
-  { "OutputBin", N_("Output Tray") },
-  { "Resolution", N_("Resolution") },
-  { "PreFilter", N_("GhostScript pre-filtering") },
-};
-
-
-static const struct {
-  const char *keyword;
-  const char *choice;
-  const char *translation;
-} cups_choice_translations[] = {
-  { "Duplex", "None", N_("One Sided") },
-  /* Translators: this is an option of "Two Sided" */
-  { "Duplex", "DuplexNoTumble", N_("Long Edge (Standard)") },
-  /* Translators: this is an option of "Two Sided" */
-  { "Duplex", "DuplexTumble", N_("Short Edge (Flip)") },
-  /* Translators: this is an option of "Paper Source" */
-  { "InputSlot", "Auto", N_("Auto Select") },
-  /* Translators: this is an option of "Paper Source" */
-  { "InputSlot", "AutoSelect", N_("Auto Select") },
-  /* Translators: this is an option of "Paper Source" */
-  { "InputSlot", "Default", N_("Printer Default") },
-  /* Translators: this is an option of "Paper Source" */
-  { "InputSlot", "None", N_("Printer Default") },
-  /* Translators: this is an option of "Paper Source" */
-  { "InputSlot", "PrinterDefault", N_("Printer Default") },
-  /* Translators: this is an option of "Paper Source" */
-  { "InputSlot", "Unspecified", N_("Auto Select") },
-  /* Translators: this is an option of "Resolution" */
-  { "Resolution", "default", N_("Printer Default") },
-  /* Translators: this is an option of "GhostScript" */
-  { "PreFilter", "EmbedFonts", N_("Embed GhostScript fonts only") },
-  /* Translators: this is an option of "GhostScript" */
-  { "PreFilter", "Level1", N_("Convert to PS level 1") },
-  /* Translators: this is an option of "GhostScript" */
-  { "PreFilter", "Level2", N_("Convert to PS level 2") },
-  /* Translators: this is an option of "GhostScript" */
-  { "PreFilter", "No", N_("No pre-filtering") },
-};
-
-static const struct {
-  const char *name;
-  const char *translation;
-} cups_group_translations[] = {
-/* Translators: "Miscellaneous" is the label for a button, that opens
-   up an extra panel of settings in a print dialog. */
-  { "Miscellaneous", N_("Miscellaneous") },
-};
-
-static const struct {
-  const char *ppd_keyword;
-  const char *name;
-} ppd_option_names[] = {
-  {"Duplex", "gtk-duplex" },
-  {"MediaType", "gtk-paper-type"},
-  {"InputSlot", "gtk-paper-source"},
-  {"OutputBin", "gtk-output-tray"},
-};
-
-static const struct {
-  const char *lpoption;
-  const char *name;
-} lpoption_names[] = {
-  {"number-up", "gtk-n-up" },
-  {"number-up-layout", "gtk-n-up-layout"},
-  {"job-billing", "gtk-billing-info"},
-  {"job-priority", "gtk-job-prio"},
-};
-
-/* keep sorted when changing */
-static const char *color_option_whitelist[] = {
-  "BRColorEnhancement",
-  "BRColorMatching",
-  "BRColorMatching",
-  "BRColorMode",
-  "BRGammaValue",
-  "BRImprovedGray",
-  "BlackSubstitution",
-  "ColorModel",
-  "HPCMYKInks",
-  "HPCSGraphics",
-  "HPCSImages",
-  "HPCSText",
-  "HPColorSmart",
-  "RPSBlackMode",
-  "RPSBlackOverPrint",
-  "Rcmyksimulation",
-};
-
-/* keep sorted when changing */
-static const char *color_group_whitelist[] = {
-  "ColorPage",
-  "FPColorWise1",
-  "FPColorWise2",
-  "FPColorWise3",
-  "FPColorWise4",
-  "FPColorWise5",
-  "HPColorOptionsPanel",
-};
-  
-/* keep sorted when changing */
-static const char *image_quality_option_whitelist[] = {
-  "BRDocument",
-  "BRHalfTonePattern",
-  "BRNormalPrt",
-  "BRPrintQuality",
-  "BitsPerPixel",
-  "Darkness",
-  "Dithering",
-  "EconoMode",
-  "Economode",
-  "HPEconoMode",
-  "HPEdgeControl",
-  "HPGraphicsHalftone",
-  "HPHalftone",
-  "HPLJDensity",
-  "HPPhotoHalftone",
-  "OutputMode",
-  "REt",
-  "RPSBitsPerPixel",
-  "RPSDitherType",
-  "Resolution",
-  "ScreenLock",
-  "Smoothing",
-  "TonerSaveMode",
-  "UCRGCRForImage",
-};
-
-/* keep sorted when changing */
-static const char *image_quality_group_whitelist[] = {
-  "FPImageQuality1",
-  "FPImageQuality2",
-  "FPImageQuality3",
-  "ImageQualityPage",
-};
-
-/* keep sorted when changing */
-static const char * finishing_option_whitelist[] = {
-  "BindColor",
-  "BindEdge",
-  "BindType",
-  "BindWhen",
-  "Booklet",
-  "FoldType",
-  "FoldWhen",
-  "HPStaplerOptions",
-  "Jog",
-  "Slipsheet",
-  "Sorter",
-  "StapleLocation",
-  "StapleOrientation",
-  "StapleWhen",
-  "StapleX",
-  "StapleY",
-};
-
-/* keep sorted when changing */
-static const char *finishing_group_whitelist[] = {
-  "FPFinishing1",
-  "FPFinishing2",
-  "FPFinishing3",
-  "FPFinishing4",
-  "FinishingPage",
-  "HPFinishingPanel",
-};
-
-/* keep sorted when changing */
-static const char *cups_option_blacklist[] = {
-  "Collate",
-  "Copies", 
-  "OutputOrder",
-  "PageRegion",
-  "PageSize",
-};
-
-static char *
-get_option_text (ppd_file_t   *ppd_file, 
-		 ppd_option_t *option)
-{
-  int i;
-  char *utf8;
-  
-  for (i = 0; i < G_N_ELEMENTS (cups_option_translations); i++)
-    {
-      if (strcmp (cups_option_translations[i].keyword, option->keyword) == 0)
-	return g_strdup (_(cups_option_translations[i].translation));
-    }
-
-  utf8 = ppd_text_to_utf8 (ppd_file, option->text);
-
-  /* Some ppd files have spaces in the text before the colon */
-  g_strchomp (utf8);
-  
-  return utf8;
-}
-
-static char *
-get_choice_text (ppd_file_t   *ppd_file, 
-		 ppd_choice_t *choice)
-{
-  int i;
-  ppd_option_t *option = choice->option;
-  const char *keyword = option->keyword;
-  
-  for (i = 0; i < G_N_ELEMENTS (cups_choice_translations); i++)
-    {
-      if (strcmp (cups_choice_translations[i].keyword, keyword) == 0 &&
-	  strcmp (cups_choice_translations[i].choice, choice->choice) == 0)
-	return g_strdup (_(cups_choice_translations[i].translation));
-    }
-  return ppd_text_to_utf8 (ppd_file, choice->text);
-}
-
-static gboolean
-group_has_option (ppd_group_t  *group, 
-		  ppd_option_t *option)
-{
-  int i;
-
-  if (group == NULL)
-    return FALSE;
-  
-  if (group->num_options > 0 &&
-      option >= group->options && option < group->options + group->num_options)
-    return TRUE;
-  
-  for (i = 0; i < group->num_subgroups; i++)
-    {
-      if (group_has_option (&group->subgroups[i],option))
-	return TRUE;
-    }
-  return FALSE;
-}
-
-static void
-set_option_off (GtkPrinterOption *option)
-{
-  /* Any of these will do, _set only applies the value
-   * if its allowed of the option */
-  gtk_printer_option_set (option, "False");
-  gtk_printer_option_set (option, "Off");
-  gtk_printer_option_set (option, "None");
-}
-
-static gboolean
-value_is_off (const char *value)
-{
-  return  (strcasecmp (value, "None") == 0 ||
-	   strcasecmp (value, "Off") == 0 ||
-	   strcasecmp (value, "False") == 0);
-}
-
-static char *
-ppd_group_name (ppd_group_t *group)
-{
-#if CUPS_VERSION_MAJOR > 1 || (CUPS_VERSION_MAJOR == 1 && CUPS_VERSION_MINOR > 1) || (CUPS_VERSION_MAJOR == 1 && CUPS_VERSION_MINOR == 1 && CUPS_VERSION_PATCH >= 18) 
-  return group->name;
-#else
-  return group->text;
-#endif
-}
-
-static int
-available_choices (ppd_file_t     *ppd,
-		   ppd_option_t   *option,
-		   ppd_choice_t ***available,
-		   gboolean        keep_if_only_one_option)
-{
-  ppd_option_t *other_option;
-  int i, j;
-  gchar *conflicts;
-  ppd_const_t *constraint;
-  const char *choice, *other_choice;
-  ppd_option_t *option1, *option2;
-  ppd_group_t *installed_options;
-  int num_conflicts;
-  gboolean all_default;
-  int add_auto;
-
-  if (available)
-    *available = NULL;
-
-  conflicts = g_new0 (char, option->num_choices);
-
-  installed_options = NULL;
-  for (i = 0; i < ppd->num_groups; i++)
-    {
-      char *name; 
-
-      name = ppd_group_name (&ppd->groups[i]);
-      if (strcmp (name, "InstallableOptions") == 0)
-	{
-	  installed_options = &ppd->groups[i];
-	  break;
-	}
-    }
-
-  for (i = ppd->num_consts, constraint = ppd->consts; i > 0; i--, constraint++)
-    {
-      option1 = ppdFindOption (ppd, constraint->option1);
-      if (option1 == NULL)
-	continue;
-
-      option2 = ppdFindOption (ppd, constraint->option2);
-      if (option2 == NULL)
-	continue;
-
-      if (option == option1)
-	{
-	  choice = constraint->choice1;
-	  other_option = option2;
-	  other_choice = constraint->choice2;
-	}
-      else if (option == option2)
-	{
-	  choice = constraint->choice2;
-	  other_option = option1;
-	  other_choice = constraint->choice1;
-	}
-      else
-	continue;
-
-      /* We only care of conflicts with installed_options and
-         PageSize */
-      if (!group_has_option (installed_options, other_option) &&
-	  (strcmp (other_option->keyword, "PageSize") != 0))
-	continue;
-
-      if (*other_choice == 0)
-	{
-	  /* Conflict only if the installed option is not off */
-	  if (value_is_off (other_option->defchoice))
-	    continue;
-	}
-      /* Conflict if the installed option has the specified default */
-      else if (strcasecmp (other_choice, other_option->defchoice) != 0)
-	continue;
-
-      if (*choice == 0)
-	{
-	  /* Conflict with all non-off choices */
-	  for (j = 0; j < option->num_choices; j++)
-	    {
-	      if (!value_is_off (option->choices[j].choice))
-		conflicts[j] = 1;
-	    }
-	}
-      else
-	{
-	  for (j = 0; j < option->num_choices; j++)
-	    {
-	      if (strcasecmp (option->choices[j].choice, choice) == 0)
-		conflicts[j] = 1;
-	    }
-	}
-    }
-
-  num_conflicts = 0;
-  all_default = TRUE;
-  for (j = 0; j < option->num_choices; j++)
-    {
-      if (conflicts[j])
-	num_conflicts++;
-      else if (strcmp (option->choices[j].choice, option->defchoice) != 0)
-	all_default = FALSE;
-    }
-
-  if ((all_default && !keep_if_only_one_option) ||
-      (num_conflicts == option->num_choices))
-    {
-      g_free (conflicts);
-
-      return 0;
-    }
-
-  /* Some ppds don't have a "use printer default" option for
-   * InputSlot. This means you always have to select a particular slot,
-   * and you can't auto-pick source based on the paper size. To support
-   * this we always add an auto option if there isn't one already. If
-   * the user chooses the generated option we don't send any InputSlot
-   * value when printing. The way we detect existing auto-cases is based
-   * on feedback from Michael Sweet of cups fame.
-   */
-  add_auto = 0;
-  if (strcmp (option->keyword, "InputSlot") == 0)
-    {
-      gboolean found_auto = FALSE;
-      for (j = 0; j < option->num_choices; j++)
-	{
-	  if (!conflicts[j])
-	    {
-	      if (strcmp (option->choices[j].choice, "Auto") == 0 ||
-		  strcmp (option->choices[j].choice, "AutoSelect") == 0 ||
-		  strcmp (option->choices[j].choice, "Default") == 0 ||
-		  strcmp (option->choices[j].choice, "None") == 0 ||
-		  strcmp (option->choices[j].choice, "PrinterDefault") == 0 ||
-		  strcmp (option->choices[j].choice, "Unspecified") == 0 ||
-		  option->choices[j].code == NULL ||
-		  option->choices[j].code[0] == 0)
-		{
-		  found_auto = TRUE;
-		  break;
-		}
-	    }
-	}
-
-      if (!found_auto)
-	add_auto = 1;
-    }
-  
-  if (available)
-    {
-      *available = g_new (ppd_choice_t *, option->num_choices - num_conflicts + add_auto);
-
-      i = 0;
-      for (j = 0; j < option->num_choices; j++)
-	{
-	  if (!conflicts[j])
-	    (*available)[i++] = &option->choices[j];
-	}
-
-      if (add_auto) 
-	(*available)[i++] = NULL;
-    }
-
-  g_free (conflicts);
-  
-  return option->num_choices - num_conflicts + add_auto;
-}
-
-static GtkPrinterOption *
-create_pickone_option (ppd_file_t   *ppd_file,
-		       ppd_option_t *ppd_option,
-		       const gchar  *gtk_name)
-{
-  GtkPrinterOption *option;
-  ppd_choice_t **available;
-  char *label;
-  int n_choices;
-  int i;
-#ifdef HAVE_CUPS_API_1_2
-  ppd_coption_t *coption;
-#endif
-
-  g_assert (ppd_option->ui == PPD_UI_PICKONE);
-  
-  option = NULL;
-
-  n_choices = available_choices (ppd_file, ppd_option, &available, g_str_has_prefix (gtk_name, "gtk-"));
-  if (n_choices > 0)
-    {
-      
-      /* right now only support one parameter per custom option 
-       * if more than one print warning and only offer the default choices
-       */
-
-      label = get_option_text (ppd_file, ppd_option);
-
-#ifdef HAVE_CUPS_API_1_2
-      coption = ppdFindCustomOption (ppd_file, ppd_option->keyword);
-
-      if (coption)
-        {
-	  ppd_cparam_t *cparam;
-
-          cparam = ppdFirstCustomParam (coption);
-
-          if (ppdNextCustomParam (coption) == NULL)
-	    {
-              switch (cparam->type)
-	        {
-                case PPD_CUSTOM_INT:
-		  option = gtk_printer_option_new (gtk_name, label,
-				         GTK_PRINTER_OPTION_TYPE_PICKONE_INT);
-		  break;
-                case PPD_CUSTOM_PASSCODE:
-		  option = gtk_printer_option_new (gtk_name, label,
-				         GTK_PRINTER_OPTION_TYPE_PICKONE_PASSCODE);
-		  break;
-                case PPD_CUSTOM_PASSWORD:
-		    option = gtk_printer_option_new (gtk_name, label,
-				         GTK_PRINTER_OPTION_TYPE_PICKONE_PASSWORD);
-		  break;
-               case PPD_CUSTOM_REAL:
-		    option = gtk_printer_option_new (gtk_name, label,
-				         GTK_PRINTER_OPTION_TYPE_PICKONE_REAL);
-		  break;
-                case PPD_CUSTOM_STRING:
-		  option = gtk_printer_option_new (gtk_name, label,
-				         GTK_PRINTER_OPTION_TYPE_PICKONE_STRING);
-		  break;
-#ifdef PRINT_IGNORED_OPTIONS
-                case PPD_CUSTOM_POINTS: 
-		  g_warning ("CUPS Backend: PPD Custom Points Option not supported");
-		  break;
-                case PPD_CUSTOM_CURVE:
-                  g_warning ("CUPS Backend: PPD Custom Curve Option not supported");
-		  break;
-                case PPD_CUSTOM_INVCURVE: 	
-		  g_warning ("CUPS Backend: PPD Custom Inverse Curve Option not supported");
-		  break;
-#endif
-                default: 
-                  break;
-		}
-	    }
-#ifdef PRINT_IGNORED_OPTIONS
-	  else
-	    g_warning ("CUPS Backend: Multi-parameter PPD Custom Option not supported");
-#endif
-	}
-#endif /* HAVE_CUPS_API_1_2 */
-
-      if (!option)
-        option = gtk_printer_option_new (gtk_name, label,
-				         GTK_PRINTER_OPTION_TYPE_PICKONE);
-      g_free (label);
-      
-      gtk_printer_option_allocate_choices (option, n_choices);
-      for (i = 0; i < n_choices; i++)
-	{
-	  if (available[i] == NULL)
-	    {
-	      /* This was auto-added */
-	      option->choices[i] = g_strdup ("gtk-ignore-value");
-	      option->choices_display[i] = g_strdup (_("Printer Default"));
-	    }
-	  else
-	    {
-	      option->choices[i] = g_strdup (available[i]->choice);
-	      option->choices_display[i] = get_choice_text (ppd_file, available[i]);
-	    }
-	}
-
-      if (option->type != GTK_PRINTER_OPTION_TYPE_PICKONE)
-        {
-          if (g_str_has_prefix (ppd_option->defchoice, "Custom."))
-            gtk_printer_option_set (option, ppd_option->defchoice + 7);
-          else
-            gtk_printer_option_set (option, ppd_option->defchoice);
-        }
-      else
-        {
-          gtk_printer_option_set (option, ppd_option->defchoice);
-        }
-    }
-#ifdef PRINT_IGNORED_OPTIONS
-  else
-    g_warning ("CUPS Backend: Ignoring pickone %s\n", ppd_option->text);
-#endif
-  g_free (available);
-
-  return option;
-}
-
-static GtkPrinterOption *
-create_boolean_option (ppd_file_t   *ppd_file,
-		       ppd_option_t *ppd_option,
-		       const gchar  *gtk_name)
-{
-  GtkPrinterOption *option;
-  ppd_choice_t **available;
-  char *label;
-  int n_choices;
-
-  g_assert (ppd_option->ui == PPD_UI_BOOLEAN);
-  
-  option = NULL;
-
-  n_choices = available_choices (ppd_file, ppd_option, &available, g_str_has_prefix (gtk_name, "gtk-"));
-  if (n_choices == 2)
-    {
-      label = get_option_text (ppd_file, ppd_option);
-      option = gtk_printer_option_new (gtk_name, label,
-				       GTK_PRINTER_OPTION_TYPE_BOOLEAN);
-      g_free (label);
-      
-      gtk_printer_option_allocate_choices (option, 2);
-      option->choices[0] = g_strdup ("True");
-      option->choices_display[0] = g_strdup ("True");
-      option->choices[1] = g_strdup ("False");
-      option->choices_display[1] = g_strdup ("False");
-      
-      gtk_printer_option_set (option, ppd_option->defchoice);
-    }
-#ifdef PRINT_IGNORED_OPTIONS
-  else
-    g_warning ("CUPS Backend: Ignoring boolean %s\n", ppd_option->text);
-#endif
-  g_free (available);
-
-  return option;
-}
-
-static gchar *
-get_ppd_option_name (const gchar *keyword)
-{
-  int i;
-
-  for (i = 0; i < G_N_ELEMENTS (ppd_option_names); i++)
-    if (strcmp (ppd_option_names[i].ppd_keyword, keyword) == 0)
-      return g_strdup (ppd_option_names[i].name);
-
-  return g_strdup_printf ("cups-%s", keyword);
-}
-
-static gchar *
-get_lpoption_name (const gchar *lpoption)
-{
-  int i;
-
-  for (i = 0; i < G_N_ELEMENTS (ppd_option_names); i++)
-    if (strcmp (ppd_option_names[i].ppd_keyword, lpoption) == 0)
-      return g_strdup (ppd_option_names[i].name);
-
-  for (i = 0; i < G_N_ELEMENTS (lpoption_names); i++)
-    if (strcmp (lpoption_names[i].lpoption, lpoption) == 0)
-      return g_strdup (lpoption_names[i].name);
-
-  return g_strdup_printf ("cups-%s", lpoption);
-}
-
-static int
-strptr_cmp (const void *a, 
-	    const void *b)
-{
-  char **aa = (char **)a;
-  char **bb = (char **)b;
-  return strcmp (*aa, *bb);
-}
-
-
-static gboolean
-string_in_table (gchar       *str, 
-		 const gchar *table[], 
-		 gint         table_len)
-{
-  return bsearch (&str, table, table_len, sizeof (char *), (void *)strptr_cmp) != NULL;
-}
-
-#define STRING_IN_TABLE(_str, _table) (string_in_table (_str, _table, G_N_ELEMENTS (_table)))
-
-static void
-handle_option (GtkPrinterOptionSet *set,
-	       ppd_file_t          *ppd_file,
-	       ppd_option_t        *ppd_option,
-	       ppd_group_t         *toplevel_group,
-	       GtkPrintSettings    *settings)
-{
-  GtkPrinterOption *option;
-  char *name;
-  int i;
-
-  if (STRING_IN_TABLE (ppd_option->keyword, cups_option_blacklist))
-    return;
-
-  name = get_ppd_option_name (ppd_option->keyword);
-
-  option = NULL;
-  if (ppd_option->ui == PPD_UI_PICKONE)
-    {
-      option = create_pickone_option (ppd_file, ppd_option, name);
-    }
-  else if (ppd_option->ui == PPD_UI_BOOLEAN)
-    {
-      option = create_boolean_option (ppd_file, ppd_option, name);
-    }
-#ifdef PRINT_IGNORED_OPTIONS
-  else
-    g_warning ("CUPS Backend: Ignoring pickmany setting %s\n", ppd_option->text);
-#endif  
-  
-  if (option)
-    {
-      char *name;
-
-      name = ppd_group_name (toplevel_group);
-      if (STRING_IN_TABLE (name,
-			   color_group_whitelist) ||
-	  STRING_IN_TABLE (ppd_option->keyword,
-			   color_option_whitelist))
-	{
-	  option->group = g_strdup ("ColorPage");
-	}
-      else if (STRING_IN_TABLE (name,
-				image_quality_group_whitelist) ||
-	       STRING_IN_TABLE (ppd_option->keyword,
-				image_quality_option_whitelist))
-	{
-	  option->group = g_strdup ("ImageQualityPage");
-	}
-      else if (STRING_IN_TABLE (name,
-				finishing_group_whitelist) ||
-	       STRING_IN_TABLE (ppd_option->keyword,
-				finishing_option_whitelist))
-	{
-	  option->group = g_strdup ("FinishingPage");
-	}
-      else
-	{
-	  for (i = 0; i < G_N_ELEMENTS (cups_group_translations); i++)
-	    {
-	      if (strcmp (cups_group_translations[i].name, toplevel_group->name) == 0)
-		{
-		  option->group = g_strdup (_(cups_group_translations[i].translation));
-		  break;
-		}
-	    }
-
-	  if (i == G_N_ELEMENTS (cups_group_translations))
-	    option->group = g_strdup (toplevel_group->text);
-	}
-
-      set_option_from_settings (option, settings);
-      
-      gtk_printer_option_set_add (set, option);
-    }
-  
-  g_free (name);
-}
-
-static void
-handle_group (GtkPrinterOptionSet *set,
-	      ppd_file_t          *ppd_file,
-	      ppd_group_t         *group,
-	      ppd_group_t         *toplevel_group,
-	      GtkPrintSettings    *settings)
-{
-  gint i;
-  gchar *name;
-  
-  /* Ignore installable options */
-  name = ppd_group_name (toplevel_group);
-  if (strcmp (name, "InstallableOptions") == 0)
-    return;
-  
-  for (i = 0; i < group->num_options; i++)
-    handle_option (set, ppd_file, &group->options[i], toplevel_group, settings);
-
-  for (i = 0; i < group->num_subgroups; i++)
-    handle_group (set, ppd_file, &group->subgroups[i], toplevel_group, settings);
-
-}
-
-static GtkPrinterOptionSet *
-cups_printer_get_options (GtkPrinter           *printer,
-			  GtkPrintSettings     *settings,
-			  GtkPageSetup         *page_setup,
-			  GtkPrintCapabilities  capabilities)
-{
-  GtkPrinterOptionSet *set;
-  GtkPrinterOption *option;
-  ppd_file_t *ppd_file;
-  int i;
-  char *print_at[] = { "now", "at", "on-hold" };
-  char *n_up[] = {"1", "2", "4", "6", "9", "16" };
-  char *prio[] = {"100", "80", "50", "30" };
-  /* Translators: These strings name the possible values of the 
-   * job priority option in the print dialog
-   */
-  char *prio_display[] = {N_("Urgent"), N_("High"), N_("Medium"), N_("Low") };
-  char *n_up_layout[] = { "lrtb", "lrbt", "rltb", "rlbt", "tblr", "tbrl", "btlr", "btrl" };
-  /* Translators: These strings name the possible arrangements of
-   * multiple pages on a sheet when printing
-   */
-  char *n_up_layout_display[] = { N_("Left to right, top to bottom"), N_("Left to right, bottom to top"), 
-                                  N_("Right to left, top to bottom"), N_("Right to left, bottom to top"), 
-                                  N_("Top to bottom, left to right"), N_("Top to bottom, right to left"), 
-                                  N_("Bottom to top, left to right"), N_("Bottom to top, right to left") };
-  char *name;
-  int num_opts;
-  cups_option_t *opts = NULL;
-  GtkPrintBackendCups *backend;
-  GtkTextDirection text_direction;
-  GtkPrinterCups *cups_printer = NULL;
-
-
-  set = gtk_printer_option_set_new ();
-
-  /* Cups specific, non-ppd related settings */
-
-   /* Translators, this string is used to label the pages-per-sheet option 
-    * in the print dialog 
-    */
-  option = gtk_printer_option_new ("gtk-n-up", _("Pages per Sheet"), GTK_PRINTER_OPTION_TYPE_PICKONE);
-  gtk_printer_option_choices_from_array (option, G_N_ELEMENTS (n_up),
-					 n_up, n_up);
-  gtk_printer_option_set (option, "1");
-  set_option_from_settings (option, settings);
-  gtk_printer_option_set_add (set, option);
-  g_object_unref (option);
-
-  if (cups_printer_get_capabilities (printer) & GTK_PRINT_CAPABILITY_NUMBER_UP_LAYOUT)
-    {
-      for (i = 0; i < G_N_ELEMENTS (n_up_layout_display); i++)
-        n_up_layout_display[i] = _(n_up_layout_display[i]);
-  
-       /* Translators, this string is used to label the option in the print 
-        * dialog that controls in what order multiple pages are arranged 
-        */
-      option = gtk_printer_option_new ("gtk-n-up-layout", _("Page Ordering"), GTK_PRINTER_OPTION_TYPE_PICKONE);
-      gtk_printer_option_choices_from_array (option, G_N_ELEMENTS (n_up_layout),
-                                             n_up_layout, n_up_layout_display);
-
-      text_direction = gtk_widget_get_default_direction ();
-      if (text_direction == GTK_TEXT_DIR_LTR)
-        gtk_printer_option_set (option, "lrtb");
-      else
-        gtk_printer_option_set (option, "rltb");
-
-      set_option_from_settings (option, settings);
-      gtk_printer_option_set_add (set, option);
-      g_object_unref (option);
-    }
-
-  for (i = 0; i < G_N_ELEMENTS(prio_display); i++)
-    prio_display[i] = _(prio_display[i]);
-  
-  /* Translators, this string is used to label the job priority option 
-   * in the print dialog 
-   */
-  option = gtk_printer_option_new ("gtk-job-prio", _("Job Priority"), GTK_PRINTER_OPTION_TYPE_PICKONE);
-  gtk_printer_option_choices_from_array (option, G_N_ELEMENTS (prio),
-					 prio, prio_display);
-  gtk_printer_option_set (option, "50");
-  set_option_from_settings (option, settings);
-  gtk_printer_option_set_add (set, option);
-  g_object_unref (option);
-
-  /* Translators, this string is used to label the billing info entry
-   * in the print dialog 
-   */
-  option = gtk_printer_option_new ("gtk-billing-info", _("Billing Info"), GTK_PRINTER_OPTION_TYPE_STRING);
-  gtk_printer_option_set (option, "");
-  set_option_from_settings (option, settings);
-  gtk_printer_option_set_add (set, option);
-  g_object_unref (option);
-
-  backend = GTK_PRINT_BACKEND_CUPS (gtk_printer_get_backend (printer));
-  cups_printer = GTK_PRINTER_CUPS (printer);
-
-  if (backend != NULL && printer != NULL)
-    {
-      char *cover_default[] = {"none", "classified", "confidential", "secret", "standard", "topsecret", "unclassified" };
-      /* Translators, these strings are names for various 'standard' cover 
-       * pages that the printing system may support.
-       */
-      char *cover_display_default[] = {N_("None"), N_("Classified"), N_("Confidential"), N_("Secret"), N_("Standard"), N_("Top Secret"), N_("Unclassified"),};
-      char **cover = NULL;
-      char **cover_display = NULL;
-      char **cover_display_translated = NULL;
-      gint num_of_covers = 0;
-      gpointer value;
-      gint j;
-
-      num_of_covers = backend->number_of_covers;
-      cover = g_new (char *, num_of_covers + 1);
-      cover[num_of_covers] = NULL;
-      cover_display = g_new (char *, num_of_covers + 1);
-      cover_display[num_of_covers] = NULL;
-      cover_display_translated = g_new (char *, num_of_covers + 1);
-      cover_display_translated[num_of_covers] = NULL;
-
-      for (i = 0; i < num_of_covers; i++)
-        {
-          cover[i] = g_strdup (backend->covers[i]);
-          value = NULL;
-          for (j = 0; j < G_N_ELEMENTS (cover_default); j++)
-            if (strcmp (cover_default[j], cover[i]) == 0)
-              {
-                value = cover_display_default[j];
-                break;
-              }
-          cover_display[i] = (value != NULL) ? g_strdup (value) : g_strdup (backend->covers[i]);
-        }
-
-      for (i = 0; i < num_of_covers; i++)
-        cover_display_translated[i] = _(cover_display[i]);
-  
-      /* Translators, this is the label used for the option in the print 
-       * dialog that controls the front cover page.
-       */
-      option = gtk_printer_option_new ("gtk-cover-before", _("Before"), GTK_PRINTER_OPTION_TYPE_PICKONE);
-      gtk_printer_option_choices_from_array (option, num_of_covers,
-					 cover, cover_display_translated);
-
-      if (cups_printer->default_cover_before != NULL)
-        gtk_printer_option_set (option, cups_printer->default_cover_before);
-      else
-        gtk_printer_option_set (option, "none");
-      set_option_from_settings (option, settings);
-      gtk_printer_option_set_add (set, option);
-      g_object_unref (option);
-
-      /* Translators, this is the label used for the option in the print 
-       * dialog that controls the back cover page.
-       */
-      option = gtk_printer_option_new ("gtk-cover-after", _("After"), GTK_PRINTER_OPTION_TYPE_PICKONE);
-      gtk_printer_option_choices_from_array (option, num_of_covers,
-					 cover, cover_display_translated);
-      if (cups_printer->default_cover_after != NULL)
-        gtk_printer_option_set (option, cups_printer->default_cover_after);
-      else
-        gtk_printer_option_set (option, "none");
-      set_option_from_settings (option, settings);
-      gtk_printer_option_set_add (set, option);
-      g_object_unref (option);
-
-      g_strfreev (cover);
-      g_strfreev (cover_display);
-      g_free (cover_display_translated);
-    }
-
-  /* Translators: this is the name of the option that controls when
-   * a print job is printed. Possible values are 'now', a specified time,
-   * or 'on hold'
-   */
-  option = gtk_printer_option_new ("gtk-print-time", _("Print at"), GTK_PRINTER_OPTION_TYPE_PICKONE);
-  gtk_printer_option_choices_from_array (option, G_N_ELEMENTS (print_at),
-					 print_at, print_at);
-  gtk_printer_option_set (option, "now");
-  set_option_from_settings (option, settings);
-  gtk_printer_option_set_add (set, option);
-  g_object_unref (option);
-  
-  /* Translators: this is the name of the option that allows the user
-   * to specify a time when a print job will be printed.
-   */
-  option = gtk_printer_option_new ("gtk-print-time-text", _("Print at time"), GTK_PRINTER_OPTION_TYPE_STRING);
-  gtk_printer_option_set (option, "");
-  set_option_from_settings (option, settings);
-  gtk_printer_option_set_add (set, option);
-  g_object_unref (option);
-  
-  /* Printer (ppd) specific settings */
-  ppd_file = gtk_printer_cups_get_ppd (GTK_PRINTER_CUPS (printer));
-  if (ppd_file)
-    {
-      GtkPaperSize *paper_size;
-      ppd_option_t *option;
-      const gchar  *ppd_name;
-
-      ppdMarkDefaults (ppd_file);
-
-      paper_size = gtk_page_setup_get_paper_size (page_setup);
-
-      option = ppdFindOption (ppd_file, "PageSize");
-      if (option)
-        {
-          ppd_name = gtk_paper_size_get_ppd_name (paper_size);
-
-          if (ppd_name)
-            strncpy (option->defchoice, ppd_name, PPD_MAX_NAME);
-          else
-            {
-              gchar *custom_name;
-              char width[G_ASCII_DTOSTR_BUF_SIZE];
-              char height[G_ASCII_DTOSTR_BUF_SIZE];
-
-              g_ascii_formatd (width, sizeof (width), "%.2f",
-                               gtk_paper_size_get_width (paper_size,
-                                                         GTK_UNIT_POINTS));
-              g_ascii_formatd (height, sizeof (height), "%.2f",
-                               gtk_paper_size_get_height (paper_size,
-                                                          GTK_UNIT_POINTS));
-              /* Translators: this format is used to display a custom
-               * paper size. The two placeholders are replaced with
-               * the width and height in points. E.g: "Custom
-               * 230.4x142.9"
-               */
-              custom_name = g_strdup_printf (_("Custom %sx%s"), width, height);
-              strncpy (option->defchoice, custom_name, PPD_MAX_NAME);
-              g_free (custom_name);
-            }
-        }
-
-      for (i = 0; i < ppd_file->num_groups; i++)
-        handle_group (set, ppd_file, &ppd_file->groups[i], &ppd_file->groups[i], settings);
-    }
-
-  /* Now honor the user set defaults for this printer */
-  num_opts = cups_get_user_options (gtk_printer_get_name (printer), 0, &opts);
-
-  for (i = 0; i < num_opts; i++)
-    {
-      if (STRING_IN_TABLE (opts[i].name, cups_option_blacklist))
-        continue;
-
-      name = get_lpoption_name (opts[i].name);
-      if (strcmp (name, "cups-job-sheets") == 0)
-        {
-          gchar **values;
-          gint    num_values;
-          
-          values = g_strsplit (opts[i].value, ",", 2);
-          num_values = g_strv_length (values);
-
-          option = gtk_printer_option_set_lookup (set, "gtk-cover-before");
-          if (option && num_values > 0)
-            gtk_printer_option_set (option, g_strstrip (values[0]));
-
-          option = gtk_printer_option_set_lookup (set, "gtk-cover-after");
-          if (option && num_values > 1)
-            gtk_printer_option_set (option, g_strstrip (values[1]));
-
-          g_strfreev (values);
-        }
-      else if (strcmp (name, "cups-job-hold-until") == 0)
-        {
-          GtkPrinterOption *option2 = NULL;
-
-          option = gtk_printer_option_set_lookup (set, "gtk-print-time-text");
-          if (option && opts[i].value)
-            {
-              option2 = gtk_printer_option_set_lookup (set, "gtk-print-time");
-              if (option2)
-                {
-                  if (strcmp (opts[i].value, "indefinite") == 0)
-                    gtk_printer_option_set (option2, "on-hold");
-                  else
-                    {
-                      gtk_printer_option_set (option2, "at");
-                      gtk_printer_option_set (option, opts[i].value);
-                    }
-                }
-            }
-        }
-      else if (strcmp (name, "cups-sides") == 0)
-        {
-          option = gtk_printer_option_set_lookup (set, "gtk-duplex");
-          if (option && opts[i].value)
-            {
-              if (strcmp (opts[i].value, "two-sided-short-edge") == 0)
-                gtk_printer_option_set (option, "DuplexTumble");
-              else if (strcmp (opts[i].value, "two-sided-long-edge") == 0)
-                gtk_printer_option_set (option, "DuplexNoTumble");
-            }
-        }
-      else
-        {
-          option = gtk_printer_option_set_lookup (set, name);
-          if (option)
-            gtk_printer_option_set (option, opts[i].value);
-        }
-      g_free (name);
-    }
-
-  cupsFreeOptions (num_opts, opts);
-
-  return set;
-}
-
-
-static void
-mark_option_from_set (GtkPrinterOptionSet *set,
-		      ppd_file_t          *ppd_file,
-		      ppd_option_t        *ppd_option)
-{
-  GtkPrinterOption *option;
-  char *name = get_ppd_option_name (ppd_option->keyword);
-
-  option = gtk_printer_option_set_lookup (set, name);
-
-  if (option)
-    ppdMarkOption (ppd_file, ppd_option->keyword, option->value);
-  
-  g_free (name);
-}
-
-
-static void
-mark_group_from_set (GtkPrinterOptionSet *set,
-		     ppd_file_t          *ppd_file,
-		     ppd_group_t         *group)
-{
-  int i;
-
-  for (i = 0; i < group->num_options; i++)
-    mark_option_from_set (set, ppd_file, &group->options[i]);
-
-  for (i = 0; i < group->num_subgroups; i++)
-    mark_group_from_set (set, ppd_file, &group->subgroups[i]);
-}
-
-static void
-set_conflicts_from_option (GtkPrinterOptionSet *set,
-			   ppd_file_t          *ppd_file,
-			   ppd_option_t        *ppd_option)
-{
-  GtkPrinterOption *option;
-  char *name;
-
-  if (ppd_option->conflicted)
-    {
-      name = get_ppd_option_name (ppd_option->keyword);
-      option = gtk_printer_option_set_lookup (set, name);
-
-      if (option)
-	gtk_printer_option_set_has_conflict (option, TRUE);
-#ifdef PRINT_IGNORED_OPTIONS
-      else
-	g_warning ("CUPS Backend: Ignoring conflict for option %s", ppd_option->keyword);
-#endif
-      
-      g_free (name);
-    }
-}
-
-static void
-set_conflicts_from_group (GtkPrinterOptionSet *set,
-			  ppd_file_t          *ppd_file,
-			  ppd_group_t         *group)
-{
-  int i;
-
-  for (i = 0; i < group->num_options; i++)
-    set_conflicts_from_option (set, ppd_file, &group->options[i]);
-
-  for (i = 0; i < group->num_subgroups; i++)
-    set_conflicts_from_group (set, ppd_file, &group->subgroups[i]);
-}
-
-static gboolean
-cups_printer_mark_conflicts (GtkPrinter          *printer,
-			     GtkPrinterOptionSet *options)
-{
-  ppd_file_t *ppd_file;
-  int num_conflicts;
-  int i;
- 
-  ppd_file = gtk_printer_cups_get_ppd (GTK_PRINTER_CUPS (printer));
-
-  if (ppd_file == NULL)
-    return FALSE;
-
-  ppdMarkDefaults (ppd_file);
-
-  for (i = 0; i < ppd_file->num_groups; i++)
-    mark_group_from_set (options, ppd_file, &ppd_file->groups[i]);
-
-  num_conflicts = ppdConflicts (ppd_file);
-
-  if (num_conflicts > 0)
-    {
-      for (i = 0; i < ppd_file->num_groups; i++)
-	set_conflicts_from_group (options, ppd_file, &ppd_file->groups[i]);
-    }
- 
-  return num_conflicts > 0;
-}
-
-struct OptionData {
-  GtkPrinter *printer;
-  GtkPrinterOptionSet *options;
-  GtkPrintSettings *settings;
-  ppd_file_t *ppd_file;
-};
-
-typedef struct {
-  const char *cups;
-  const char *standard;
-} NameMapping;
-
-static void
-map_settings_to_option (GtkPrinterOption  *option,
-			const NameMapping  table[],
-			gint               n_elements,
-			GtkPrintSettings  *settings,
-			const gchar       *standard_name,
-			const gchar       *cups_name)
-{
-  int i;
-  char *name;
-  const char *cups_value;
-  const char *standard_value;
-
-  /* If the cups-specific setting is set, always use that */
-  name = g_strdup_printf ("cups-%s", cups_name);
-  cups_value = gtk_print_settings_get (settings, name);
-  g_free (name);
-  
-  if (cups_value != NULL) 
-    {
-      gtk_printer_option_set (option, cups_value);
-      return;
-    }
-
-  /* Otherwise we try to convert from the general setting */
-  standard_value = gtk_print_settings_get (settings, standard_name);
-  if (standard_value == NULL)
-    return;
-
-  for (i = 0; i < n_elements; i++)
-    {
-      if (table[i].cups == NULL && table[i].standard == NULL)
-	{
-	  gtk_printer_option_set (option, standard_value);
-	  break;
-	}
-      else if (table[i].cups == NULL &&
-	       strcmp (table[i].standard, standard_value) == 0)
-	{
-	  set_option_off (option);
-	  break;
-	}
-      else if (strcmp (table[i].standard, standard_value) == 0)
-	{
-	  gtk_printer_option_set (option, table[i].cups);
-	  break;
-	}
-    }
-}
-
-static void
-map_option_to_settings (const gchar       *value,
-			const NameMapping  table[],
-			gint               n_elements,
-			GtkPrintSettings  *settings,
-			const gchar       *standard_name,
-			const gchar       *cups_name)
-{
-  int i;
-  char *name;
-
-  for (i = 0; i < n_elements; i++)
-    {
-      if (table[i].cups == NULL && table[i].standard == NULL)
-	{
-	  gtk_print_settings_set (settings,
-				  standard_name,
-				  value);
-	  break;
-	}
-      else if (table[i].cups == NULL && table[i].standard != NULL)
-	{
-	  if (value_is_off (value))
-	    {
-	      gtk_print_settings_set (settings,
-				      standard_name,
-				      table[i].standard);
-	      break;
-	    }
-	}
-      else if (strcmp (table[i].cups, value) == 0)
-	{
-	  gtk_print_settings_set (settings,
-				  standard_name,
-				  table[i].standard);
-	  break;
-	}
-    }
-
-  /* Always set the corresponding cups-specific setting */
-  name = g_strdup_printf ("cups-%s", cups_name);
-  gtk_print_settings_set (settings, name, value);
-  g_free (name);
-}
-
-
-static const NameMapping paper_source_map[] = {
-  { "Lower", "lower"},
-  { "Middle", "middle"},
-  { "Upper", "upper"},
-  { "Rear", "rear"},
-  { "Envelope", "envelope"},
-  { "Cassette", "cassette"},
-  { "LargeCapacity", "large-capacity"},
-  { "AnySmallFormat", "small-format"},
-  { "AnyLargeFormat", "large-format"},
-  { NULL, NULL}
-};
-
-static const NameMapping output_tray_map[] = {
-  { "Upper", "upper"},
-  { "Lower", "lower"},
-  { "Rear", "rear"},
-  { NULL, NULL}
-};
-
-static const NameMapping duplex_map[] = {
-  { "DuplexTumble", "vertical" },
-  { "DuplexNoTumble", "horizontal" },
-  { NULL, "simplex" }
-};
-
-static const NameMapping output_mode_map[] = {
-  { "Standard", "normal" },
-  { "Normal", "normal" },
-  { "Draft", "draft" },
-  { "Fast", "draft" },
-};
-
-static const NameMapping media_type_map[] = {
-  { "Transparency", "transparency"},
-  { "Standard", "stationery"},
-  { NULL, NULL}
-};
-
-static const NameMapping all_map[] = {
-  { NULL, NULL}
-};
-
-
-static void
-set_option_from_settings (GtkPrinterOption *option,
-			  GtkPrintSettings *settings)
-{
-  const char *cups_value;
-  char *value;
-  
-  if (settings == NULL)
-    return;
-
-  if (strcmp (option->name, "gtk-paper-source") == 0)
-    map_settings_to_option (option, paper_source_map, G_N_ELEMENTS (paper_source_map),
-			     settings, GTK_PRINT_SETTINGS_DEFAULT_SOURCE, "InputSlot");
-  else if (strcmp (option->name, "gtk-output-tray") == 0)
-    map_settings_to_option (option, output_tray_map, G_N_ELEMENTS (output_tray_map),
-			    settings, GTK_PRINT_SETTINGS_OUTPUT_BIN, "OutputBin");
-  else if (strcmp (option->name, "gtk-duplex") == 0)
-    map_settings_to_option (option, duplex_map, G_N_ELEMENTS (duplex_map),
-			    settings, GTK_PRINT_SETTINGS_DUPLEX, "Duplex");
-  else if (strcmp (option->name, "cups-OutputMode") == 0)
-    map_settings_to_option (option, output_mode_map, G_N_ELEMENTS (output_mode_map),
-			    settings, GTK_PRINT_SETTINGS_QUALITY, "OutputMode");
-  else if (strcmp (option->name, "cups-Resolution") == 0)
-    {
-      cups_value = gtk_print_settings_get (settings, option->name);
-      if (cups_value)
-	gtk_printer_option_set (option, cups_value);
-      else
-	{
-	  int res = gtk_print_settings_get_resolution (settings);
-	  int res_x = gtk_print_settings_get_resolution_x (settings);
-	  int res_y = gtk_print_settings_get_resolution_y (settings);
-
-          if (res_x != res_y)
-            {
-	      value = g_strdup_printf ("%dx%ddpi", res_x, res_y);
-	      gtk_printer_option_set (option, value);
-	      g_free (value);
-            }
-          else if (res != 0)
-	    {
-	      value = g_strdup_printf ("%ddpi", res);
-	      gtk_printer_option_set (option, value);
-	      g_free (value);
-	    }
-	}
-    }
-  else if (strcmp (option->name, "gtk-paper-type") == 0)
-    map_settings_to_option (option, media_type_map, G_N_ELEMENTS (media_type_map),
-			    settings, GTK_PRINT_SETTINGS_MEDIA_TYPE, "MediaType");
-  else if (strcmp (option->name, "gtk-n-up") == 0)
-    {
-      map_settings_to_option (option, all_map, G_N_ELEMENTS (all_map),
-			      settings, GTK_PRINT_SETTINGS_NUMBER_UP, "number-up");
-    }
-  else if (strcmp (option->name, "gtk-n-up-layout") == 0)
-    {
-      map_settings_to_option (option, all_map, G_N_ELEMENTS (all_map),
-			      settings, GTK_PRINT_SETTINGS_NUMBER_UP_LAYOUT, "number-up-layout");
-    }
-  else if (strcmp (option->name, "gtk-billing-info") == 0)
-    {
-      cups_value = gtk_print_settings_get (settings, "cups-job-billing");
-      if (cups_value)
-	gtk_printer_option_set (option, cups_value);
-    } 
-  else if (strcmp (option->name, "gtk-job-prio") == 0)
-    {
-      cups_value = gtk_print_settings_get (settings, "cups-job-priority");
-      if (cups_value)
-	gtk_printer_option_set (option, cups_value);
-    } 
-  else if (strcmp (option->name, "gtk-cover-before") == 0)
-    {
-      cups_value = gtk_print_settings_get (settings, "cover-before");
-      if (cups_value)
-	gtk_printer_option_set (option, cups_value);
-    } 
-  else if (strcmp (option->name, "gtk-cover-after") == 0)
-    {
-      cups_value = gtk_print_settings_get (settings, "cover-after");
-      if (cups_value)
-	gtk_printer_option_set (option, cups_value);
-    } 
-  else if (strcmp (option->name, "gtk-print-time") == 0)
-    {
-      cups_value = gtk_print_settings_get (settings, "print-at");
-      if (cups_value)
-	gtk_printer_option_set (option, cups_value);
-    } 
-  else if (strcmp (option->name, "gtk-print-time-text") == 0)
-    {
-      cups_value = gtk_print_settings_get (settings, "print-at-time");
-      if (cups_value)
-	gtk_printer_option_set (option, cups_value);
-    } 
-  else if (g_str_has_prefix (option->name, "cups-"))
-    {
-      cups_value = gtk_print_settings_get (settings, option->name);
-      if (cups_value)
-	gtk_printer_option_set (option, cups_value);
-    } 
-}
-
-static void
-foreach_option_get_settings (GtkPrinterOption *option,
-			     gpointer          user_data)
-{
-  struct OptionData *data = user_data;
-  GtkPrintSettings *settings = data->settings;
-  const char *value;
-
-  value = option->value;
-
-  if (strcmp (option->name, "gtk-paper-source") == 0)
-    map_option_to_settings (value, paper_source_map, G_N_ELEMENTS (paper_source_map),
-			    settings, GTK_PRINT_SETTINGS_DEFAULT_SOURCE, "InputSlot");
-  else if (strcmp (option->name, "gtk-output-tray") == 0)
-    map_option_to_settings (value, output_tray_map, G_N_ELEMENTS (output_tray_map),
-			    settings, GTK_PRINT_SETTINGS_OUTPUT_BIN, "OutputBin");
-  else if (strcmp (option->name, "gtk-duplex") == 0)
-    map_option_to_settings (value, duplex_map, G_N_ELEMENTS (duplex_map),
-			    settings, GTK_PRINT_SETTINGS_DUPLEX, "Duplex");
-  else if (strcmp (option->name, "cups-OutputMode") == 0)
-    map_option_to_settings (value, output_mode_map, G_N_ELEMENTS (output_mode_map),
-			    settings, GTK_PRINT_SETTINGS_QUALITY, "OutputMode");
-  else if (strcmp (option->name, "cups-Resolution") == 0)
-    {
-      int res, res_x, res_y;
-
-      if (sscanf (value, "%dx%ddpi", &res_x, &res_y) == 2)
-        {
-          if (res_x > 0 && res_y > 0)
-            gtk_print_settings_set_resolution_xy (settings, res_x, res_y);
-        }
-      else if (sscanf (value, "%ddpi", &res) == 1)
-        {
-          if (res > 0)
-            gtk_print_settings_set_resolution (settings, res);
-        }
-
-      gtk_print_settings_set (settings, option->name, value);
-    }
-  else if (strcmp (option->name, "gtk-paper-type") == 0)
-    map_option_to_settings (value, media_type_map, G_N_ELEMENTS (media_type_map),
-			    settings, GTK_PRINT_SETTINGS_MEDIA_TYPE, "MediaType");
-  else if (strcmp (option->name, "gtk-n-up") == 0)
-    map_option_to_settings (value, all_map, G_N_ELEMENTS (all_map),
-			    settings, GTK_PRINT_SETTINGS_NUMBER_UP, "number-up");
-  else if (strcmp (option->name, "gtk-n-up-layout") == 0)
-    map_option_to_settings (value, all_map, G_N_ELEMENTS (all_map),
-			    settings, GTK_PRINT_SETTINGS_NUMBER_UP_LAYOUT, "number-up-layout");
-  else if (strcmp (option->name, "gtk-billing-info") == 0 && strlen (value) > 0)
-    gtk_print_settings_set (settings, "cups-job-billing", value);
-  else if (strcmp (option->name, "gtk-job-prio") == 0)
-    gtk_print_settings_set (settings, "cups-job-priority", value);
-  else if (strcmp (option->name, "gtk-cover-before") == 0)
-    gtk_print_settings_set (settings, "cover-before", value);
-  else if (strcmp (option->name, "gtk-cover-after") == 0)
-    gtk_print_settings_set (settings, "cover-after", value);
-  else if (strcmp (option->name, "gtk-print-time") == 0)
-    gtk_print_settings_set (settings, "print-at", value);
-  else if (strcmp (option->name, "gtk-print-time-text") == 0)
-    gtk_print_settings_set (settings, "print-at-time", value);
-  else if (g_str_has_prefix (option->name, "cups-"))
-    gtk_print_settings_set (settings, option->name, value);
-}
-
-static gboolean
-supports_am_pm (void)
-{
-  struct tm tmp_tm = { 0 };
-  char   time[8];
-  int    length;
-
-  length = strftime (time, sizeof (time), "%p", &tmp_tm);
-
-  return length != 0;
-}
-
-/* Converts local time to UTC time. Local time has to be in one of these
- * formats:  HH:MM:SS, HH:MM, HH:MM:SS {am, pm}, HH:MM {am, pm}, HH {am, pm},
- * {am, pm} HH:MM:SS, {am, pm} HH:MM, {am, pm} HH.
- * Returns a newly allocated string holding UTC time in HH:MM:SS format
- * or NULL.
- */
-gchar *
-localtime_to_utctime (const char *local_time)
-{
-  const char *formats_0[] = {" %I : %M : %S %p ", " %p %I : %M : %S ",
-                             " %H : %M : %S ",
-                             " %I : %M %p ", " %p %I : %M ",
-                             " %H : %M ",
-                             " %I %p ", " %p %I "};
-  const char *formats_1[] = {" %H : %M : %S ", " %H : %M "};
-  const char *end = NULL;
-  struct tm  *actual_local_time;
-  struct tm  *actual_utc_time;
-  struct tm   local_print_time;
-  struct tm   utc_print_time;
-  struct tm   diff_time;
-  gchar      *utc_time = NULL;
-  int         i, n;
-
-  if (local_time == NULL || local_time[0] == '\0')
-    return NULL;
-
-  n = supports_am_pm () ? G_N_ELEMENTS (formats_0) : G_N_ELEMENTS (formats_1);
-
-  for (i = 0; i < n; i++)
-    {
-      local_print_time.tm_hour = 0;
-      local_print_time.tm_min  = 0;
-      local_print_time.tm_sec  = 0;
-
-      if (supports_am_pm ())
-        end = strptime (local_time, formats_0[i], &local_print_time);
-      else
-        end = strptime (local_time, formats_1[i], &local_print_time);
-
-      if (end != NULL && end[0] == '\0')
-        break;
-    }
-
-  if (end != NULL && end[0] == '\0')
-    {
-      time_t rawtime;
-      time (&rawtime);
-
-      actual_utc_time = g_memdup2 (gmtime (&rawtime), sizeof (struct tm));
-      actual_local_time = g_memdup2 (localtime (&rawtime), sizeof (struct tm));
-
-      diff_time.tm_hour = actual_utc_time->tm_hour - actual_local_time->tm_hour;
-      diff_time.tm_min  = actual_utc_time->tm_min  - actual_local_time->tm_min;
-      diff_time.tm_sec  = actual_utc_time->tm_sec  - actual_local_time->tm_sec;
-
-      utc_print_time.tm_hour = ((local_print_time.tm_hour + diff_time.tm_hour) + 24) % 24;
-      utc_print_time.tm_min  = ((local_print_time.tm_min  + diff_time.tm_min)  + 60) % 60;
-      utc_print_time.tm_sec  = ((local_print_time.tm_sec  + diff_time.tm_sec)  + 60) % 60;
-
-      utc_time = g_strdup_printf ("%02d:%02d:%02d",
-                                  utc_print_time.tm_hour,
-                                  utc_print_time.tm_min,
-                                  utc_print_time.tm_sec);
-    }
-
-  return utc_time;
-}
-
-static void
-cups_printer_get_settings_from_options (GtkPrinter          *printer,
-					GtkPrinterOptionSet *options,
-					GtkPrintSettings    *settings)
-{
-  struct OptionData data;
-  const char *print_at, *print_at_time;
-
-  data.printer = printer;
-  data.options = options;
-  data.settings = settings;
-  data.ppd_file = gtk_printer_cups_get_ppd (GTK_PRINTER_CUPS (printer));
- 
-  gtk_printer_option_set_foreach (options, foreach_option_get_settings, &data);
-  if (data.ppd_file != NULL)
-    {
-      GtkPrinterOption *cover_before, *cover_after;
-
-      cover_before = gtk_printer_option_set_lookup (options, "gtk-cover-before");
-      cover_after = gtk_printer_option_set_lookup (options, "gtk-cover-after");
-      if (cover_before && cover_after)
-	{
-	  char *value = g_strdup_printf ("%s,%s", cover_before->value, cover_after->value);
-	  gtk_print_settings_set (settings, "cups-job-sheets", value);
-	  g_free (value);
-	}
-
-      print_at = gtk_print_settings_get (settings, "print-at");
-      print_at_time = gtk_print_settings_get (settings, "print-at-time");
-
-      if (strcmp (print_at, "at") == 0)
-        {
-          gchar *utc_time = NULL;
-          
-          utc_time = localtime_to_utctime (print_at_time);
-
-          if (utc_time != NULL)
-            {
-              gtk_print_settings_set (settings, "cups-job-hold-until", utc_time);
-              g_free (utc_time);
-            }
-          else
-            gtk_print_settings_set (settings, "cups-job-hold-until", print_at_time);
-        }
-      else if (strcmp (print_at, "on-hold") == 0)
-	gtk_print_settings_set (settings, "cups-job-hold-until", "indefinite");
-    }
-}
-
-static void
-cups_printer_prepare_for_print (GtkPrinter       *printer,
-				GtkPrintJob      *print_job,
-				GtkPrintSettings *settings,
-				GtkPageSetup     *page_setup)
-{
-  GtkPageSet page_set;
-  GtkPaperSize *paper_size;
-  const char *ppd_paper_name;
-  double scale;
-  GtkPrintCapabilities  capabilities;
-
-  capabilities = cups_printer_get_capabilities (printer);
-  print_job->print_pages = gtk_print_settings_get_print_pages (settings);
-  print_job->page_ranges = NULL;
-  print_job->num_page_ranges = 0;
-  
-  if (print_job->print_pages == GTK_PRINT_PAGES_RANGES)
-    print_job->page_ranges =
-      gtk_print_settings_get_page_ranges (settings,
-					  &print_job->num_page_ranges);
-  
-  if (capabilities & GTK_PRINT_CAPABILITY_COLLATE)
-    {
-      if (gtk_print_settings_get_collate (settings))
-        gtk_print_settings_set (settings, "cups-Collate", "True");
-      print_job->collate = FALSE;
-    }
-  else
-    {
-      print_job->collate = gtk_print_settings_get_collate (settings);
-    }
-
-  if (capabilities & GTK_PRINT_CAPABILITY_REVERSE)
-    {
-      if (gtk_print_settings_get_reverse (settings))
-        gtk_print_settings_set (settings, "cups-OutputOrder", "Reverse");
-      print_job->reverse = FALSE;
-    }
-  else
-    {
-      print_job->reverse = gtk_print_settings_get_reverse (settings);
-    }
-
-  if (capabilities & GTK_PRINT_CAPABILITY_COPIES)
-    {
-      if (gtk_print_settings_get_n_copies (settings) > 1)
-        gtk_print_settings_set_int (settings, "cups-copies",
-                                    gtk_print_settings_get_n_copies (settings));
-      print_job->num_copies = 1;
-    }
-  else
-    {
-      print_job->num_copies = gtk_print_settings_get_n_copies (settings);
-    }
-
-  scale = gtk_print_settings_get_scale (settings);
-  print_job->scale = 1.0;
-  if (scale != 100.0)
-    print_job->scale = scale/100.0;
-
-  page_set = gtk_print_settings_get_page_set (settings);
-  if (page_set == GTK_PAGE_SET_EVEN)
-    gtk_print_settings_set (settings, "cups-page-set", "even");
-  else if (page_set == GTK_PAGE_SET_ODD)
-    gtk_print_settings_set (settings, "cups-page-set", "odd");
-  print_job->page_set = GTK_PAGE_SET_ALL;
-
-  paper_size = gtk_page_setup_get_paper_size (page_setup);
-  ppd_paper_name = gtk_paper_size_get_ppd_name (paper_size);
-  if (ppd_paper_name != NULL)
-    gtk_print_settings_set (settings, "cups-PageSize", ppd_paper_name);
-  else
-    {
-      char width[G_ASCII_DTOSTR_BUF_SIZE];
-      char height[G_ASCII_DTOSTR_BUF_SIZE];
-      char *custom_name;
-
-      g_ascii_formatd (width, sizeof (width), "%.2f", gtk_paper_size_get_width (paper_size, GTK_UNIT_POINTS));
-      g_ascii_formatd (height, sizeof (height), "%.2f", gtk_paper_size_get_height (paper_size, GTK_UNIT_POINTS));
-      custom_name = g_strdup_printf (("Custom.%sx%s"), width, height);
-      gtk_print_settings_set (settings, "cups-PageSize", custom_name);
-      g_free (custom_name);
-    }
-
-  if (gtk_print_settings_get_number_up (settings) > 1)
-    {
-      GtkNumberUpLayout  layout = gtk_print_settings_get_number_up_layout (settings);
-      GEnumClass        *enum_class;
-      GEnumValue        *enum_value;
-
-      switch (gtk_page_setup_get_orientation (page_setup))
-        {
-          case GTK_PAGE_ORIENTATION_PORTRAIT:
-            break;
-          case GTK_PAGE_ORIENTATION_LANDSCAPE:
-            if (layout < 4)
-              layout = layout + 2 + 4 * (1 - layout / 2);
-            else
-              layout = layout - 3 - 2 * (layout % 2);
-            break;
-          case GTK_PAGE_ORIENTATION_REVERSE_PORTRAIT:
-            layout = (layout + 3 - 2 * (layout % 2)) % 4 + 4 * (layout / 4);
-            break;
-          case GTK_PAGE_ORIENTATION_REVERSE_LANDSCAPE:
-            if (layout < 4)
-              layout = layout + 5 - 2 * (layout % 2);
-            else
-              layout = layout - 6 + 4 * (1 - (layout - 4) / 2);
-            break;
-        }
-
-      enum_class = g_type_class_ref (GTK_TYPE_NUMBER_UP_LAYOUT);
-      enum_value = g_enum_get_value (enum_class, layout);
-      gtk_print_settings_set (settings, "cups-number-up-layout", enum_value->value_nick);
-      g_type_class_unref (enum_class);
-
-      if (!(capabilities & GTK_PRINT_CAPABILITY_NUMBER_UP))
-        {
-          print_job->number_up = gtk_print_settings_get_number_up (settings);
-          print_job->number_up_layout = gtk_print_settings_get_number_up_layout (settings);
-        }
-    }
-
-  print_job->rotate_to_orientation = TRUE;
-}
-
-static GtkPageSetup *
-create_page_setup (ppd_file_t *ppd_file,
-		   ppd_size_t *size)
- {
-   char *display_name;
-   GtkPageSetup *page_setup;
-   GtkPaperSize *paper_size;
-   ppd_option_t *option;
-   ppd_choice_t *choice;
-
-  display_name = NULL;
-  option = ppdFindOption (ppd_file, "PageSize");
-  if (option)
-    {
-      choice = ppdFindChoice (option, size->name);
-      if (choice)
-	display_name = ppd_text_to_utf8 (ppd_file, choice->text);
-    }
-
-  if (display_name == NULL)
-    display_name = g_strdup (size->name);
-  
-  page_setup = gtk_page_setup_new ();
-  paper_size = gtk_paper_size_new_from_ppd (size->name,
-					    display_name,
-					    size->width,
-					    size->length);
-  gtk_page_setup_set_paper_size (page_setup, paper_size);
-  gtk_paper_size_free (paper_size);
-  
-  gtk_page_setup_set_top_margin (page_setup, size->length - size->top, GTK_UNIT_POINTS);
-  gtk_page_setup_set_bottom_margin (page_setup, size->bottom, GTK_UNIT_POINTS);
-  gtk_page_setup_set_left_margin (page_setup, size->left, GTK_UNIT_POINTS);
-  gtk_page_setup_set_right_margin (page_setup, size->width - size->right, GTK_UNIT_POINTS);
-  
-  g_free (display_name);
-
-  return page_setup;
-}
-
-static GList *
-cups_printer_list_papers (GtkPrinter *printer)
-{
-  ppd_file_t *ppd_file;
-  ppd_size_t *size;
-  GtkPageSetup *page_setup;
-  GList *l;
-  int i;
-
-  ppd_file = gtk_printer_cups_get_ppd (GTK_PRINTER_CUPS (printer));
-  if (ppd_file == NULL)
-    return NULL;
-
-  l = NULL;
-  
-  for (i = 0; i < ppd_file->num_sizes; i++)
-    {
-      size = &ppd_file->sizes[i];      
-
-      page_setup = create_page_setup (ppd_file, size);
-
-      l = g_list_prepend (l, page_setup);
-    }
-
-  return g_list_reverse (l);
-}
-
-static GtkPageSetup *
-cups_printer_get_default_page_size (GtkPrinter *printer)
-{
-  ppd_file_t *ppd_file;
-  ppd_size_t *size;
-  ppd_option_t *option;
-
-
-  ppd_file = gtk_printer_cups_get_ppd (GTK_PRINTER_CUPS (printer));
-  if (ppd_file == NULL)
-    return NULL;
-
-  option = ppdFindOption (ppd_file, "PageSize");
-  if (option == NULL)
-    return NULL;
-
-  size = ppdPageSize (ppd_file, option->defchoice); 
-  if (size == NULL)
-    return NULL;
-
-  return create_page_setup (ppd_file, size);
-}
-
-static gboolean
-cups_printer_get_hard_margins (GtkPrinter *printer,
-			       gdouble    *top,
-			       gdouble    *bottom,
-			       gdouble    *left,
-			       gdouble    *right)
-{
-  ppd_file_t *ppd_file;
-
-  ppd_file = gtk_printer_cups_get_ppd (GTK_PRINTER_CUPS (printer));
-  if (ppd_file == NULL)
-    return FALSE;
-
-  *left = ppd_file->custom_margins[0];
-  *bottom = ppd_file->custom_margins[1];
-  *right = ppd_file->custom_margins[2];
-  *top = ppd_file->custom_margins[3];
-
-  return TRUE;
-}
-
-static GtkPrintCapabilities
-cups_printer_get_capabilities (GtkPrinter *printer)
-{
-  GtkPrintCapabilities  capabilities = 0;
-  GtkPrinterCups       *cups_printer = GTK_PRINTER_CUPS (printer);
-
-  if (gtk_printer_cups_get_ppd (cups_printer))
-    {
-      capabilities = GTK_PRINT_CAPABILITY_REVERSE;
-    }
-
-  if (cups_printer->supports_copies)
-    {
-      capabilities |= GTK_PRINT_CAPABILITY_COPIES;
-    }
-
-  if (cups_printer->supports_collate)
-    {
-      capabilities |= GTK_PRINT_CAPABILITY_COLLATE;
-    }
-
-  if (cups_printer->supports_number_up)
-    {
-      capabilities |= GTK_PRINT_CAPABILITY_NUMBER_UP;
-#if (CUPS_VERSION_MAJOR == 1 && CUPS_VERSION_MINOR >= 1 && CUPS_VERSION_PATCH >= 15) || (CUPS_VERSION_MAJOR == 1 && CUPS_VERSION_MINOR > 1) || CUPS_VERSION_MAJOR > 1
-      capabilities |= GTK_PRINT_CAPABILITY_NUMBER_UP_LAYOUT;
-#endif
-    }
-
-  return capabilities;
-}
diff --git a/modules/printbackends/cups/gtkprintbackendcups.h b/modules/printbackends/cups/gtkprintbackendcups.h
deleted file mode 100644
index 81c1d98..0000000
--- a/modules/printbackends/cups/gtkprintbackendcups.h
+++ /dev/null
@@ -1,42 +0,0 @@
-/* GTK - The GIMP Toolkit
- * gtkprintbackendcups.h: Default implementation of GtkPrintBackend for the Common Unix Print System (CUPS)
- * Copyright (C) 2006, 2007 Red Hat, Inc.
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-#ifndef __GTK_PRINT_BACKEND_CUPS_H__
-#define __GTK_PRINT_BACKEND_CUPS_H__
-
-#include <glib-object.h>
-#include "gtkprintbackend.h"
-
-G_BEGIN_DECLS
-
-#define GTK_TYPE_PRINT_BACKEND_CUPS             (gtk_print_backend_cups_get_type ())
-#define GTK_PRINT_BACKEND_CUPS(obj)             (G_TYPE_CHECK_INSTANCE_CAST ((obj), GTK_TYPE_PRINT_BACKEND_CUPS, GtkPrintBackendCups))
-#define GTK_IS_PRINT_BACKEND_CUPS(obj)          (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GTK_TYPE_PRINT_BACKEND_CUPS))
-
-typedef struct _GtkPrintBackendCups      GtkPrintBackendCups;
-
-GtkPrintBackend *gtk_print_backend_cups_new      (void);
-GType          gtk_print_backend_cups_get_type (void) G_GNUC_CONST;
-
-G_END_DECLS
-
-#endif /* __GTK_PRINT_BACKEND_CUPS_H__ */
-
-
diff --git a/modules/printbackends/cups/gtkprintercups.c b/modules/printbackends/cups/gtkprintercups.c
deleted file mode 100644
index f957558..0000000
--- a/modules/printbackends/cups/gtkprintercups.c
+++ /dev/null
@@ -1,192 +0,0 @@
-/* GtkPrinterCupsCups
- * Copyright (C) 2006 John (J5) Palmieri  <johnp@redhat.com>
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-#include "config.h"
-#include "gtkprintercups.h"
-
-static void gtk_printer_cups_init       (GtkPrinterCups      *printer);
-static void gtk_printer_cups_class_init (GtkPrinterCupsClass *class);
-static void gtk_printer_cups_finalize   (GObject             *object);
-
-static GtkPrinterClass *gtk_printer_cups_parent_class;
-static GType gtk_printer_cups_type = 0;
-
-void 
-gtk_printer_cups_register_type (GTypeModule *module)
-{
-  const GTypeInfo object_info =
-  {
-    sizeof (GtkPrinterCupsClass),
-    (GBaseInitFunc) NULL,
-    (GBaseFinalizeFunc) NULL,
-    (GClassInitFunc) gtk_printer_cups_class_init,
-    NULL,           /* class_finalize */
-    NULL,           /* class_data */
-    sizeof (GtkPrinterCups),
-    0,              /* n_preallocs */
-    (GInstanceInitFunc) gtk_printer_cups_init,
-  };
-
- gtk_printer_cups_type = g_type_module_register_type (module,
-                                                      GTK_TYPE_PRINTER,
-                                                      "GtkPrinterCups",
-                                                      &object_info, 0);
-}
-
-GType
-gtk_printer_cups_get_type (void)
-{
-  return gtk_printer_cups_type;
-}
-
-static void
-gtk_printer_cups_class_init (GtkPrinterCupsClass *class)
-{
-  GObjectClass *object_class = (GObjectClass *) class;
-	
-  gtk_printer_cups_parent_class = g_type_class_peek_parent (class);
-
-  object_class->finalize = gtk_printer_cups_finalize;
-}
-
-static void
-gtk_printer_cups_init (GtkPrinterCups *printer)
-{
-  printer->device_uri = NULL;
-  printer->printer_uri = NULL;
-  printer->state = 0;
-  printer->hostname = NULL;
-  printer->port = 0;
-  printer->ppd_name = NULL;
-  printer->ppd_file = NULL;
-  printer->default_cover_before = NULL;
-  printer->default_cover_after = NULL;
-  printer->remote = FALSE;
-  printer->get_remote_ppd_poll = 0;
-  printer->get_remote_ppd_attempts = 0;
-  printer->remote_cups_connection_test = NULL;
-  printer->auth_info_required = NULL;
-#ifdef HAVE_CUPS_API_1_6
-  printer->avahi_browsed = FALSE;
-  printer->avahi_name = NULL;
-  printer->avahi_type = NULL;
-  printer->avahi_domain = NULL;
-#endif
-  printer->ipp_version_major = 1;
-  printer->ipp_version_minor = 1;
-  printer->supports_copies = FALSE;
-  printer->supports_collate = FALSE;
-  printer->supports_number_up = FALSE;
-}
-
-static void
-gtk_printer_cups_finalize (GObject *object)
-{
-  GtkPrinterCups *printer;
-
-  g_return_if_fail (object != NULL);
-
-  printer = GTK_PRINTER_CUPS (object);
-
-  g_free (printer->device_uri);
-  g_free (printer->printer_uri);
-  g_free (printer->hostname);
-  g_free (printer->ppd_name);
-  g_free (printer->default_cover_before);
-  g_free (printer->default_cover_after);
-  g_strfreev (printer->auth_info_required);
-
-#ifdef HAVE_CUPS_API_1_6
-  g_free (printer->avahi_name);
-  g_free (printer->avahi_type);
-  g_free (printer->avahi_domain);
-#endif
-
-  if (printer->ppd_file)
-    ppdClose (printer->ppd_file);
-
-  if (printer->get_remote_ppd_poll > 0)
-    g_source_remove (printer->get_remote_ppd_poll);
-  printer->get_remote_ppd_attempts = 0;
-
-  gtk_cups_connection_test_free (printer->remote_cups_connection_test);
-
-  G_OBJECT_CLASS (gtk_printer_cups_parent_class)->finalize (object);
-}
-
-/**
- * gtk_printer_cups_new:
- *
- * Creates a new #GtkPrinterCups.
- *
- * Return value: a new #GtkPrinterCups
- *
- * Since: 2.10
- **/
-GtkPrinterCups *
-gtk_printer_cups_new (const char      *name,
-		      GtkPrintBackend *backend)
-{
-  GObject *result;
-  gboolean accepts_pdf;
-  GtkPrinterCups *printer;
-
-#if (CUPS_VERSION_MAJOR == 1 && CUPS_VERSION_MINOR >= 2) || CUPS_VERSION_MAJOR > 1
-  accepts_pdf = TRUE;
-#else
-  accepts_pdf = FALSE;
-#endif
-
-  result = g_object_new (GTK_TYPE_PRINTER_CUPS,
-			 "name", name,
-			 "backend", backend,
-			 "is-virtual", FALSE,
-			 "accepts-pdf", accepts_pdf,
-                         NULL);
-
-  printer = GTK_PRINTER_CUPS (result);
-
-  /*
-   * IPP version 1.1 has to be supported
-   * by all implementations according to rfc 2911
-   */
-  printer->ipp_version_major = 1;
-  printer->ipp_version_minor = 1;
-
-  return printer;
-}
-
-ppd_file_t *
-gtk_printer_cups_get_ppd (GtkPrinterCups *printer)
-{
-  return printer->ppd_file;
-}
-
-const gchar *
-gtk_printer_cups_get_ppd_name (GtkPrinterCups  *printer)
-{
-  const gchar *result;
-
-  result = printer->ppd_name;
-
-  if (result == NULL)
-    result = gtk_printer_get_name (GTK_PRINTER (printer));
-
-  return result;
-}
diff --git a/modules/printbackends/cups/gtkprintercups.h b/modules/printbackends/cups/gtkprintercups.h
deleted file mode 100644
index d10bd7e..0000000
--- a/modules/printbackends/cups/gtkprintercups.h
+++ /dev/null
@@ -1,93 +0,0 @@
-/* GtkPrinterCups
- * Copyright (C) 2006 John (J5) Palmieri <johnp@redhat.com>
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-#ifndef __GTK_PRINTER_CUPS_H__
-#define __GTK_PRINTER_CUPS_H__
-
-#include <glib-object.h>
-#include <cups/cups.h>
-#include <cups/ppd.h>
-#include "gtkcupsutils.h"
-
-#include <gtk/gtkunixprint.h>
-
-G_BEGIN_DECLS
-
-#define GTK_TYPE_PRINTER_CUPS                  (gtk_printer_cups_get_type ())
-#define GTK_PRINTER_CUPS(obj)                  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GTK_TYPE_PRINTER_CUPS, GtkPrinterCups))
-#define GTK_PRINTER_CUPS_CLASS(klass)          (G_TYPE_CHECK_CLASS_CAST ((klass), GTK_TYPE_PRINTER_CUPS, GtkPrinterCupsClass))
-#define GTK_IS_PRINTER_CUPS(obj)               (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GTK_TYPE_PRINTER_CUPS))
-#define GTK_IS_PRINTER_CUPS_CLASS(klass)       (G_TYPE_CHECK_CLASS_TYPE ((klass), GTK_TYPE_PRINTER_CUPS))
-#define GTK_PRINTER_CUPS_GET_CLASS(obj)        (G_TYPE_INSTANCE_GET_CLASS ((obj), GTK_TYPE_PRINTER_CUPS, GtkPrinterCupsClass))
-
-typedef struct _GtkPrinterCups	        GtkPrinterCups;
-typedef struct _GtkPrinterCupsClass     GtkPrinterCupsClass;
-typedef struct _GtkPrinterCupsPrivate   GtkPrinterCupsPrivate;
-
-struct _GtkPrinterCups
-{
-  GtkPrinter parent_instance;
-
-  gchar *device_uri;
-  gchar *printer_uri;
-  gchar *hostname;
-  gint port;
-  gchar **auth_info_required;
-
-  ipp_pstate_t state;
-  gboolean reading_ppd;
-  gchar      *ppd_name;
-  ppd_file_t *ppd_file;
-
-  gchar  *default_cover_before;
-  gchar  *default_cover_after;
-
-  gboolean remote;
-  guint get_remote_ppd_poll;
-  gint  get_remote_ppd_attempts;
-  GtkCupsConnectionTest *remote_cups_connection_test;
-#ifdef HAVE_CUPS_API_1_6
-  gboolean  avahi_browsed;
-  gchar    *avahi_name;
-  gchar    *avahi_type;
-  gchar    *avahi_domain;
-#endif
-  guchar ipp_version_major;
-  guchar ipp_version_minor;
-  gboolean supports_copies;
-  gboolean supports_collate;
-  gboolean supports_number_up;
-};
-
-struct _GtkPrinterCupsClass
-{
-  GtkPrinterClass parent_class;
-
-};
-
-GType                    gtk_printer_cups_get_type      (void) G_GNUC_CONST;
-void                     gtk_printer_cups_register_type (GTypeModule     *module);
-GtkPrinterCups          *gtk_printer_cups_new           (const char      *name,
-							 GtkPrintBackend *backend);
-ppd_file_t 		*gtk_printer_cups_get_ppd       (GtkPrinterCups  *printer);
-const gchar		*gtk_printer_cups_get_ppd_name  (GtkPrinterCups  *printer);
-
-G_END_DECLS
-
-#endif /* __GTK_PRINTER_CUPS_H__ */
diff --git a/modules/printbackends/file/Makefile.am b/modules/printbackends/file/Makefile.am
deleted file mode 100644
index 904f768..0000000
--- a/modules/printbackends/file/Makefile.am
+++ /dev/null
@@ -1,35 +0,0 @@
-include $(top_srcdir)/Makefile.decl
-
-
-backenddir = $(libdir)/gtk-2.0/$(GTK_BINARY_VERSION)/printbackends
-
-backend_LTLIBRARIES = libprintbackend-file.la
-
-libprintbackend_file_la_SOURCES = \
-	gtkprintbackendfile.c
-
-libprintbackend_file_la_CPPFLAGS = \
-	-I$(top_srcdir) 				\
-	-I$(top_srcdir)/gtk				\
-	-I$(top_builddir)/gtk				\
-	-I$(top_srcdir)/gdk				\
-	-I$(top_builddir)/gdk				\
-	-DGTK_PRINT_BACKEND_ENABLE_UNSUPPORTED		\
-	$(AM_CPPFLAGS)
-
-libprintbackend_file_la_CFLAGS = \
-	$(GTK_DEP_CFLAGS)				\
-	$(AM_CFLAGS)
-
-libprintbackend_file_la_LDFLAGS =  \
-	-avoid-version -module $(no_undefined)
-
-libprintbackend_file_la_LIBADD = \
-	$(top_builddir)/gtk/$(gtktargetlib)		\
-	$(top_builddir)/gdk/$(gdktargetlib)		\
-	$(GTK_DEP_LIBS)
-
-noinst_HEADERS =			\
-	gtkprintbackendfile.h
-
--include $(top_srcdir)/git.mk
diff --git a/modules/printbackends/file/gtkprintbackendfile.c b/modules/printbackends/file/gtkprintbackendfile.c
deleted file mode 100644
index 20d157d..0000000
--- a/modules/printbackends/file/gtkprintbackendfile.c
+++ /dev/null
@@ -1,809 +0,0 @@
-/* GTK - The GIMP Toolkit
- * gtkprintbackendfile.c: Default implementation of GtkPrintBackend 
- * for printing to a file
- * Copyright (C) 2003, Red Hat, Inc.
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-#include "config.h"
-
-#include <unistd.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <fcntl.h>
-#include <stdlib.h>
-#include <string.h>
-
-#include <errno.h>
-#include <cairo.h>
-#include <cairo-pdf.h>
-#include <cairo-ps.h>
-#include <cairo-svg.h>
-
-#include "gtk/gtkintl.h"
-
-#include "gtk/gtk.h"
-#include "gtk/gtkprinter-private.h"
-
-#include "gtkprintbackendfile.h"
-
-typedef struct _GtkPrintBackendFileClass GtkPrintBackendFileClass;
-
-#define GTK_PRINT_BACKEND_FILE_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), GTK_TYPE_PRINT_BACKEND_FILE, GtkPrintBackendFileClass))
-#define GTK_IS_PRINT_BACKEND_FILE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GTK_TYPE_PRINT_BACKEND_FILE))
-#define GTK_PRINT_BACKEND_FILE_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GTK_TYPE_PRINT_BACKEND_FILE, GtkPrintBackendFileClass))
-
-#define _STREAM_MAX_CHUNK_SIZE 8192
-
-static GType print_backend_file_type = 0;
-
-struct _GtkPrintBackendFileClass
-{
-  GtkPrintBackendClass parent_class;
-};
-
-struct _GtkPrintBackendFile
-{
-  GtkPrintBackend parent_instance;
-};
-
-typedef enum
-{
-  FORMAT_PDF,
-  FORMAT_PS,
-  FORMAT_SVG,
-  N_FORMATS
-} OutputFormat;
-
-static const gchar* formats[N_FORMATS] =
-{
-  "pdf",
-  "ps",
-  "svg"
-};
-
-static GObjectClass *backend_parent_class;
-
-static void                 gtk_print_backend_file_class_init      (GtkPrintBackendFileClass *class);
-static void                 gtk_print_backend_file_init            (GtkPrintBackendFile      *impl);
-static void                 file_printer_get_settings_from_options (GtkPrinter              *printer,
-								    GtkPrinterOptionSet     *options,
-								    GtkPrintSettings        *settings);
-static GtkPrinterOptionSet *file_printer_get_options               (GtkPrinter              *printer,
-								    GtkPrintSettings        *settings,
-								    GtkPageSetup            *page_setup,
-								    GtkPrintCapabilities     capabilities);
-static void                 file_printer_prepare_for_print         (GtkPrinter              *printer,
-								    GtkPrintJob             *print_job,
-								    GtkPrintSettings        *settings,
-								    GtkPageSetup            *page_setup);
-static void                 gtk_print_backend_file_print_stream    (GtkPrintBackend         *print_backend,
-								    GtkPrintJob             *job,
-								    GIOChannel              *data_io,
-								    GtkPrintJobCompleteFunc  callback,
-								    gpointer                 user_data,
-								    GDestroyNotify           dnotify);
-static cairo_surface_t *    file_printer_create_cairo_surface      (GtkPrinter              *printer,
-								    GtkPrintSettings        *settings,
-								    gdouble                  width,
-								    gdouble                  height,
-								    GIOChannel              *cache_io);
-
-static GList *              file_printer_list_papers               (GtkPrinter              *printer);
-static GtkPageSetup *       file_printer_get_default_page_size     (GtkPrinter              *printer);
-
-static void
-gtk_print_backend_file_register_type (GTypeModule *module)
-{
-  const GTypeInfo print_backend_file_info =
-  {
-    sizeof (GtkPrintBackendFileClass),
-    NULL,		/* base_init */
-    NULL,		/* base_finalize */
-    (GClassInitFunc) gtk_print_backend_file_class_init,
-    NULL,		/* class_finalize */
-    NULL,		/* class_data */
-    sizeof (GtkPrintBackendFile),
-    0,		/* n_preallocs */
-    (GInstanceInitFunc) gtk_print_backend_file_init,
-  };
-
-  print_backend_file_type = g_type_module_register_type (module,
-                                                         GTK_TYPE_PRINT_BACKEND,
-                                                         "GtkPrintBackendFile",
-                                                         &print_backend_file_info, 0);
-}
-
-G_MODULE_EXPORT void 
-pb_module_init (GTypeModule *module)
-{
-  gtk_print_backend_file_register_type (module);
-}
-
-G_MODULE_EXPORT void 
-pb_module_exit (void)
-{
-
-}
-  
-G_MODULE_EXPORT GtkPrintBackend * 
-pb_module_create (void)
-{
-  return gtk_print_backend_file_new ();
-}
-
-/*
- * GtkPrintBackendFile
- */
-GType
-gtk_print_backend_file_get_type (void)
-{
-  return print_backend_file_type;
-}
-
-/**
- * gtk_print_backend_file_new:
- *
- * Creates a new #GtkPrintBackendFile object. #GtkPrintBackendFile
- * implements the #GtkPrintBackend interface with direct access to
- * the filesystem using Unix/Linux API calls
- *
- * Return value: the new #GtkPrintBackendFile object
- **/
-GtkPrintBackend *
-gtk_print_backend_file_new (void)
-{
-  return g_object_new (GTK_TYPE_PRINT_BACKEND_FILE, NULL);
-}
-
-static void
-gtk_print_backend_file_class_init (GtkPrintBackendFileClass *class)
-{
-  GtkPrintBackendClass *backend_class = GTK_PRINT_BACKEND_CLASS (class);
-
-  backend_parent_class = g_type_class_peek_parent (class);
-
-  backend_class->print_stream = gtk_print_backend_file_print_stream;
-  backend_class->printer_create_cairo_surface = file_printer_create_cairo_surface;
-  backend_class->printer_get_options = file_printer_get_options;
-  backend_class->printer_get_settings_from_options = file_printer_get_settings_from_options;
-  backend_class->printer_prepare_for_print = file_printer_prepare_for_print;
-  backend_class->printer_list_papers = file_printer_list_papers;
-  backend_class->printer_get_default_page_size = file_printer_get_default_page_size;
-}
-
-/* return N_FORMATS if no explicit format in the settings */
-static OutputFormat
-format_from_settings (GtkPrintSettings *settings)
-{
-  const gchar *value;
-  gint i;
-
-  if (settings == NULL)
-    return N_FORMATS;
-
-  value = gtk_print_settings_get (settings,
-                                  GTK_PRINT_SETTINGS_OUTPUT_FILE_FORMAT);
-  if (value == NULL)
-    return N_FORMATS;
-
-  for (i = 0; i < N_FORMATS; ++i)
-    if (strcmp (value, formats[i]) == 0)
-      break;
-
-  g_assert (i < N_FORMATS);
-
-  return (OutputFormat) i;
-}
-
-static gchar *
-output_file_from_settings (GtkPrintSettings *settings,
-			   const gchar      *default_format)
-{
-  gchar *uri = NULL;
-  
-  if (settings)
-    uri = g_strdup (gtk_print_settings_get (settings, GTK_PRINT_SETTINGS_OUTPUT_URI));
-
-  if (uri == NULL)
-    { 
-      const gchar *extension;
-      gchar *name, *locale_name, *path;
-
-      if (default_format)
-        extension = default_format;
-      else
-        {
-          OutputFormat format;
-
-          format = format_from_settings (settings);
-          switch (format)
-            {
-              default:
-              case FORMAT_PDF:
-                extension = "pdf";
-                break;
-              case FORMAT_PS:
-                extension = "ps";
-                break;
-              case FORMAT_SVG:
-                extension = "svg";
-                break;
-            }
-        }
- 
-      /* default filename used for print-to-file */ 
-      name = g_strdup_printf (_("output.%s"), extension);
-      locale_name = g_filename_from_utf8 (name, -1, NULL, NULL, NULL);
-      g_free (name);
-
-      if (locale_name != NULL)
-        {
-	  gchar *current_dir = g_get_current_dir ();
-          path = g_build_filename (current_dir, locale_name, NULL);
-          g_free (locale_name);
-
-          uri = g_filename_to_uri (path, NULL, NULL);
-          g_free (path);
-	  g_free (current_dir);
-	}
-    }
-
-  return uri;
-}
-
-static cairo_status_t
-_cairo_write (void                *closure,
-              const unsigned char *data,
-              unsigned int         length)
-{
-  GIOChannel *io = (GIOChannel *)closure;
-  gsize written;
-  GError *error;
-
-  error = NULL;
-
-  GTK_NOTE (PRINTING,
-            g_print ("FILE Backend: Writting %i byte chunk to temp file\n", length));
-
-  while (length > 0) 
-    {
-      g_io_channel_write_chars (io, (const gchar *) data, length, &written, &error);
-
-      if (error != NULL)
-	{
-	  GTK_NOTE (PRINTING,
-                     g_print ("FILE Backend: Error writting to temp file, %s\n", error->message));
-
-          g_error_free (error);
-	  return CAIRO_STATUS_WRITE_ERROR;
-	}    
-
-      GTK_NOTE (PRINTING,
-                g_print ("FILE Backend: Wrote %i bytes to temp file\n", written));
-      
-      data += written;
-      length -= written;
-    }
-
-  return CAIRO_STATUS_SUCCESS;
-}
-
-
-static cairo_surface_t *
-file_printer_create_cairo_surface (GtkPrinter       *printer,
-				   GtkPrintSettings *settings,
-				   gdouble           width, 
-				   gdouble           height,
-				   GIOChannel       *cache_io)
-{
-  cairo_surface_t *surface;
-  OutputFormat format;
-  const cairo_svg_version_t *versions;
-  int num_versions = 0;
-
-  format = format_from_settings (settings);
-
-  switch (format)
-    {
-      default:
-      case FORMAT_PDF:
-        surface = cairo_pdf_surface_create_for_stream (_cairo_write, cache_io, width, height);
-        break;
-      case FORMAT_PS:
-        surface = cairo_ps_surface_create_for_stream (_cairo_write, cache_io, width, height);
-        break;
-      case FORMAT_SVG:
-        surface = cairo_svg_surface_create_for_stream (_cairo_write, cache_io, width, height);
-        cairo_svg_get_versions (&versions, &num_versions);
-        if (num_versions > 0)
-          cairo_svg_surface_restrict_to_version (surface, versions[num_versions - 1]);
-        break;
-    }
-
-  cairo_surface_set_fallback_resolution (surface,
-                                         2.0 * gtk_print_settings_get_printer_lpi (settings),
-                                         2.0 * gtk_print_settings_get_printer_lpi (settings));
-
-  return surface;
-}
-
-typedef struct {
-  GtkPrintBackend *backend;
-  GtkPrintJobCompleteFunc callback;
-  GtkPrintJob *job;
-  GFileOutputStream *target_io_stream;
-  gpointer user_data;
-  GDestroyNotify dnotify;
-} _PrintStreamData;
-
-static void
-file_print_cb (GtkPrintBackendFile *print_backend,
-               GError              *error,
-               gpointer            user_data)
-{
-  _PrintStreamData *ps = (_PrintStreamData *) user_data;
-
-  GDK_THREADS_ENTER ();
-
-  if (ps->target_io_stream != NULL)
-    g_output_stream_close (G_OUTPUT_STREAM (ps->target_io_stream), NULL, NULL);
-
-  if (ps->callback)
-    ps->callback (ps->job, ps->user_data, error);
-
-  if (ps->dnotify)
-    ps->dnotify (ps->user_data);
-
-  gtk_print_job_set_status (ps->job,
-			    (error != NULL)?GTK_PRINT_STATUS_FINISHED_ABORTED:GTK_PRINT_STATUS_FINISHED);
-
-  if (ps->job)
-    g_object_unref (ps->job);
- 
-  g_free (ps);
-
-  GDK_THREADS_LEAVE ();
-}
-
-static gboolean
-file_write (GIOChannel   *source,
-            GIOCondition  con,
-            gpointer      user_data)
-{
-  gchar buf[_STREAM_MAX_CHUNK_SIZE];
-  gsize bytes_read;
-  GError *error;
-  GIOStatus read_status;
-  _PrintStreamData *ps = (_PrintStreamData *) user_data;
-
-  error = NULL;
-
-  read_status = 
-    g_io_channel_read_chars (source,
-                             buf,
-                             _STREAM_MAX_CHUNK_SIZE,
-                             &bytes_read,
-                             &error);
-
-  if (read_status != G_IO_STATUS_ERROR)
-    {
-      gsize bytes_written;
-
-      g_output_stream_write_all (G_OUTPUT_STREAM (ps->target_io_stream),
-                                 buf,
-                                 bytes_read,
-                                 &bytes_written,
-                                 NULL,
-                                 &error);
-    }
-
-  if (error != NULL || read_status == G_IO_STATUS_EOF)
-    {
-      file_print_cb (GTK_PRINT_BACKEND_FILE (ps->backend), error, user_data);
-
-      if (error != NULL)
-        {
-          GTK_NOTE (PRINTING,
-                    g_print ("FILE Backend: %s\n", error->message));
-
-          g_error_free (error);
-        }
-
-      return FALSE;
-    }
-
-  GTK_NOTE (PRINTING,
-            g_print ("FILE Backend: Writting %i byte chunk to target file\n", bytes_read));
-
-  return TRUE;
-}
-
-static void
-gtk_print_backend_file_print_stream (GtkPrintBackend        *print_backend,
-				     GtkPrintJob            *job,
-				     GIOChannel             *data_io,
-				     GtkPrintJobCompleteFunc callback,
-				     gpointer                user_data,
-				     GDestroyNotify          dnotify)
-{
-  GError *internal_error = NULL;
-  _PrintStreamData *ps;
-  GtkPrintSettings *settings;
-  gchar *uri;
-  GFile *file = NULL;
-
-  settings = gtk_print_job_get_settings (job);
-
-  ps = g_new0 (_PrintStreamData, 1);
-  ps->callback = callback;
-  ps->user_data = user_data;
-  ps->dnotify = dnotify;
-  ps->job = g_object_ref (job);
-  ps->backend = print_backend;
-
-  internal_error = NULL;
-  uri = output_file_from_settings (settings, NULL);
-
-  if (uri == NULL)
-    goto error;
-
-  file = g_file_new_for_uri (uri);
-  ps->target_io_stream = g_file_replace (file, NULL, FALSE, G_FILE_CREATE_NONE, NULL, &internal_error);
-
-  g_object_unref (file);
-  g_free (uri);
-
-error:
-  if (internal_error != NULL)
-    {
-      file_print_cb (GTK_PRINT_BACKEND_FILE (print_backend),
-                    internal_error, ps);
-
-      g_error_free (internal_error);
-      return;
-    }
-
-  g_io_add_watch (data_io, 
-                  G_IO_IN | G_IO_PRI | G_IO_ERR | G_IO_HUP,
-                  (GIOFunc) file_write,
-                  ps);
-}
-
-static void
-gtk_print_backend_file_init (GtkPrintBackendFile *backend)
-{
-  GtkPrinter *printer;
-  
-  printer = g_object_new (GTK_TYPE_PRINTER,
-			  "name", _("Print to File"),
-			  "backend", backend,
-			  "is-virtual", TRUE,
-			  "accepts-pdf", TRUE,
-			  NULL); 
-
-  gtk_printer_set_has_details (printer, TRUE);
-  gtk_printer_set_icon_name (printer, "gtk-save");
-  gtk_printer_set_is_active (printer, TRUE);
-
-  gtk_print_backend_add_printer (GTK_PRINT_BACKEND (backend), printer);
-  g_object_unref (printer);
-
-  gtk_print_backend_set_list_done (GTK_PRINT_BACKEND (backend));
-}
-
-typedef struct {
-  GtkPrinter          *printer;
-  GtkPrinterOptionSet *set;
-} _OutputFormatChangedData;
-
-static void
-set_printer_format_from_option_set (GtkPrinter          *printer,
-				    GtkPrinterOptionSet *set)
-{
-  GtkPrinterOption *format_option;
-  const gchar *value;
-  gint i;
-
-  format_option = gtk_printer_option_set_lookup (set, "output-file-format");
-  if (format_option && format_option->value)
-    {
-      value = format_option->value;
-      if (value)
-        {
-	  for (i = 0; i < N_FORMATS; ++i)
-	    if (strcmp (value, formats[i]) == 0)
-	      break;
-
-	  g_assert (i < N_FORMATS);
-
-	  switch (i)
-	    {
-	      case FORMAT_PDF:
-		gtk_printer_set_accepts_pdf (printer, TRUE);
-		gtk_printer_set_accepts_ps (printer, FALSE);
-		break;
-	      case FORMAT_PS:
-		gtk_printer_set_accepts_pdf (printer, FALSE);
-		gtk_printer_set_accepts_ps (printer, TRUE);
-		break;
-	      case FORMAT_SVG:
-	      default:
-		gtk_printer_set_accepts_pdf (printer, FALSE);
-		gtk_printer_set_accepts_ps (printer, FALSE);
-		break;
-	    }
-	}
-    }
-}
-
-static void
-file_printer_output_file_format_changed (GtkPrinterOption    *format_option,
-					 gpointer             user_data)
-{
-  GtkPrinterOption *uri_option;
-  gchar            *base = NULL;
-  _OutputFormatChangedData *data = (_OutputFormatChangedData *) user_data;
-
-  if (! format_option->value)
-    return;
-
-  uri_option = gtk_printer_option_set_lookup (data->set,
-                                              "gtk-main-page-custom-input");
-
-  if (uri_option && uri_option->value)
-    {
-      const gchar *uri = uri_option->value;
-      const gchar *dot = strrchr (uri, '.');
-
-      if (dot)
-        {
-          gint i;
-
-          /*  check if the file extension matches one of the known ones  */
-          for (i = 0; i < N_FORMATS; i++)
-            if (strcmp (dot + 1, formats[i]) == 0)
-              break;
-
-          if (i < N_FORMATS && strcmp (formats[i], format_option->value))
-            {
-              /*  the file extension is known but doesn't match the
-               *  selected one, strip it away
-               */
-              base = g_strndup (uri, dot - uri);
-            }
-        }
-      else
-        {
-          /*  there's no file extension  */
-          base = g_strdup (uri);
-        }
-    }
-
-  if (base)
-    {
-      gchar *tmp = g_strdup_printf ("%s.%s", base, format_option->value);
-
-      gtk_printer_option_set (uri_option, tmp);
-      g_free (tmp);
-      g_free (base);
-    }
-
-  set_printer_format_from_option_set (data->printer, data->set);
-}
-
-static GtkPrinterOptionSet *
-file_printer_get_options (GtkPrinter           *printer,
-			  GtkPrintSettings     *settings,
-			  GtkPageSetup         *page_setup,
-			  GtkPrintCapabilities  capabilities)
-{
-  GtkPrinterOptionSet *set;
-  GtkPrinterOption *option;
-  const gchar *n_up[] = {"1", "2", "4", "6", "9", "16" };
-  const gchar *pages_per_sheet = NULL;
-  const gchar *format_names[N_FORMATS] = { N_("PDF"), N_("Postscript"), N_("SVG") };
-  const gchar *supported_formats[N_FORMATS];
-  gchar *display_format_names[N_FORMATS];
-  gint n_formats = 0;
-  OutputFormat format;
-  gchar *uri;
-  gint current_format = 0;
-  _OutputFormatChangedData *format_changed_data;
-
-  format = format_from_settings (settings);
-
-  set = gtk_printer_option_set_new ();
-
-  option = gtk_printer_option_new ("gtk-n-up", _("Pages per _sheet:"), GTK_PRINTER_OPTION_TYPE_PICKONE);
-  gtk_printer_option_choices_from_array (option, G_N_ELEMENTS (n_up),
-					 (char **) n_up, (char **) n_up /* FIXME i18n (localised digits)! */);
-  if (settings)
-    pages_per_sheet = gtk_print_settings_get (settings, GTK_PRINT_SETTINGS_NUMBER_UP);
-  if (pages_per_sheet)
-    gtk_printer_option_set (option, pages_per_sheet);
-  else
-    gtk_printer_option_set (option, "1");
-  gtk_printer_option_set_add (set, option);
-  g_object_unref (option);
-
-  if (capabilities & (GTK_PRINT_CAPABILITY_GENERATE_PDF | GTK_PRINT_CAPABILITY_GENERATE_PS))
-    {
-      if (capabilities & GTK_PRINT_CAPABILITY_GENERATE_PDF)
-        {
-	  if (format == FORMAT_PDF || format == N_FORMATS)
-            {
-              format = FORMAT_PDF;
-	      current_format = n_formats;
-            }
-          supported_formats[n_formats] = formats[FORMAT_PDF];
-	  display_format_names[n_formats] = (gchar*)format_names[FORMAT_PDF];
-	  n_formats++;
-	}
-      if (capabilities & GTK_PRINT_CAPABILITY_GENERATE_PS)
-        {
-	  if (format == FORMAT_PS || format == N_FORMATS)
-	    current_format = n_formats;
-          supported_formats[n_formats] = formats[FORMAT_PS];
-          display_format_names[n_formats] = (gchar*)format_names[FORMAT_PS];
-	  n_formats++;
-	}
-    }
-  else
-    {
-      switch (format)
-        {
-          default:
-          case FORMAT_PDF:
-            current_format = FORMAT_PDF;
-            break;
-          case FORMAT_PS:
-            current_format = FORMAT_PS;
-            break;
-          case FORMAT_SVG:
-            current_format = FORMAT_SVG;            
-            break;
-        }
-
-      for (n_formats = 0; n_formats < N_FORMATS; ++n_formats)
-        {
-	  supported_formats[n_formats] = formats[n_formats];
-          display_format_names[n_formats] = (gchar*)format_names[n_formats];
-	}
-    }
-
-  uri = output_file_from_settings (settings, supported_formats[current_format]);
-
-  option = gtk_printer_option_new ("gtk-main-page-custom-input", _("File"), 
-				   GTK_PRINTER_OPTION_TYPE_FILESAVE);
-  gtk_printer_option_set_activates_default (option, TRUE);
-  gtk_printer_option_set (option, uri);
-  g_free (uri);
-  option->group = g_strdup ("GtkPrintDialogExtension");
-  gtk_printer_option_set_add (set, option);
-
-  if (n_formats > 1)
-    {
-      option = gtk_printer_option_new ("output-file-format", _("_Output format"), 
-				       GTK_PRINTER_OPTION_TYPE_ALTERNATIVE);
-      option->group = g_strdup ("GtkPrintDialogExtension");
-
-      gtk_printer_option_choices_from_array (option, n_formats,
-					     (char **) supported_formats,
-					     display_format_names);
-      gtk_printer_option_set (option, supported_formats[current_format]);
-      gtk_printer_option_set_add (set, option);
-
-      set_printer_format_from_option_set (printer, set);
-      format_changed_data = g_new (_OutputFormatChangedData, 1);
-      format_changed_data->printer = printer;
-      format_changed_data->set = set;
-      g_signal_connect_data (option, "changed",
-			     G_CALLBACK (file_printer_output_file_format_changed),
-			     format_changed_data, (GClosureNotify)g_free, 0);
-
-      g_object_unref (option);
-    }
-
-  return set;
-}
-
-static void
-file_printer_get_settings_from_options (GtkPrinter          *printer,
-					GtkPrinterOptionSet *options,
-					GtkPrintSettings    *settings)
-{
-  GtkPrinterOption *option;
-
-  option = gtk_printer_option_set_lookup (options, "gtk-main-page-custom-input");
-  gtk_print_settings_set (settings, GTK_PRINT_SETTINGS_OUTPUT_URI, option->value);
-
-  option = gtk_printer_option_set_lookup (options, "output-file-format");
-  if (option)
-    gtk_print_settings_set (settings, GTK_PRINT_SETTINGS_OUTPUT_FILE_FORMAT, option->value);
-
-  option = gtk_printer_option_set_lookup (options, "gtk-n-up");
-  if (option)
-    gtk_print_settings_set (settings, GTK_PRINT_SETTINGS_NUMBER_UP, option->value);
-
-  option = gtk_printer_option_set_lookup (options, "gtk-n-up-layout");
-  if (option)
-    gtk_print_settings_set (settings, GTK_PRINT_SETTINGS_NUMBER_UP_LAYOUT, option->value);
-}
-
-static void
-file_printer_prepare_for_print (GtkPrinter       *printer,
-				GtkPrintJob      *print_job,
-				GtkPrintSettings *settings,
-				GtkPageSetup     *page_setup)
-{
-  gdouble scale;
-
-  print_job->print_pages = gtk_print_settings_get_print_pages (settings);
-  print_job->page_ranges = NULL;
-  print_job->num_page_ranges = 0;
-  
-  if (print_job->print_pages == GTK_PRINT_PAGES_RANGES)
-    print_job->page_ranges =
-      gtk_print_settings_get_page_ranges (settings,
-					  &print_job->num_page_ranges);
-  
-  print_job->collate = gtk_print_settings_get_collate (settings);
-  print_job->reverse = gtk_print_settings_get_reverse (settings);
-  print_job->num_copies = gtk_print_settings_get_n_copies (settings);
-  print_job->number_up = gtk_print_settings_get_number_up (settings);
-  print_job->number_up_layout = gtk_print_settings_get_number_up_layout (settings);
-
-  scale = gtk_print_settings_get_scale (settings);
-  if (scale != 100.0)
-    print_job->scale = scale/100.0;
-
-  print_job->page_set = gtk_print_settings_get_page_set (settings);
-  print_job->rotate_to_orientation = TRUE;
-}
-
-static GList *
-file_printer_list_papers (GtkPrinter *printer)
-{
-  GList *result = NULL;
-  GList *papers, *p;
-  GtkPageSetup *page_setup;
-
-  papers = gtk_paper_size_get_paper_sizes (TRUE);
-
-  for (p = papers; p; p = p->next)
-    {
-      GtkPaperSize *paper_size = p->data;
-
-      page_setup = gtk_page_setup_new ();
-      gtk_page_setup_set_paper_size (page_setup, paper_size);
-      gtk_paper_size_free (paper_size);
-      result = g_list_prepend (result, page_setup);
-    }
-
-  g_list_free (papers);
-
-  return g_list_reverse (result);
-}
-
-static GtkPageSetup *
-file_printer_get_default_page_size (GtkPrinter *printer)
-{
-  GtkPageSetup *result = NULL;
-
-  return result;
-}
diff --git a/modules/printbackends/file/gtkprintbackendfile.h b/modules/printbackends/file/gtkprintbackendfile.h
deleted file mode 100644
index 94b30c3..0000000
--- a/modules/printbackends/file/gtkprintbackendfile.h
+++ /dev/null
@@ -1,41 +0,0 @@
-/* GTK - The GIMP Toolkit
- * gtkprintbackendpdf.h: Default implementation of GtkPrintBackend 
- * for printing to a file
- * Copyright (C) 2003, Red Hat, Inc.
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-#ifndef __GTK_PRINT_BACKEND_FILE_H__
-#define __GTK_PRINT_BACKEND_FILE_H__
-
-#include <glib-object.h>
-#include "gtkprintbackend.h"
-
-G_BEGIN_DECLS
-
-#define GTK_TYPE_PRINT_BACKEND_FILE    (gtk_print_backend_file_get_type ())
-#define GTK_PRINT_BACKEND_FILE(obj)    (G_TYPE_CHECK_INSTANCE_CAST ((obj), GTK_TYPE_PRINT_BACKEND_FILE, GtkPrintBackendFile))
-#define GTK_IS_PRINT_BACKEND_FILE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GTK_TYPE_PRINT_BACKEND_FILE))
-
-typedef struct _GtkPrintBackendFile    GtkPrintBackendFile;
-
-GtkPrintBackend *gtk_print_backend_file_new      (void);
-GType            gtk_print_backend_file_get_type (void) G_GNUC_CONST;
-
-G_END_DECLS
-
-#endif /* __GTK_PRINT_BACKEND_FILE_H__ */
diff --git a/modules/printbackends/lpr/Makefile.am b/modules/printbackends/lpr/Makefile.am
deleted file mode 100644
index 12b7fce..0000000
--- a/modules/printbackends/lpr/Makefile.am
+++ /dev/null
@@ -1,31 +0,0 @@
-include $(top_srcdir)/Makefile.decl
-
-
-INCLUDES = \
-	-I$(top_srcdir) 				\
-	-I$(top_srcdir)/gtk				\
-	-I$(top_builddir)/gtk				\
-	-I$(top_srcdir)/gdk				\
-	-I$(top_builddir)/gdk				\
-	-DGTK_PRINT_BACKEND_ENABLE_UNSUPPORTED		\
-	$(GTK_DEP_CFLAGS)				\
-	$(GTK_DEBUG_FLAGS)
-
-LDADDS = \
-	$(GTK_DEP_LIBS)					\
-	$(top_builddir)/gtk/$(gtktargetlib)		
-
-backenddir = $(libdir)/gtk-2.0/$(GTK_BINARY_VERSION)/printbackends
-
-backend_LTLIBRARIES = libprintbackend-lpr.la
-
-libprintbackend_lpr_la_SOURCES =	\
-	gtkprintbackendlpr.c
-
-noinst_HEADERS =			\
-	gtkprintbackendlpr.h
-
-libprintbackend_lpr_la_LDFLAGS =  -avoid-version -module $(no_undefined)
-libprintbackend_lpr_la_LIBADD = $(LDADDS)
-
--include $(top_srcdir)/git.mk
diff --git a/modules/printbackends/lpr/gtkprintbackendlpr.c b/modules/printbackends/lpr/gtkprintbackendlpr.c
deleted file mode 100644
index 0ee856c..0000000
--- a/modules/printbackends/lpr/gtkprintbackendlpr.c
+++ /dev/null
@@ -1,490 +0,0 @@
-/* GTK - The GIMP Toolkit
- * gtkprintbackendlpr.c: LPR implementation of GtkPrintBackend 
- * for printing to lpr 
- * Copyright (C) 2006, 2007 Red Hat, Inc.
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-#include "config.h"
-#include <unistd.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <fcntl.h>
-#include <stdlib.h>
-#include <string.h>
-
-#include <errno.h>
-#include <cairo.h>
-#include <cairo-ps.h>
-
-#include "gtk/gtkintl.h"
-
-#include <gtk/gtk.h>
-#include "gtkprinter-private.h"
-
-#include "gtkprintbackendlpr.h"
-
-typedef struct _GtkPrintBackendLprClass GtkPrintBackendLprClass;
-
-#define GTK_PRINT_BACKEND_LPR_CLASS(klass)     (G_TYPE_CHECK_CLASS_CAST ((klass), GTK_TYPE_PRINT_BACKEND_LPR, GtkPrintBackendLprClass))
-#define GTK_IS_PRINT_BACKEND_LPR_CLASS(klass)  (G_TYPE_CHECK_CLASS_TYPE ((klass), GTK_TYPE_PRINT_BACKEND_LPR))
-#define GTK_PRINT_BACKEND_LPR_GET_CLASS(obj)   (G_TYPE_INSTANCE_GET_CLASS ((obj), GTK_TYPE_PRINT_BACKEND_LPR, GtkPrintBackendLprClass))
-
-#define _LPR_MAX_CHUNK_SIZE 8192
-
-static GType print_backend_lpr_type = 0;
-
-struct _GtkPrintBackendLprClass
-{
-  GtkPrintBackendClass parent_class;
-};
-
-struct _GtkPrintBackendLpr
-{
-  GtkPrintBackend parent_instance;
-};
-
-static GObjectClass *backend_parent_class;
-
-static void                 gtk_print_backend_lpr_class_init      (GtkPrintBackendLprClass *class);
-static void                 gtk_print_backend_lpr_init            (GtkPrintBackendLpr      *impl);
-static void                 lpr_printer_get_settings_from_options (GtkPrinter              *printer,
-								   GtkPrinterOptionSet     *options,
-								   GtkPrintSettings        *settings);
-static GtkPrinterOptionSet *lpr_printer_get_options               (GtkPrinter              *printer,
-								   GtkPrintSettings        *settings,
-								   GtkPageSetup            *page_setup,
-								   GtkPrintCapabilities     capabilities);
-static void                 lpr_printer_prepare_for_print         (GtkPrinter              *printer,
-								   GtkPrintJob             *print_job,
-								   GtkPrintSettings        *settings,
-								   GtkPageSetup            *page_setup);
-static cairo_surface_t *    lpr_printer_create_cairo_surface      (GtkPrinter              *printer,
-								   GtkPrintSettings        *settings,
-								   gdouble                  width,
-								   gdouble                  height,
-								   GIOChannel              *cache_io);
-static void                 gtk_print_backend_lpr_print_stream    (GtkPrintBackend         *print_backend,
-								   GtkPrintJob             *job,
-								   GIOChannel              *data_io,
-								   GtkPrintJobCompleteFunc  callback,
-								   gpointer                 user_data,
-								   GDestroyNotify           dnotify);
-
-static void
-gtk_print_backend_lpr_register_type (GTypeModule *module)
-{
-  const GTypeInfo print_backend_lpr_info =
-  {
-    sizeof (GtkPrintBackendLprClass),
-    NULL,		/* base_init */
-    NULL,		/* base_finalize */
-    (GClassInitFunc) gtk_print_backend_lpr_class_init,
-    NULL,		/* class_finalize */
-    NULL,		/* class_data */
-    sizeof (GtkPrintBackendLpr),
-    0,		/* n_preallocs */
-    (GInstanceInitFunc) gtk_print_backend_lpr_init,
-  };
-
-  print_backend_lpr_type = g_type_module_register_type (module,
-                                                        GTK_TYPE_PRINT_BACKEND,
-                                                        "GtkPrintBackendLpr",
-                                                        &print_backend_lpr_info, 0);
-}
-
-G_MODULE_EXPORT void 
-pb_module_init (GTypeModule *module)
-{
-  gtk_print_backend_lpr_register_type (module);
-}
-
-G_MODULE_EXPORT void 
-pb_module_exit (void)
-{
-
-}
-  
-G_MODULE_EXPORT GtkPrintBackend * 
-pb_module_create (void)
-{
-  return gtk_print_backend_lpr_new ();
-}
-
-/*
- * GtkPrintBackendLpr
- */
-GType
-gtk_print_backend_lpr_get_type (void)
-{
-  return print_backend_lpr_type;
-}
-
-/**
- * gtk_print_backend_lpr_new:
- *
- * Creates a new #GtkPrintBackendLpr object. #GtkPrintBackendLpr
- * implements the #GtkPrintBackend interface with direct access to
- * the filesystem using Unix/Linux API calls
- *
- * Return value: the new #GtkPrintBackendLpr object
- **/
-GtkPrintBackend *
-gtk_print_backend_lpr_new (void)
-{
-  return g_object_new (GTK_TYPE_PRINT_BACKEND_LPR, NULL);
-}
-
-static void
-gtk_print_backend_lpr_class_init (GtkPrintBackendLprClass *class)
-{
-  GtkPrintBackendClass *backend_class = GTK_PRINT_BACKEND_CLASS (class);
-  
-  backend_parent_class = g_type_class_peek_parent (class);
-
-  backend_class->print_stream = gtk_print_backend_lpr_print_stream;
-  backend_class->printer_create_cairo_surface = lpr_printer_create_cairo_surface;
-  backend_class->printer_get_options = lpr_printer_get_options;
-  backend_class->printer_get_settings_from_options = lpr_printer_get_settings_from_options;
-  backend_class->printer_prepare_for_print = lpr_printer_prepare_for_print;
-}
-
-static cairo_status_t
-_cairo_write (void                *closure,
-              const unsigned char *data,
-              unsigned int         length)
-{
-  GIOChannel *io = (GIOChannel *)closure;
-  gsize written;
-  GError *error;
-
-  error = NULL;
-
-  GTK_NOTE (PRINTING,
-            g_print ("LPR Backend: Writting %i byte chunk to temp file\n", length));
-
-  while (length > 0) 
-    {
-      g_io_channel_write_chars (io, (const gchar*)data, length, &written, &error);
-
-      if (error != NULL)
-	{
-	  GTK_NOTE (PRINTING,
-                     g_print ("LPR Backend: Error writting to temp file, %s\n", error->message));
-
-          g_error_free (error);
-	  return CAIRO_STATUS_WRITE_ERROR;
-	}    
-
-      GTK_NOTE (PRINTING,
-                g_print ("LPR Backend: Wrote %" G_GSIZE_FORMAT " bytes to temp file\n", written));
-
-      data += written;
-      length -= written;
-    }
-
-  return CAIRO_STATUS_SUCCESS;
-}
-
-static cairo_surface_t *
-lpr_printer_create_cairo_surface (GtkPrinter       *printer,
-				  GtkPrintSettings *settings,
-				  gdouble           width, 
-				  gdouble           height,
-				  GIOChannel       *cache_io)
-{
-  cairo_surface_t *surface;
-  
-  surface = cairo_ps_surface_create_for_stream (_cairo_write, cache_io, width, height);
-
-  cairo_surface_set_fallback_resolution (surface,
-                                         2.0 * gtk_print_settings_get_printer_lpi (settings),
-                                         2.0 * gtk_print_settings_get_printer_lpi (settings));
-
-  return surface;
-}
-
-typedef struct {
-  GtkPrintBackend *backend;
-  GtkPrintJobCompleteFunc callback;
-  GtkPrintJob *job;
-  gpointer user_data;
-  GDestroyNotify dnotify;
-
-  GIOChannel *in;
-} _PrintStreamData;
-
-static void
-lpr_print_cb (GtkPrintBackendLpr *print_backend,
-              GError             *error,
-              gpointer            user_data)
-{
-  _PrintStreamData *ps = (_PrintStreamData *) user_data;
-
-  if (ps->in != NULL) 
-    g_io_channel_unref (ps->in);
-
-  if (ps->callback)
-    ps->callback (ps->job, ps->user_data, error);
-
-  if (ps->dnotify)
-    ps->dnotify (ps->user_data);
-
-  gtk_print_job_set_status (ps->job, 
-			    error ? GTK_PRINT_STATUS_FINISHED_ABORTED 
-			          : GTK_PRINT_STATUS_FINISHED);
-
-  if (ps->job)
-    g_object_unref (ps->job);
-  
-  g_free (ps);
-}
-
-static gboolean
-lpr_write (GIOChannel   *source,
-           GIOCondition  con,
-           gpointer      user_data)
-{
-  gchar buf[_LPR_MAX_CHUNK_SIZE];
-  gsize bytes_read;
-  GError *error;
-  GIOStatus status;
-  _PrintStreamData *ps = (_PrintStreamData *) user_data;
-
-  error = NULL;
-
-  status = 
-    g_io_channel_read_chars (source,
-                             buf,
-                             _LPR_MAX_CHUNK_SIZE,
-                             &bytes_read,
-                             &error);
-
-  if (status != G_IO_STATUS_ERROR)
-    {
-      gsize bytes_written;
-
-      g_io_channel_write_chars (ps->in,
-                                buf, 
-				bytes_read, 
-				&bytes_written, 
-				&error);
-    }
-
-  if (error != NULL || status == G_IO_STATUS_EOF)
-    {
-      lpr_print_cb (GTK_PRINT_BACKEND_LPR (ps->backend), 
-		    error, user_data);
-
-
-      if (error != NULL)
-        {
-          GTK_NOTE (PRINTING,
-                    g_print ("LPR Backend: %s\n", error->message));
-
-          g_error_free (error);
-        } 
-
-      return FALSE;
-    }
-
-  GTK_NOTE (PRINTING,
-            g_print ("LPR Backend: Writting %" G_GSIZE_FORMAT " byte chunk to lpr pipe\n", bytes_read));
-
-
-  return TRUE;
-}
-
-#define LPR_COMMAND "lpr"
-
-static void
-gtk_print_backend_lpr_print_stream (GtkPrintBackend        *print_backend,
-				    GtkPrintJob            *job,
-				    GIOChannel             *data_io,
-				    GtkPrintJobCompleteFunc callback,
-				    gpointer                user_data,
-				    GDestroyNotify          dnotify)
-{
-  GError *print_error = NULL;
-  _PrintStreamData *ps;
-  GtkPrintSettings *settings;
-  gint argc;
-  gint in_fd;
-  gchar **argv = NULL;
-  const char *cmd_line;
-
-  settings = gtk_print_job_get_settings (job);
-
-  cmd_line = gtk_print_settings_get (settings, "lpr-commandline");
-  if (cmd_line == NULL)
-    cmd_line = LPR_COMMAND;
-
-  ps = g_new0 (_PrintStreamData, 1);
-  ps->callback = callback;
-  ps->user_data = user_data;
-  ps->dnotify = dnotify;
-  ps->job = g_object_ref (job);
-  ps->in = NULL;
-
- /* spawn lpr with pipes and pipe ps file to lpr */
-  if (!g_shell_parse_argv (cmd_line, &argc, &argv, &print_error))
-    goto out;
-
-  if (!g_spawn_async_with_pipes (NULL,
-                                 argv,
-                                 NULL,
-                                 G_SPAWN_SEARCH_PATH,
-                                 NULL,
-                                 NULL,
-                                 NULL,
-                                 &in_fd,
-                                 NULL,
-                                 NULL,
-                                 &print_error))
-      goto out;
-
-  ps->in = g_io_channel_unix_new (in_fd);
-
-  g_io_channel_set_encoding (ps->in, NULL, &print_error);
-  if (print_error != NULL)
-    {
-      if (ps->in != NULL)
-        g_io_channel_unref (ps->in);
-
-      goto out;
-    }
-
-  g_io_channel_set_close_on_unref (ps->in, TRUE);
-
-  g_io_add_watch (data_io,
-                  G_IO_IN | G_IO_PRI | G_IO_ERR | G_IO_HUP,
-                  (GIOFunc) lpr_write,
-                  ps);
-
- out:
-  if (argv != NULL)
-    g_strfreev (argv);
-
-  if (print_error != NULL)
-    {
-      lpr_print_cb (GTK_PRINT_BACKEND_LPR (print_backend),
-		    print_error, ps);
-      g_error_free (print_error);
-    }
-}
-
-static void
-gtk_print_backend_lpr_init (GtkPrintBackendLpr *backend)
-{
-  GtkPrinter *printer;
-
-  printer = gtk_printer_new (_("Print to LPR"),
-			     GTK_PRINT_BACKEND (backend),
-			     TRUE); 
-  gtk_printer_set_has_details (printer, TRUE);
-  gtk_printer_set_icon_name (printer, "gtk-print");
-  gtk_printer_set_is_active (printer, TRUE);
-  gtk_printer_set_is_default (printer, TRUE);
-
-  gtk_print_backend_add_printer (GTK_PRINT_BACKEND (backend), printer);
-  g_object_unref (printer);
-  gtk_print_backend_set_list_done (GTK_PRINT_BACKEND (backend));
-}
-
-static GtkPrinterOptionSet *
-lpr_printer_get_options (GtkPrinter           *printer,
-			 GtkPrintSettings     *settings,
-			 GtkPageSetup         *page_setup,
-			 GtkPrintCapabilities  capabilities)
-{
-  GtkPrinterOptionSet *set;
-  GtkPrinterOption *option;
-  const char *command;
-  char *n_up[] = {"1", "2", "4", "6", "9", "16" };
-
-  set = gtk_printer_option_set_new ();
-
-  option = gtk_printer_option_new ("gtk-n-up", _("Pages Per Sheet"), GTK_PRINTER_OPTION_TYPE_PICKONE);
-  gtk_printer_option_choices_from_array (option, G_N_ELEMENTS (n_up),
-					 n_up, n_up);
-  gtk_printer_option_set (option, "1");
-  gtk_printer_option_set_add (set, option);
-  g_object_unref (option);
-
-  option = gtk_printer_option_new ("gtk-main-page-custom-input", _("Command Line"), GTK_PRINTER_OPTION_TYPE_STRING);
-  gtk_printer_option_set_activates_default (option, TRUE);
-  option->group = g_strdup ("GtkPrintDialogExtension");
-  if (settings != NULL &&
-      (command = gtk_print_settings_get (settings, "lpr-commandline"))!= NULL)
-    gtk_printer_option_set (option, command);
-  else
-    gtk_printer_option_set (option, LPR_COMMAND);
-  gtk_printer_option_set_add (set, option);
-    
-  return set;
-}
-
-static void
-lpr_printer_get_settings_from_options (GtkPrinter          *printer,
-				       GtkPrinterOptionSet *options,
-				       GtkPrintSettings    *settings)
-{
-  GtkPrinterOption *option;
-
-  option = gtk_printer_option_set_lookup (options, "gtk-main-page-custom-input");
-  if (option)
-    gtk_print_settings_set (settings, "lpr-commandline", option->value);
-
-  option = gtk_printer_option_set_lookup (options, "gtk-n-up");
-  if (option)
-    gtk_print_settings_set (settings, GTK_PRINT_SETTINGS_NUMBER_UP, option->value);
-
-  option = gtk_printer_option_set_lookup (options, "gtk-n-up-layout");
-  if (option)
-    gtk_print_settings_set (settings, GTK_PRINT_SETTINGS_NUMBER_UP_LAYOUT, option->value);
-}
-
-static void
-lpr_printer_prepare_for_print (GtkPrinter       *printer,
-			       GtkPrintJob      *print_job,
-			       GtkPrintSettings *settings,
-			       GtkPageSetup     *page_setup)
-{
-  double scale;
-
-  print_job->print_pages = gtk_print_settings_get_print_pages (settings);
-  print_job->page_ranges = NULL;
-  print_job->num_page_ranges = 0;
-  
-  if (print_job->print_pages == GTK_PRINT_PAGES_RANGES)
-    print_job->page_ranges =
-      gtk_print_settings_get_page_ranges (settings,
-					  &print_job->num_page_ranges);
-  
-  print_job->collate = gtk_print_settings_get_collate (settings);
-  print_job->reverse = gtk_print_settings_get_reverse (settings);
-  print_job->num_copies = gtk_print_settings_get_n_copies (settings);
-  print_job->number_up = gtk_print_settings_get_number_up (settings);
-  print_job->number_up_layout = gtk_print_settings_get_number_up_layout (settings);
-
-  scale = gtk_print_settings_get_scale (settings);
-  if (scale != 100.0)
-    print_job->scale = scale/100.0;
-
-  print_job->page_set = gtk_print_settings_get_page_set (settings);
-  print_job->rotate_to_orientation = TRUE;
-}
diff --git a/modules/printbackends/lpr/gtkprintbackendlpr.h b/modules/printbackends/lpr/gtkprintbackendlpr.h
deleted file mode 100644
index 51c529a..0000000
--- a/modules/printbackends/lpr/gtkprintbackendlpr.h
+++ /dev/null
@@ -1,43 +0,0 @@
-/* GTK - The GIMP Toolkit
- * gtkprintbackendlpr.h: LPR implementation of GtkPrintBackend 
- * for printing to lpr 
- * Copyright (C) 2006, 2007 Red Hat, Inc.
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-#ifndef __GTK_PRINT_BACKEND_LPR_H__
-#define __GTK_PRINT_BACKEND_LPR_H__
-
-#include <glib-object.h>
-#include "gtkprintbackend.h"
-
-G_BEGIN_DECLS
-
-#define GTK_TYPE_PRINT_BACKEND_LPR            (gtk_print_backend_lpr_get_type ())
-#define GTK_PRINT_BACKEND_LPR(obj)             (G_TYPE_CHECK_INSTANCE_CAST ((obj), GTK_TYPE_PRINT_BACKEND_LPR, GtkPrintBackendLpr))
-#define GTK_IS_PRINT_BACKEND_LPR(obj)          (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GTK_TYPE_PRINT_BACKEND_LPR))
-
-typedef struct _GtkPrintBackendLpr      GtkPrintBackendLpr;
-
-GtkPrintBackend *gtk_print_backend_lpr_new      (void);
-GType          gtk_print_backend_lpr_get_type (void) G_GNUC_CONST;
-
-G_END_DECLS
-
-#endif /* __GTK_PRINT_BACKEND_LPR_H__ */
-
-
diff --git a/modules/printbackends/papi/Makefile.am b/modules/printbackends/papi/Makefile.am
deleted file mode 100644
index 671055b..0000000
--- a/modules/printbackends/papi/Makefile.am
+++ /dev/null
@@ -1,31 +0,0 @@
-
-INCLUDES = \
-	-I$(top_srcdir) 				\
-	-I$(top_srcdir)/gtk				\
-	-I$(top_builddir)/gtk				\
-	-I$(top_srcdir)/gdk				\
-	-I$(top_builddir)/gdk				\
-	-DGTK_PRINT_BACKEND_ENABLE_UNSUPPORTED		\
-	$(GTK_DEP_CFLAGS)				\
-	$(GTK_DEBUG_FLAGS)
-
-LDADDS = \
-	$(GTK_DEP_LIBS)					\
-	$(top_builddir)/gtk/$(gtktargetlib)		
-
-backenddir = $(libdir)/gtk-2.0/$(GTK_BINARY_VERSION)/printbackends
-
-backend_LTLIBRARIES = libprintbackend-papi.la
-
-libprintbackend_papi_la_SOURCES =	\
-	gtkprinterpapi.c		\
-	gtkprintbackendpapi.c
-
-noinst_HEADERS =			\
-	gtkprinterpapi.h		\
-	gtkprintbackendpapi.h
-
-libprintbackend_papi_la_LDFLAGS =  -avoid-version -module $(no_undefined)
-libprintbackend_papi_la_LIBADD = $(LDADDS) -lpapi
-
--include $(top_srcdir)/git.mk
diff --git a/modules/printbackends/papi/gtkprintbackendpapi.c b/modules/printbackends/papi/gtkprintbackendpapi.c
deleted file mode 100644
index d349010..0000000
--- a/modules/printbackends/papi/gtkprintbackendpapi.c
+++ /dev/null
@@ -1,863 +0,0 @@
-/* GTK - The GIMP Toolkit
- * gtkprintbackendpapi.c: Default implementation of GtkPrintBackend 
- * for printing to papi 
- * Copyright (C) 2003, Red Hat, Inc.
- * Copyright (C) 2009, Sun Microsystems, Inc.
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-#include <unistd.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <fcntl.h>
-#include <stdlib.h>
-#include <string.h>
-#include <papi.h>
-
-#include <config.h>
-#include <errno.h>
-#include <cairo.h>
-#include <cairo-ps.h>
-
-#include "gtk/gtkintl.h"
-
-#include "gtk.h"
-#include "gtkprintbackendpapi.h"
-#include "gtkprinterpapi.h"
-#include "gtkprinter-private.h"
-
-typedef struct _GtkPrintBackendPapiClass GtkPrintBackendPapiClass;
-
-#define GTK_PRINT_BACKEND_PAPI_CLASS(klass)     (G_TYPE_CHECK_CLASS_CAST ((klass), GTK_TYPE_PRINT_BACKEND_PAPI, GtkPrintBackendPapiClass))
-#define GTK_IS_PRINT_BACKEND_PAPI_CLASS(klass)  (G_TYPE_CHECK_CLASS_TYPE ((klass), GTK_TYPE_PRINT_BACKEND_PAPI))
-#define GTK_PRINT_BACKEND_PAPI_GET_CLASS(obj)   (G_TYPE_INSTANCE_GET_CLASS ((obj), GTK_TYPE_PRINT_BACKEND_PAPI, GtkPrintBackendPapiClass))
-
-#define _PAPI_MAX_CHUNK_SIZE 8192
-
-static GType print_backend_papi_type = 0;
-
-struct _GtkPrintBackendPapiClass
-{
-  GtkPrintBackendClass parent_class;
-};
-
-struct _GtkPrintBackendPapi
-{
-  GtkPrintBackend parent_instance;
-
-  char *default_printer;  
-};
-
-typedef struct {
-  GtkPrinter *printer;
-} _PrinterStatus;
-
-static GObjectClass *backend_parent_class;
-
-static void                 gtk_print_backend_papi_class_init      (GtkPrintBackendPapiClass *class);
-static void                 gtk_print_backend_papi_init            (GtkPrintBackendPapi      *impl);
-static void                 gtk_print_backend_papi_finalize        (GObject                  *object);
-static void                 gtk_print_backend_papi_dispose         (GObject                  *object);
-static void                 papi_request_printer_list              (GtkPrintBackend          *print_backend);
-static gboolean 	    papi_get_printer_list 		   (GtkPrintBackendPapi      *papi_backend);
-static void                 papi_printer_request_details           (GtkPrinter               *printer);
-static GtkPrintCapabilities papi_printer_get_capabilities          (GtkPrinter               *printer);
-static void                 papi_printer_get_settings_from_options (GtkPrinter               *printer,
-								   GtkPrinterOptionSet       *options,
-								   GtkPrintSettings          *settings);
-static GtkPrinterOptionSet *papi_printer_get_options               (GtkPrinter               *printer,
-								   GtkPrintSettings          *settings,
-								   GtkPageSetup              *page_setup,
-								   GtkPrintCapabilities       capabilities);
-static void                 papi_printer_prepare_for_print         (GtkPrinter               *printer,
-								   GtkPrintJob               *print_job,
-								   GtkPrintSettings          *settings,
-								   GtkPageSetup              *page_setup);
-static cairo_surface_t *    papi_printer_create_cairo_surface      (GtkPrinter               *printer,
-								   GtkPrintSettings          *settings,
-								   gdouble                   width,
-								   gdouble                   height,
-								   GIOChannel                *cache_io);
-static void                 gtk_print_backend_papi_print_stream    (GtkPrintBackend          *print_backend,
-								   GtkPrintJob               *job,
-								   GIOChannel                *data_io,
-								   GtkPrintJobCompleteFunc   callback,
-								   gpointer                  user_data,
-								   GDestroyNotify            dnotify);
-
-static gboolean             papi_display_printer_status            (gpointer user_data);
-static void                 papi_display_printer_status_done       (gpointer user_data);
-
-static void
-gtk_print_backend_papi_register_type (GTypeModule *module)
-{
-  const GTypeInfo print_backend_papi_info =
-  {
-    sizeof (GtkPrintBackendPapiClass),
-    NULL,		/* base_init */
-    NULL,		/* base_finalize */
-    (GClassInitFunc) gtk_print_backend_papi_class_init,
-    NULL,		/* class_finalize */
-    NULL,		/* class_data */
-    sizeof (GtkPrintBackendPapi),
-    0,		/* n_preallocs */
-    (GInstanceInitFunc) gtk_print_backend_papi_init,
-  };
-
-  print_backend_papi_type = g_type_module_register_type (module,
-                                                        GTK_TYPE_PRINT_BACKEND,
-                                                        "GtkPrintBackendPapi",
-                                                        &print_backend_papi_info, 0);
-}
-
-G_MODULE_EXPORT void 
-pb_module_init (GTypeModule *module)
-{
-  gtk_print_backend_papi_register_type (module);
-  gtk_printer_papi_register_type (module);
-}
-
-G_MODULE_EXPORT void 
-pb_module_exit (void)
-{
-
-}
-  
-G_MODULE_EXPORT GtkPrintBackend * 
-pb_module_create (void)
-{
-  return gtk_print_backend_papi_new ();
-}
-
-/*
- * GtkPrintBackendPapi
- */
-GType
-gtk_print_backend_papi_get_type (void)
-{
-  return print_backend_papi_type;
-}
-
-/**
- * gtk_print_backend_papi_new:
- *
- * Creates a new #GtkPrintBackendPapi object. #GtkPrintBackendPapi
- * implements the #GtkPrintBackend interface with direct access to
- * the filesystem using Unix/Linux API calls
- *
- * Return value: the new #GtkPrintBackendPapi object
- **/
-GtkPrintBackend *
-gtk_print_backend_papi_new (void)
-{
-  return g_object_new (GTK_TYPE_PRINT_BACKEND_PAPI, NULL);
-}
-
-static void
-gtk_print_backend_papi_class_init (GtkPrintBackendPapiClass *class)
-{
-  GObjectClass *gobject_class = G_OBJECT_CLASS (class);
-  GtkPrintBackendClass *backend_class = GTK_PRINT_BACKEND_CLASS (class);
-  
-  backend_parent_class = g_type_class_peek_parent (class);
-
-  gobject_class->finalize = gtk_print_backend_papi_finalize;
-  gobject_class->dispose = gtk_print_backend_papi_dispose;
-
-  backend_class->request_printer_list = papi_request_printer_list;
-  backend_class->printer_request_details = papi_printer_request_details;
-  backend_class->printer_get_capabilities = papi_printer_get_capabilities;
-  backend_class->printer_get_options = papi_printer_get_options;
-  backend_class->printer_get_settings_from_options = papi_printer_get_settings_from_options;
-  backend_class->printer_prepare_for_print = papi_printer_prepare_for_print;
-  backend_class->printer_create_cairo_surface = papi_printer_create_cairo_surface;
-  backend_class->print_stream = gtk_print_backend_papi_print_stream;
-}
-
-static cairo_status_t
-_cairo_write (void                *closure,
-              const unsigned char *data,
-              unsigned int         length)
-{
-  GIOChannel *io = (GIOChannel *)closure;
-  gsize written;
-  GError *error = NULL;
-
-  GTK_NOTE (PRINTING,
-            g_print ("PAPI Backend: Writting %i byte chunk to temp file\n", length));
-
-  while (length > 0) 
-    {
-      g_io_channel_write_chars (io, (char *)data, length, &written, &error);
-
-      if (error != NULL)
-	{
-	  GTK_NOTE (PRINTING,
-                     g_print ("PAPI Backend: Error writting to temp file, %s\n", error->message));
-
-          g_error_free (error);
-	  return CAIRO_STATUS_WRITE_ERROR;
-	}    
-
-      GTK_NOTE (PRINTING,
-                g_print ("PAPI Backend: Wrote %i bytes to temp file\n", written));
-
-      data += written;
-      length -= written;
-    }
-
-  return CAIRO_STATUS_SUCCESS;
-}
-
-static cairo_surface_t *
-papi_printer_create_cairo_surface (GtkPrinter       *printer,
-				  GtkPrintSettings *settings,
-				  gdouble           width, 
-				  gdouble           height,
-				  GIOChannel       *cache_io)
-{
-  cairo_surface_t *surface;
-  
-  surface = cairo_ps_surface_create_for_stream (_cairo_write, cache_io, width, height);
-
-  cairo_surface_set_fallback_resolution (surface,
-                                         2.0 * gtk_print_settings_get_printer_lpi (settings),
-                                         2.0 * gtk_print_settings_get_printer_lpi (settings));
-
-  return surface;
-}
-
-typedef struct {
-  GtkPrintBackend *backend;
-  GtkPrintJobCompleteFunc callback;
-  GtkPrintJob *job;
-  gpointer user_data;
-  GDestroyNotify dnotify;
-
-  papi_service_t service;
-  papi_stream_t stream;
-} _PrintStreamData;
-
-static void
-papi_print_cb (GtkPrintBackendPapi *print_backend,
-              GError             *error,
-              gpointer            user_data)
-{
-  _PrintStreamData *ps = (_PrintStreamData *) user_data;
-
-  if (ps->callback)
-    ps->callback (ps->job, ps->user_data, error);
-
-  if (ps->dnotify)
-    ps->dnotify (ps->user_data);
-
-  gtk_print_job_set_status (ps->job, 
-			    error ? GTK_PRINT_STATUS_FINISHED_ABORTED 
-			          : GTK_PRINT_STATUS_FINISHED);
-
-  if (ps->job)
-    g_object_unref (ps->job);
-  
-  g_free (ps);
-}
-
-static gboolean
-papi_write (GIOChannel   *source,
-           GIOCondition  con,
-           gpointer      user_data)
-{
-  gchar buf[_PAPI_MAX_CHUNK_SIZE];
-  gsize bytes_read;
-  GError *error;
-  GIOStatus status;
-  _PrintStreamData *ps = (_PrintStreamData *) user_data;
-  papi_job_t job = NULL;
-
-  error = NULL;
-  status = g_io_channel_read_chars (source,
-                                    buf,
-                                    _PAPI_MAX_CHUNK_SIZE,
-                                    &bytes_read,
-                                    &error);
-
-  /* Keep writing to PAPI input stream while there are data */
-  if (status != G_IO_STATUS_ERROR)
-  {
-     papiJobStreamWrite (ps->service, ps->stream, buf, bytes_read);
-  }
-  
-  /* Finish reading input stream data. Closing the stream and handle to service */
-  if (bytes_read == 0) {
-     papiJobStreamClose (ps->service, ps->stream, &job);
-     ps->stream = NULL;
-     papiJobFree (job);
-     papiServiceDestroy (ps->service);
-     ps->service = NULL;
-  }
-
-  if (error != NULL || status == G_IO_STATUS_EOF)
-    {
-      papi_print_cb (GTK_PRINT_BACKEND_PAPI (ps->backend), 
-		    error, user_data);
-
-      if (error)
-	g_error_free (error);
-
-      if (error != NULL)
-        {
-          GTK_NOTE (PRINTING,
-                    g_print ("PAPI Backend: %s\n", error->message));
-
-          g_error_free (error);
-        } 
-
-      return FALSE;
-    }
-
-  GTK_NOTE (PRINTING,
-            g_print ("PAPI Backend: Writting %i byte chunk to papi pipe\n", bytes_read));
-
-  return TRUE;
-}
-
-static void
-gtk_print_backend_papi_print_stream (GtkPrintBackend        *print_backend,
-				    GtkPrintJob            *job,
-				    GIOChannel             *data_io,
-				    GtkPrintJobCompleteFunc callback,
-				    gpointer                user_data,
-				    GDestroyNotify          dnotify)
-{
-  GError *print_error = NULL;
-  GtkPrinterPapi *printer;
-  _PrintStreamData *ps;
-  GtkPrintSettings *settings;
-  gint argc;  
-  gint in_fd;
-  gchar **argv = NULL; 
-  const gchar *title;
-  char *prtnm = NULL;
-  GtkPrintDuplex val;
-  papi_status_t pstatus = NULL;
-  papi_attribute_t **attrs = NULL;
-  papi_job_ticket_t *ticket = NULL;
-  
-  printer = GTK_PRINTER_PAPI (gtk_print_job_get_printer (job));
-  settings = gtk_print_job_get_settings (job);
-
-  /* FIXME - the title should be set as the job-name */
-  title = gtk_print_job_get_title (job);
-
-  ps = g_new0 (_PrintStreamData, 1);
-  ps->callback = callback;
-  ps->user_data = user_data;
-  ps->dnotify = dnotify;
-  ps->job = g_object_ref (job);
-  ps->service = NULL;
-  ps->stream = NULL;
-
-   /* This cannot be queried yet with the current API */
-  papiAttributeListAddString (&attrs, PAPI_ATTR_EXCL, "document-format", "application/postscript");
-  val =  gtk_print_settings_get_duplex (settings) ;
-  if (val == GTK_PRINT_DUPLEX_HORIZONTAL)
-    papiAttributeListAddString (&attrs, PAPI_ATTR_EXCL, "Duplex", "DuplexNoTumble");
-  else if (val == GTK_PRINT_DUPLEX_VERTICAL)
-    papiAttributeListAddString (&attrs, PAPI_ATTR_EXCL, "Duplex", "DuplexTumble");
-
-  if (job->num_copies > 1) 
-    {
-      papiAttributeListAddInteger (&attrs, PAPI_ATTR_EXCL, "copies", job->num_copies); 
-    }
-
-  prtnm = strdup (gtk_printer_get_name (GTK_PRINTER(printer)));
-
-  if (papiServiceCreate (&(ps->service), prtnm, NULL, NULL, NULL,
-                         PAPI_ENCRYPT_NEVER, NULL) != PAPI_OK)
-    return;
-
-  pstatus = papiJobStreamOpen (ps->service, prtnm, attrs, ticket, &(ps->stream));
-  if (pstatus != PAPI_OK)
-    {
-      papiServiceDestroy (ps->service);
-      ps->service = NULL;
-      return;
-    }
-
-  /* Everything set up fine, so get ready to wait for input data stream */
-  g_io_add_watch (data_io,
-                  G_IO_IN | G_IO_PRI | G_IO_ERR | G_IO_HUP,
-                  (GIOFunc) papi_write,
-                  ps);
-}
-
-
-static void
-_papi_set_default_printer (GtkPrintBackendPapi *backend)
-{
-  char *def_printer = NULL;
-  char *_default_attr[] = { "printer-name", NULL };
-  papi_service_t service = NULL;
-  papi_printer_t default_printer = NULL;
-  papi_attribute_t **attrs = NULL;
-
-  if (papiServiceCreate (&service, NULL, NULL, NULL, NULL, PAPI_ENCRYPT_NEVER,
-                          NULL) != PAPI_OK)
-    return;
-
-  if (papiPrinterQuery (service, "_default", _default_attr, NULL, 
-                        &default_printer) == PAPI_OK)  
-    {
-      if (default_printer != NULL)  
-        {
-          attrs = papiPrinterGetAttributeList (default_printer);
-
-          if (attrs != NULL)
-            if (papiAttributeListGetString (attrs, NULL, "printer-name", 
-                                            &def_printer) == PAPI_OK) 
-	      {
-	        backend->default_printer = strdup (def_printer);
-	      }
-        }
-    }
-
-  papiPrinterFree (default_printer);
-  papiServiceDestroy (service);
-}
-
-static void
-gtk_print_backend_papi_init (GtkPrintBackendPapi *backend)
-{
-  _papi_set_default_printer (backend);
-}
-
-static void
-gtk_print_backend_papi_finalize (GObject *object)
-{
-  GtkPrintBackendPapi *backend_papi;
-
-  GTK_NOTE (PRINTING,
-            g_print ("PAPI Backend: finalizing PAPI backend module\n"));
-
-  backend_papi = GTK_PRINT_BACKEND_PAPI (object);
-
-  g_free (backend_papi->default_printer);
-  backend_papi->default_printer = NULL;
-
-  backend_parent_class->finalize (object);
-}
-
-
-static void
-gtk_print_backend_papi_dispose (GObject *object)
-{
-  GtkPrintBackendPapi *backend_papi;
-
-  GTK_NOTE (PRINTING,
-            g_print ("PAPI Backend: %s\n", G_STRFUNC));
-
-  backend_papi = GTK_PRINT_BACKEND_PAPI (object);
-
-  backend_parent_class->dispose (object);
-}
-
-char **
-get_all_list(papi_service_t svc)
-{
-        papi_status_t status;
-        papi_printer_t printer = NULL;
-        char *attr[] = { "member-names", NULL };
-        char **names = NULL;
-
-        status = papiPrinterQuery(svc, "_all", attr, NULL, &printer);
-        if ((status == PAPI_OK) && (printer != NULL)) {
-                papi_attribute_t **attributes =
-                                        papiPrinterGetAttributeList(printer);
-                if (attributes != NULL) {
-                        void *iter = NULL;
-                        char *member = NULL;
-
-                        for (status = papiAttributeListGetString(attributes,
-                                                &iter, "member-names", &member);
-                                status == PAPI_OK;
-                                status = papiAttributeListGetString(attributes,
-                                                &iter, NULL, &member))
-                                        list_append(&names, strdup(member));
-                }
-                papiPrinterFree(printer);
-        }
-
-        return (names);
-}
-
-static char **
-get_printers_list(papi_service_t svc)
-{
-	papi_status_t status;
-    	papi_printer_t *printers = NULL;
-    	char *keys[] = { "printer-name", "printer-uri-supported", NULL };
-    	char **names = NULL;
-
-	status = papiPrintersList(svc, keys, NULL, &printers);
-	if ((status == PAPI_OK) && (printers != NULL)) {
-		int i;
-
-		for (i = 0; printers[i] != NULL; i++) {
-			papi_attribute_t **attributes =
-				papiPrinterGetAttributeList(printers[i]);
-    			char *name = NULL;
-			
-			(void) papiAttributeListGetString(attributes, NULL,
-							"printer-name", &name);
-			if ((name != NULL) && (strcmp(name, "_default") != 0))
-    				list_append(&names, strdup(name));
-    		}
-    		papiPrinterListFree(printers);
-    	}
-    
-    	return (names);
-}
-
-static void
-papi_request_printer_list (GtkPrintBackend *backend)
-{
-  GtkPrintBackendPapi *papi_backend;
-
-  papi_backend = GTK_PRINT_BACKEND_PAPI (backend);
-
-  /* Get the list of printers using papi API */
-  papi_get_printer_list (papi_backend); 
-}
-
-static gboolean
-papi_get_printer_list (GtkPrintBackendPapi *papi_backend)
-{
-  int i;
-  const char *attributes[] =  /* Attributes we're interested in */
-    {
-      "printer-name",
-      "printer-uri-supported",
-      NULL
-    };
-  papi_status_t status, status2;
-  papi_service_t service = NULL;
-  char **printers = NULL;
-  GtkPrinter *printer;
-  GtkPrinterPapi *papi_printer;
-  GList *current_printer_list;
-  GtkPrintBackend *backend = GTK_PRINT_BACKEND (papi_backend);
-  
-  if ((status = papiServiceCreate (&service, NULL, NULL, NULL, NULL,
-		PAPI_ENCRYPT_NEVER, NULL)) != PAPI_OK)
-    return FALSE; 
-
-  if ((printers = get_all_list (service)) == NULL) 
-    {
-      printers = get_printers_list (service);
-    }
-
-  if (printers == NULL) 
-    {
-      papiServiceDestroy (service);
-      return FALSE;
-    }
-
-  for (i = 0; printers[i] != NULL; i++) 
-    {
-      GtkPrinter *printer;
-      char *name = NULL, *url = NULL;
-      papi_attribute_t **attrs = NULL;
-
-          printer = gtk_print_backend_find_printer (backend, printers[i]);
-
-	  if (!printer) 
-	    {
-              /* skip null printer name just in case */
-              if (printers[i] == NULL)
-                continue;
-
-	      /* skip the alias _default and _all printers */
-      	      if (strcmp(printers[i], "_default")==0 || strcmp(printers[i], "_all")==0)
-	        continue;	
-
-	      papi_printer = gtk_printer_papi_new (printers[i], backend);
-	      printer = GTK_PRINTER (papi_printer);
-
-	      /* Only marked default printer to not have details so that
-		 the request_details method will be called  at start up
-	       */
-
-	      if (papi_backend->default_printer != NULL)
-	        if (strcmp (printers[i], papi_backend->default_printer)==0)
-		  {
-		    gtk_printer_set_is_default (printer, TRUE);
-	  	  }	
-
-              gtk_printer_set_icon_name (printer, "gtk-print");
-	      gtk_print_backend_add_printer (backend, printer);
-              gtk_printer_set_is_active (printer, TRUE);
-
-  	      /* gtk_printer_set_has_details (printer, TRUE); */
-	    }
-    	  else 
-            g_object_ref (printer);
-
-      if (!gtk_printer_is_active (printer))
-        {
-          gtk_printer_set_is_active (printer, TRUE);
-          gtk_printer_set_is_new (printer, TRUE);
-        }
-
-      if (gtk_printer_is_new (printer))
-        {
-          g_signal_emit_by_name (backend, "printer-added", printer);
-          gtk_printer_set_is_new (printer, FALSE);
-        }
-
-      g_object_unref (printer);
-    }
-
-  free (printers);
-  papiServiceDestroy (service);
-
-  /* To set that the list of printers added is complete */
-  gtk_print_backend_set_list_done (backend); 
-
-  return TRUE;
-}
-
-static void
-update_printer_status (GtkPrinter *printer)
-{
-  GtkPrintBackend *backend;
-  GtkPrinterPapi *papi_printer;
-  gboolean status_changed = FALSE;
-
-  backend = gtk_printer_get_backend (printer);
-  papi_printer = GTK_PRINTER_PAPI (printer);
-
-  /* if (status_changed) */
-    g_signal_emit_by_name (GTK_PRINT_BACKEND (backend),
-                           "printer-status-changed", printer);
-
-}
-
-
-static GtkPrinterOptionSet *
-papi_printer_get_options (GtkPrinter           *printer,
-			  GtkPrintSettings     *settings,
-			  GtkPageSetup         *page_setup,
-			  GtkPrintCapabilities  capabilities)
-{
-  GtkPrinterOptionSet *set;
-  GtkPrinterOption *option;
-  int i;
-  char *print_at[] = { "now", "on-hold" };
-  char *n_up[] = {"1"};
-
-  /* Update the printer status before the printer options are displayed */
-  update_printer_status (printer); 
-
-  set = gtk_printer_option_set_new ();
-
-  /* non-ppd related settings */
-
-  /* This maps to number-up-supported in PAPI. FIXME 
-   * number-up-default is the default value. 
-   * number-up-supported is the list of number of able to print per page 
-   */
-  option = gtk_printer_option_new ("gtk-n-up", "Pages Per Sheet", GTK_PRINTER_OPTION_TYPE_PICKONE);
-  gtk_printer_option_choices_from_array (option, G_N_ELEMENTS (n_up),
-					 n_up, n_up);
-  gtk_printer_option_set (option, "1");
-  gtk_printer_option_set_add (set, option);
-  g_object_unref (option);
-
-  /* This maps to job-priority-supported and job-priority-default in PAPI - FIXME*/
-  
-  /* This relates to job-sheets-supported in PAPI  FIXME*/
-  
-  /* This relates to job-hold-until-supported in PAPI */
-  option = gtk_printer_option_new ("gtk-print-time", "Print at", GTK_PRINTER_OPTION_TYPE_PICKONE);
-  gtk_printer_option_choices_from_array (option, G_N_ELEMENTS (print_at),
-					 print_at, print_at);
-  gtk_printer_option_set (option, "now");
-  gtk_printer_option_set_add (set, option);
-  g_object_unref (option);
-  
-  return set;
-}
-
-static void
-papi_printer_get_settings_from_options (GtkPrinter          *printer,
-				       GtkPrinterOptionSet *options,
-				       GtkPrintSettings    *settings)
-{
-  GtkPrinterOption *option;
-
-  option = gtk_printer_option_set_lookup (options, "gtk-n-up");
-  if (option)
-     gtk_print_settings_set (settings, GTK_PRINT_SETTINGS_NUMBER_UP, option->value);
-
-}
-
-static void
-papi_printer_prepare_for_print (GtkPrinter       *printer,
-			       GtkPrintJob      *print_job,
-			       GtkPrintSettings *settings,
-			       GtkPageSetup     *page_setup)
-{
-  GtkPageSet page_set;
-  double scale;
-  GtkPaperSize *papersize = NULL;
-  char *ppd_paper_name;
-
-  print_job->print_pages = gtk_print_settings_get_print_pages (settings);
-  print_job->page_ranges = NULL;
-  print_job->num_page_ranges = 0;
-  
-  if (print_job->print_pages == GTK_PRINT_PAGES_RANGES)
-    print_job->page_ranges =
-      gtk_print_settings_get_page_ranges (settings,
-					  &print_job->num_page_ranges);
-  
-  print_job->collate = gtk_print_settings_get_collate (settings);
-  print_job->reverse = gtk_print_settings_get_reverse (settings);
-  print_job->num_copies = gtk_print_settings_get_n_copies (settings);
- 
-  scale = gtk_print_settings_get_scale (settings);
-  if (scale != 100.0)
-    print_job->scale = scale/100.0;
-
-  papersize = gtk_page_setup_get_paper_size (page_setup);
-  ppd_paper_name = gtk_paper_size_get_ppd_name (papersize);
-
-  page_set = gtk_print_settings_get_page_set (settings);
-  if (page_set == GTK_PAGE_SET_EVEN)
-    print_job->page_set = GTK_PAGE_SET_EVEN;
-  else if (page_set == GTK_PAGE_SET_ODD)
-    print_job->page_set = GTK_PAGE_SET_ODD;
-  else
-    print_job->page_set = GTK_PAGE_SET_ALL;
-
-  print_job->rotate_to_orientation = TRUE;
-
-}
-
-gboolean
-is_local_printer (gchar *printer_uri)
-{
-  if (strncmp (printer_uri, "lpsched:", 8) == 0)
-    return TRUE;
-  else
-    return FALSE;
-}
-
-void
-merge_ppd_data (papi_attribute_t ***attributes, gchar *ppdfile)
-{
-  get_ppd_attrs (attributes, ppdfile);
-}
-
-
-static void
-papi_display_printer_status_done (gpointer user_data)
-{
-  GtkPrinter *printer = (GtkPrinter *) user_data;
-  GtkPrinterPapi *papi_printer;
-
-  g_signal_emit_by_name (printer, "details-acquired", TRUE); 
-  papi_printer = GTK_PRINTER_PAPI (printer);
-  return;
-}
-
-#define IDLE 3
-#define PROCESSING 4
-#define STOPPED 5
-static gboolean
-papi_display_printer_status (gpointer user_data)
-{
-  GtkPrinter *printer = (GtkPrinter *) user_data;
-  GtkPrinterPapi *papi_printer;
-  gchar *loc, *printer_uri, *ppdfile;
-  int state;
-  papi_service_t service;
-  papi_attribute_t **attrs = NULL;
-  papi_printer_t current_printer = NULL;
-  static int count = 0;
-
-  papi_printer = GTK_PRINTER_PAPI (printer);
-  if (papiServiceCreate (&service, NULL, NULL, NULL, NULL, PAPI_ENCRYPT_NEVER,
-                          NULL) != PAPI_OK)
-    return FALSE;
-
-  if (papiPrinterQuery (service, papi_printer->printer_name, NULL, NULL,
-                        &current_printer) != PAPI_OK) 
-    {
-       /* SUN_BRANDING */
-       gtk_printer_set_state_message (printer, _("printer offline"));
-    }
-
-  if (current_printer != NULL)
-    {
-        attrs = papiPrinterGetAttributeList (current_printer);
-    }
-
-  if (papiAttributeListGetString (attrs, NULL, "printer-info", &loc) == PAPI_OK)
-    {
-        gtk_printer_set_location (printer, loc);
-    }
-
-  if (papiAttributeListGetInteger (attrs, NULL, "printer-state", &state) == PAPI_OK)
-    {
-      switch (state) 
-        {
-	  /* SUN_BRANDING */
-	  case IDLE: gtk_printer_set_state_message (printer, _("ready to print"));
-		     break;
-	  /* SUN_BRANDING */
-	  case PROCESSING: gtk_printer_set_state_message (printer, _("processing job"));
-		           break;
-
-	  /* SUN_BRANDING */
-	  case STOPPED: gtk_printer_set_state_message (printer, _("paused"));
-		        break;
-	  /* SUN_BRANDING */
-	  default: gtk_printer_set_state_message (printer, _("unknown"));
-		   break;
-        }
-    }
-
-  papiPrinterFree (current_printer);
-  papiServiceDestroy (service);
-  gtk_printer_set_has_details (printer, TRUE);
-
-  return FALSE;
-}
-
-static void  
-papi_printer_request_details (GtkPrinter *printer)
-{
-  g_idle_add_full (G_PRIORITY_DEFAULT_IDLE, papi_display_printer_status, printer, papi_display_printer_status_done); 
-}
-
-
-static GtkPrintCapabilities
-papi_printer_get_capabilities (GtkPrinter *printer)
-{
-  return GTK_PRINT_CAPABILITY_COPIES | GTK_PRINT_CAPABILITY_PAGE_SET ; 
-}
-
diff --git a/modules/printbackends/papi/gtkprintbackendpapi.h b/modules/printbackends/papi/gtkprintbackendpapi.h
deleted file mode 100644
index 4eba665..0000000
--- a/modules/printbackends/papi/gtkprintbackendpapi.h
+++ /dev/null
@@ -1,44 +0,0 @@
-/* GTK - The GIMP Toolkit
- * gtkprintbackendpapi.h: Default implementation of GtkPrintBackend 
- * for printing to papi 
- * Copyright (C) 2003, Red Hat, Inc.
- * Copyright (C) 2009, Sun Microsystems, Inc.
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-#ifndef __GTK_PRINT_BACKEND_PAPI_H__
-#define __GTK_PRINT_BACKEND_PAPI_H__
-
-#include <glib-object.h>
-#include "gtkprintbackend.h"
-
-G_BEGIN_DECLS
-
-#define GTK_TYPE_PRINT_BACKEND_PAPI            (gtk_print_backend_papi_get_type ())
-#define GTK_PRINT_BACKEND_PAPI(obj)             (G_TYPE_CHECK_INSTANCE_CAST ((obj), GTK_TYPE_PRINT_BACKEND_PAPI, GtkPrintBackendPapi))
-#define GTK_IS_PRINT_BACKEND_PAPI(obj)          (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GTK_TYPE_PRINT_BACKEND_PAPI))
-
-typedef struct _GtkPrintBackendPapi      GtkPrintBackendPapi;
-
-GtkPrintBackend *gtk_print_backend_papi_new      (void);
-GType          gtk_print_backend_papi_get_type (void) G_GNUC_CONST;
-
-G_END_DECLS
-
-#endif /* __GTK_PRINT_BACKEND_PAPI_H__ */
-
-
diff --git a/modules/printbackends/papi/gtkprinterpapi.c b/modules/printbackends/papi/gtkprinterpapi.c
deleted file mode 100644
index 979c428..0000000
--- a/modules/printbackends/papi/gtkprinterpapi.c
+++ /dev/null
@@ -1,116 +0,0 @@
-/* GtkPrinterPapi
- * Copyright (C) 2006 John (J5) Palmieri  <johnp@redhat.com>
- * Copyright (C) 2009 Ghee Teo <ghee.teo@sun.com>
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-#include "config.h"
-#include "gtkprinterpapi.h"
-
-static void gtk_printer_papi_init       (GtkPrinterPapi      *printer);
-static void gtk_printer_papi_class_init (GtkPrinterPapiClass *class);
-static void gtk_printer_papi_finalize   (GObject             *object);
-
-static GtkPrinterClass *gtk_printer_papi_parent_class;
-static GType gtk_printer_papi_type = 0;
-
-void 
-gtk_printer_papi_register_type (GTypeModule *module)
-{
-  const GTypeInfo object_info =
-  {
-    sizeof (GtkPrinterPapiClass),
-    (GBaseInitFunc) NULL,
-    (GBaseFinalizeFunc) NULL,
-    (GClassInitFunc) gtk_printer_papi_class_init,
-    NULL,           /* class_finalize */
-    NULL,           /* class_data */
-    sizeof (GtkPrinterPapi),
-    0,              /* n_preallocs */
-    (GInstanceInitFunc) gtk_printer_papi_init,
-  };
-
- gtk_printer_papi_type = g_type_module_register_type (module,
-                                                      GTK_TYPE_PRINTER,
-                                                      "GtkPrinterPapi",
-                                                      &object_info, 0);
-}
-
-GType
-gtk_printer_papi_get_type (void)
-{
-  return gtk_printer_papi_type;
-}
-
-static void
-gtk_printer_papi_class_init (GtkPrinterPapiClass *class)
-{
-  GObjectClass *object_class = (GObjectClass *) class;
-	
-  gtk_printer_papi_parent_class = g_type_class_peek_parent (class);
-
-  object_class->finalize = gtk_printer_papi_finalize;
-}
-
-static void
-gtk_printer_papi_init (GtkPrinterPapi *printer)
-{
-  printer->printer_name = NULL;
-}
-
-static void
-gtk_printer_papi_finalize (GObject *object)
-{
-  GtkPrinterPapi *printer;
-
-  g_return_if_fail (object != NULL);
-
-  printer = GTK_PRINTER_PAPI (object);
-
-  g_free(printer->printer_name);
-
-  G_OBJECT_CLASS (gtk_printer_papi_parent_class)->finalize (object);
-}
-
-/**
- * gtk_printer_papi_new:
- *
- * Creates a new #GtkPrinterPapi.
- *
- * Return value: a new #GtkPrinterPapi
- *
- * Since: 2.10
- **/
-GtkPrinterPapi *
-gtk_printer_papi_new (const char      *name,
-		      GtkPrintBackend *backend)
-{
-  GObject *result;
-  GtkPrinterPapi *pp;
-  
-  result = g_object_new (GTK_TYPE_PRINTER_PAPI,
-			 "name", name,
-			 "backend", backend,
-			 "is-virtual", TRUE,
-                         NULL);
-  pp = GTK_PRINTER_PAPI(result);
-
-  pp->printer_name = g_strdup (name);
-
-  return (GtkPrinterPapi *) pp;
-}
-
diff --git a/modules/printbackends/papi/gtkprinterpapi.h b/modules/printbackends/papi/gtkprinterpapi.h
deleted file mode 100644
index 300cf17..0000000
--- a/modules/printbackends/papi/gtkprinterpapi.h
+++ /dev/null
@@ -1,61 +0,0 @@
-/* GtkPrinterPapi
- * Copyright (C) 2006 John (J5) Palmieri <johnp@redhat.com>
- * Copyright (C) 2009 Ghee Teo <ghee.teo@sun.com>
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-#ifndef __GTK_PRINTER_PAPI_H__
-#define __GTK_PRINTER_PAPI_H__
-
-#include <glib.h>
-#include <glib-object.h>
-#include <papi.h>
-
-#include "gtkunixprint.h"
-
-G_BEGIN_DECLS
-
-#define GTK_TYPE_PRINTER_PAPI                  (gtk_printer_papi_get_type ())
-#define GTK_PRINTER_PAPI(obj)                  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GTK_TYPE_PRINTER_PAPI, GtkPrinterPapi))
-#define GTK_PRINTER_PAPI_CLASS(klass)          (G_TYPE_CHECK_CLASS_CAST ((klass), GTK_TYPE_PRINTER_PAPI, GtkPrinterPapiClass))
-#define GTK_IS_PRINTER_PAPI(obj)               (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GTK_TYPE_PRINTER_PAPI))
-#define GTK_IS_PRINTER_PAPI_CLASS(klass)       (G_TYPE_CHECK_CLASS_TYPE ((klass), GTK_TYPE_PRINTER_PAPI))
-#define GTK_PRINTER_PAPI_GET_CLASS(obj)        (G_TYPE_INSTANCE_GET_CLASS ((obj), GTK_TYPE_PRINTER_PAPI, GtkPrinterPapiClass))
-
-typedef struct _GtkPrinterPapi	        GtkPrinterPapi;
-typedef struct _GtkPrinterPapiClass     GtkPrinterPapiClass;
-typedef struct _GtkPrinterPapiPrivate   GtkPrinterPapiPrivate;
-
-struct _GtkPrinterPapi
-{
-  GtkPrinter parent_instance;
-
-  gchar *printer_name;
-};
-
-struct _GtkPrinterPapiClass
-{
-  GtkPrinterClass parent_class;
-
-};
-
-GType                    gtk_printer_papi_get_type      (void) G_GNUC_CONST;
-void                     gtk_printer_papi_register_type (GTypeModule     *module);
-GtkPrinterPapi          *gtk_printer_papi_new           (const char      *name, GtkPrintBackend *backend);
-
-G_END_DECLS
-
-#endif /* __GTK_PRINTER_PAPI_H__ */
